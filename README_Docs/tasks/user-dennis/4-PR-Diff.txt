diff --git a/README_Docs/tasks/Bugs.md b/README_Docs/tasks/Bugs.md
index 27ebe7bb440f2b5cd8d1ecd477cea7cc3999aac6..9f9d0f1c65bd643ec46a2afcffb8295a69b1891c 100644
--- a/README_Docs/tasks/Bugs.md
+++ b/README_Docs/tasks/Bugs.md
@@ -8,6 +8,3 @@ Engineer Assigned
 
 ---
 
-
-[ ] new user signs up, lands on `/onboarding`, before they finish they go to localhost:3000 (mymcat.ai), then it instantly redirects them to `onboarding` - we shouldn't reroute based on the home page (localhost:3000) - always should always see landing page with login button **Dennis**
-
diff --git a/README_Docs/tasks/user-dennis/1-tasks-fixbug.md b/README_Docs/tasks/user-dennis/1-tasks-fixbug.md
new file mode 100644
index 0000000000000000000000000000000000000000..a284433380a669598fedc253a325a2a23131c0b9
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/1-tasks-fixbug.md
@@ -0,0 +1,169 @@
+# Onboarding Navigation Requirements
+
+
+
+## Routing Requirement
+**Routing should ONLY happen when users explicitly press the login button at the root URL**. The application should never automatically redirect users who navigate to localhost:3000 without clicking the login button.
+When users explicitly press the login button at localhost:3000 (or mymcat.ai), the application should route them to the appropriate page based on their onboarding status:
+
+When clicking the login button:
+- If `onboardingComplete` is true (user has completed onboarding), they should go to `/home`
+- If `onboardingComplete` is false (user hasn't completed onboarding), they should go to `/onboarding`
+
+The solution must handle these specific edge cases:
+1. **New User Flow**: When a new user who hasn't completed onboarding goes to the root URL and presses the login button, they should be redirected to `/onboarding`.
+
+2. **Returning User Flow**: When a returning user who has completed onboarding goes to the root URL and presses the login button, they should be redirected to `/home`.
+
+3. **Post-Login Root Navigation**: When a user who is already logged in navigates directly to the root path, they should remain at the root URL with no redirect.
+
+4. **Post-Logout Flow**: When a user logs out and then returns to the site, they should remain at the root URL with no redirect until they press the login button again.
+
+
+
+## Current onboardingComplete Explanation 
+
+This section details how we currently implement onboarding...
+
+- When a new user first interacts with the system, an `onboardingInfo` object is created in the database during the `handleNameSubmit` function in `useOnboardingInfo.ts`. This happens AFTER the user authenticates with Clerk and begins the onboarding process. Specifically, the creation occurs when they submit their name in the first onboarding step, which triggers a POST request to `/api/user-info`. 
+
+- The `onboardingInfo` object is not created empty but is initialized with a complete set of default values in the POST endpoint:
+  ```javascript
+  onboardingInfo: {
+    currentStep: 1,
+    onboardingComplete: false,
+    firstName: firstName || null,  // Uses the user-provided name
+    college: null,
+    isNonTraditional: null,
+    isCanadian: null,
+    gpa: null,
+    currentMcatScore: null,
+    hasNotTakenMCAT: null,
+    mcatAttemptNumber: null,
+    targetMedSchool: null,
+    targetScore: null,
+    referralEmail: null
+  }
+  ```
+  This ensures all fields exist from the beginning, with `onboardingComplete` explicitly set to `false` and only the `firstName` and `currentStep` having non-null values initially.
+
+- As the user progresses through each step of onboarding (name, college, academics, goals, Kalypso dialogue, referral), the `onboardingInfo` object is updated in the database via the `updateOnboardingInfo` function calling the PUT endpoint at `/api/user-info/onboarding`. Each step triggers a separate API call to update the database with:
+  - The new data specific to that step
+  - An updated `currentStep` value pointing to the next step
+  - The same `onboardingComplete: false` flag (until the final step)
+
+
+- The `onboardingComplete` flag is only toggled to true at the very end of the onboarding process, specifically in the `handleReferralComplete` function when the user completes the final step. This happens when:
+  1. User has successfully completed all previous onboarding steps
+  2. User reaches the referral step and clicks "Complete" or "Skip"
+  3. The `handleReferralComplete` function is triggered
+  
+- Before setting `onboardingComplete` to true, the system performs several validation checks:
+  1. Verifies that the onboardingInfo record exists in the database
+  2. Validates that a non-zero target score has been set (critical check)
+  3. Confirms that required fields like firstName and college are present
+  4. If any of these checks fail, the system shows an error and does not proceed
+
+
+- The actual update process follows a specific sequence:
+  1. First, make a PUT request to update the database with `onboardingComplete: true`
+  2. Wait for the database update to complete and verify it was successful
+  3. Only if the database update was confirmed successful, update the local state with `setOnboardingComplete(true)`
+  4. Then redirect the user to the appropriate page (/home or /redirect for mobile)
+
+
+- This database-first approach ensures data integrity and prevents inconsistent states between the database and client.
+
+
+- The system checks for `onboardingComplete` status in several key places:
+
+  1. **In the `useOnboardingInfo` hook's `fetchOnboardingInfo` function**:
+     - Runs when the onboarding page is first loaded in `app/(auth)/(routes)/onboarding/page.tsx`
+     - Makes an API call to `/api/user-info/onboarding` to check current onboarding status
+     - If `data?.onboardingComplete` is true from the API response, it updates local state and redirects immediately
+     - Used to resume onboarding at the correct step if the user had partially completed it
+
+  2. **In the `RouteTracker.tsx` component**:
+     - The RouteTracker component is included in the root layout (`app/layout.tsx`) and runs on every page
+     - It calculates `effectiveOnboardingComplete` by checking both the direct flag and the targetScore as a fallback
+     - Uses this information to determine if redirects are needed when users log in or navigate between pages
+     - Triggers different behavior based on explicit login clicks vs. regular navigation
+
+  3. **In the `StoreInitializer` component**:
+     - Also included in the root layout and runs on every page load 
+     - Calls `refreshUserInfo()` to load all user data including onboarding status
+     - Performs a second refresh after 1 second to ensure consistency
+     - Ensures all components have access to the current onboarding state
+
+
+## Database Synchronization Flow
+
+This section details how data synchronization occurs between the database and local state:
+
+1. **App Initialization**:
+   - The `StoreInitializer` component is included in the root layout of the application (`app/layout.tsx`)
+   - It runs on every page load, regardless of route
+   - If a user is signed in, it calls `refreshUserInfo()` to sync all user data from the database
+   - It performs a second `refreshUserInfo()` call after a 1-second delay to handle potential race conditions
+
+2. **Login Flow**:
+   - When a user clicks login at the root URL, the `explicit_login_click` flag is set in localStorage
+   - After authentication, the `StoreInitializer` detects the user is signed in and fetches user data
+   - The `RouteTracker` checks the user's `onboardingComplete` status and redirects accordingly
+
+3. **Onboarding Process**:
+   - When entering their name, a new userInfo record is created in the database via POST to `/api/user-info`
+   - Each subsequent step updates the database via PUT to `/api/user-info/onboarding`
+   - At the final step (`handleReferralComplete`), after setting `onboardingComplete: true`:
+     - The database is updated first
+     - The success of this update is explicitly verified
+     - Only then is the local state updated with `setOnboardingComplete(true)`
+     - A full `refreshUserInfo()` call is performed to ensure complete data synchronization
+     - Finally, the user is redirected to the appropriate page (/home or /redirect for mobile)
+
+4. **Home Page Load After Completion**:
+   - When redirected to home, the `StoreInitializer` runs again on page load
+   - This triggers another `refreshUserInfo()` which ensures local state is fully in sync with the database
+
+
+## Recommended Improvements
+
+This section outlines potential improvements to our current implementation that would enhance reliability, performance, and code maintainability:
+
+
+### 2. Consistent State Synchronization
+
+The following improvements have been implemented:
+- Added a full `refreshUserInfo()` call immediately after setting `onboardingComplete: true` in `handleReferralComplete()`
+- Implemented atomic updates for related state changes with the new `batchUpdateProfile` function
+- Added error handling with rollback capabilities for failed API operations
+- Replaced individual property updates with batch updates for related changes
+
+### 3. Reduce API Calls
+- Batch onboarding step updates where possible instead of making separate calls for each step
+- Implement a debounce mechanism for frequent state changes
+- Consider using GraphQL to fetch exactly what's needed in fewer requests
+- Add proper caching strategies for user data
+
+### 4. Improve Error Handling
+- Add retry logic for failed API calls with exponential backoff
+- Implement offline support with synchronization when connection is restored
+- Provide clear recovery paths for users when operations fail
+- Add more comprehensive error logging and monitoring
+
+### 5. Streamline State Management
+- Consolidate state management to reduce the mix of local and global state
+- Implement proper state selectors to minimize rerenders (already partly done with the selector pattern)
+- Consider using React Context + useReducer for more predictable state transitions
+- Create a clear separation between UI state and data state
+
+### 6. Auth Flow Improvements
+- Implement a more robust auth state detection system than localStorage flags
+- Add auth session persistence options to improve the returning user experience
+- Consider a more streamlined onboarding flow with fewer steps and conditional form fields
+- Add progress saving with the ability to resume onboarding from where users left off
+
+These improvements would lead to a more reliable, responsive, and maintainable application while reducing the potential for data inconsistency issues.
+
+
+
diff --git a/README_Docs/tasks/user-dennis/3-BE-DebugConsole.txt b/README_Docs/tasks/user-dennis/3-BE-DebugConsole.txt
new file mode 100644
index 0000000000000000000000000000000000000000..0e433616ee026508c5ea3cf7bd53b44fc5a773a0
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/3-BE-DebugConsole.txt
@@ -0,0 +1,539 @@
+macbookair@M2-MacbookAir my-mcat % npm run dev
+
+> ai-saas@0.1.0 dev
+> next dev
+
+  â–² Next.js 14.2.13
+  - Local:        http://localhost:3000
+  - Environments: .env
+  - Experiments (use with caution):
+    Â· turbo
+
+ âœ“ Starting...
+   automatically enabled Fast Refresh for 1 custom loader
+ âœ“ Ready in 1845ms
+ â—‹ Compiling /_not-found ...
+Browserslist: caniuse-lite is outdated. Please run:
+  npx update-browserslist-db@latest
+  Why you should do it regularly: https://github.com/browserslist/update-db#readme
+ âœ“ Compiled /_not-found in 6.2s (976 modules)
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /home
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /home
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params { pathname: '/home', searchParams: 'debug=true' }
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /home?debug=true 404 in 6413ms
+ â—‹ Compiling /favicon.ico ...
+ âœ“ Compiled /favicon.ico in 643ms (772 modules)
+ GET /favicon.ico 200 in 907ms
+ â—‹ Compiling /api/user-info ...
+ âœ“ Compiled /api/user-info in 595ms (698 modules)
+ âœ“ Compiled (702 modules)
+ GET /api/user-info/profile 200 in 1883ms
+ GET /api/user-info/profile 200 in 229ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 2502ms
+ âœ“ Compiled /api/study-plan in 135ms (704 modules)
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 373ms
+ GET /api/study-plan 200 in 373ms
+ GET /api/study-plan 200 in 106ms
+ â—‹ Compiling /home ...
+ âœ“ Compiled /home in 5.9s (6349 modules)
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /home
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /home
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params { pathname: '/home', searchParams: 'debug=true' }
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /home?debug=true 200 in 8279ms
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params {
+  pathname: '/_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map',
+  searchParams: ''
+}
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map 404 in 371ms
+ â—‹ Compiling /api/notifications ...
+ âœ“ Compiled /api/notifications in 1699ms (3365 modules)
+ GET /api/notifications 200 in 3169ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 3347ms
+ GET /api/notifications 200 in 200ms
+ GET /api/notifications 200 in 99ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+ GET /api/notifications 200 in 97ms
+ GET /api/user-info/profile 200 in 3646ms
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 370ms
+ GET /api/user-info/profile 200 in 217ms
+ GET /api/study-plan 200 in 226ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+ GET /api/user-info/profile 200 in 199ms
+ GET /api/study-plan 200 in 100ms
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 398ms
+ GET /api/user-info/profile 200 in 223ms
+ GET /api/study-plan 200 in 107ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+ GET /api/user-info/profile 200 in 191ms
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 381ms
+ GET /api/user-info/profile 200 in 191ms
+ GET /api/study-plan 200 in 220ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 436ms
+ â—‹ Compiling /api/user-activity ...
+ âœ“ Compiled /api/user-activity in 798ms (3367 modules)
+ âœ“ Compiled (3374 modules)
+ GET /api/calendar-activity 200 in 2195ms
+ GET /api/calendar/exam-activities 200 in 2381ms
+ GET /api/subscription 200 in 2358ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+ GET /api/study-plan 200 in 143ms
+objc[10892]: Class GNotificationCenterDelegate is implemented in both /opt/homebrew/Cellar/glib/2.82.4/lib/libgio-2.0.0.dylib (0x140300648) and /Users/macbookair/Desktop/my-mcat/node_modules/@img/sharp-libvips-darwin-arm64/lib/libvips-cpp.42.dylib (0xd17c09a28). One of the two will be used. Which one is undefined.
+ âš  The "images.domains" configuration is deprecated. Please use "images.remotePatterns" configuration instead.
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 542ms
+ GET /api/user-info/profile 200 in 2414ms
+cleaning up last activity
+cleaning up last activity
+cleaning up last activity
+ GET /api/calendar-activity 200 in 257ms
+ GET /api/calendar/exam-activities 200 in 470ms
+ GET /api/study-plan 200 in 209ms
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 625ms
+ GET /api/user-info/profile 200 in 223ms
+cleaning up last activity
+ GET /api/calendar-activity 200 in 275ms
+ POST /api/user-activity 200 in 3490ms
+cleaning up last activity
+[DEBUG][API] User info from database, keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord'
+]
+ GET /api/study-plan 200 in 200ms
+[DEBUG][API] Response object keys: [
+  'id',               'userId',
+  'devUserId',        'bio',
+  'updatedAt',        'apiCount',
+  'createdAt',        'score',
+  'clinicRooms',      'hasPaid',
+  'subscriptionType', 'diagnosticScores',
+  'firstName',        'profilePhoto',
+  'streak',           'notificationPreference',
+  'unlocks',          'onboardingInfo',
+  'patientRecord',    'email'
+]
+ GET /api/user-info 200 in 391ms
+cleaning up last activity
+ POST /api/user-activity 200 in 2157ms
+ â—‹ Compiling /api/user-activity/[activityId] ...
+ POST /api/user-activity 200 in 1332ms
+ âœ“ Compiled /api/user-activity/[activityId] in 762ms (3376 modules)
+ POST /api/user-activity 200 in 4857ms
+ POST /api/user-activity 200 in 1634ms
+ POST /api/user-activity 200 in 2539ms
+ GET /api/study-plan 200 in 1328ms
+ PATCH /api/user-activity/cm8nwawcy0000dgek748d0iyh 200 in 3100ms
+ GET /api/notifications 200 in 326ms
+ GET /api/notifications 200 in 111ms
+ GET /api/notifications 200 in 206ms
+ GET /api/notifications 200 in 103ms
+ GET /api/notifications 200 in 218ms
+ GET /api/notifications 200 in 103ms
+ GET /api/notifications 200 in 202ms
+ GET /api/notifications 200 in 103ms
+ GET /api/notifications 200 in 211ms
+ GET /api/notifications 200 in 105ms
+ GET /api/notifications 200 in 216ms
+ GET /api/notifications 200 in 103ms
+ âœ“ Compiled in 3.5s (6247 modules)
+ GET /home?debug=true&_rsc=1yv1g 200 in 272ms
+ â—‹ Compiling /api/user-activity/[activityId] ...
+ âœ“ Compiled /api/user-activity/[activityId] in 1085ms (6238 modules)
+ âœ“ Compiled in 0ms (3252 modules)
+ âœ“ Compiled in 2s (6238 modules)
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params {
+  pathname: '/_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map',
+  searchParams: ''
+}
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map 404 in 4075ms
+ PATCH /api/user-activity/cm8nwaxuv0005dgek9e79nnew 200 in 5244ms
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /home
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /home
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params { pathname: '/home', searchParams: 'debug=true' }
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /home?debug=true 200 in 4114ms
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params {
+  pathname: '/_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map',
+  searchParams: ''
+}
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map 404 in 143ms
+ â—‹ Compiling /favicon.ico ...
+ âœ“ Compiled /api/user-info/profile in 1372ms (3280 modules)
+ âœ“ Compiled (3365 modules)
+ GET /favicon.ico 200 in 3322ms
+ GET /home?debug=true&_rsc=1yv1g 200 in 70ms
+ GET /api/notifications 200 in 2833ms
+ GET /api/user-info/profile 200 in 2857ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+[RouteTracker DEBUG] === STATE DUMP ===
+[RouteTracker DEBUG] Path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] isSignedIn: undefined
+[RouteTracker DEBUG] isLoaded: true
+[RouteTracker DEBUG] profileLoading: true
+[RouteTracker DEBUG] Zustand onboardingComplete: false
+[RouteTracker DEBUG] userInfo exists: false
+[RouteTracker DEBUG] ====================
+[RouteTracker DEBUG] Checking exemption for path: /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map
+[RouteTracker DEBUG] User is signed in: undefined
+[RouteTracker DEBUG] Path exempt (standard): false
+[RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ðŸ‘‹ DebugPanel: Component initialized
+ðŸ‘‹ DebugPanel: Current path and search params {
+  pathname: '/_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map',
+  searchParams: ''
+}
+ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ GET /_next/static/css/app/(dashboard)/(routes)/home/react-big-calendar.css.map 404 in 313ms
+ GET /api/notifications 200 in 174ms
+ GET /api/user-info/profile 200 in 212ms
+ GET /api/user-info 200 in 3452ms
+ GET /api/notifications 200 in 104ms
+ GET /api/notifications 200 in 159ms
+ GET /api/user-info/profile 200 in 262ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ âœ“ Compiled /api/study-plan in 480ms (3367 modules)
+ GET /api/user-info 200 in 690ms
+ GET /api/study-plan 200 in 1096ms
+ GET /api/user-info/profile 200 in 1014ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ GET /api/user-info 200 in 512ms
+ GET /api/study-plan 200 in 228ms
+ GET /api/user-info/profile 200 in 229ms
+ GET /api/study-plan 200 in 123ms
+ GET /api/user-info/profile 200 in 201ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ GET /api/user-info 200 in 591ms
+ GET /api/study-plan 200 in 246ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ GET /api/user-info 200 in 491ms
+ â—‹ Compiling /api/calendar-activity ...
+ âœ“ Compiled /api/user-activity in 798ms (3369 modules)
+ âœ“ Compiled (3376 modules)
+ GET /api/calendar-activity 200 in 1356ms
+cleaning up last activity
+ GET /api/user-info/profile 200 in 1625ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ GET /api/calendar/exam-activities 200 in 1643ms
+cleaning up last activity
+ GET /api/subscription 200 in 1666ms
+ GET /api/user-info 200 in 385ms
+ GET /api/study-plan 200 in 152ms
+ GET /api/calendar-activity 200 in 157ms
+cleaning up last activity
+ GET /api/user-info/profile 200 in 218ms
+ POST /api/user-activity 200 in 1622ms
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+cleaning up last activity
+ GET /api/calendar/exam-activities 200 in 415ms
+ GET /api/study-plan 200 in 127ms
+ GET /api/user-info 200 in 436ms
+ GET /api/calendar-activity 200 in 227ms
+cleaning up last activity
+[DEBUG][API] RAW DATABASE RESPONSE: ["id","userId","devUserId","bio","updatedAt","apiCount","createdAt","score","clinicRooms","hasPaid","subscriptionType","diagnosticScores","firstName","profilePhoto","streak","notificationPreference","unlocks","onboardingInfo","patientRecord"]
+ POST /api/user-activity 200 in 2169ms
+ GET /api/user-info 200 in 362ms
+ POST /api/user-activity 200 in 789ms
+ GET /api/study-plan 200 in 106ms
+ GET /api/study-plan 200 in 109ms
+ POST /api/user-activity 200 in 1423ms
+ POST /api/user-activity 200 in 890ms
+ PATCH /api/user-activity/cm8nwf4t80006dgek2qc3i3nw 200 in 863ms
+ GET /api/notifications 200 in 217ms
+ GET /api/notifications 200 in 112ms
+ GET /api/notifications 200 in 206ms
+ GET /api/notifications 200 in 100ms
diff --git a/README_Docs/tasks/user-dennis/3-FE-DebugConsole.txt b/README_Docs/tasks/user-dennis/3-FE-DebugConsole.txt
new file mode 100644
index 0000000000000000000000000000000000000000..20370d39baf3a533a6351aeb83efb58e1021b38c
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/3-FE-DebugConsole.txt
@@ -0,0 +1,558 @@
+initializationContentScript.js:1 Chrome storage API available, initializing emoji style sync
+content.js:1 [Deprecation] Listener added for a 'DOMNodeInserted' mutation event. Support for this event type has been removed, and this event will no longer be fired. See https://chromestatus.com/feature/5083947249172480 for more information.
+(anonymous) @ content.js:1
+j @ jquery.js:2
+fireWith @ jquery.js:2
+ready @ jquery.js:2
+I @ jquery.js:2
+contentScript.js:2 Chrome storage API available, initializing emoji style sync
+ [RouteTracker DEBUG] === STATE DUMP ===
+ [RouteTracker DEBUG] Path: /home
+ [RouteTracker DEBUG] isSignedIn: undefined
+ [RouteTracker DEBUG] isLoaded: true
+ [RouteTracker DEBUG] profileLoading: true
+ [RouteTracker DEBUG] Zustand onboardingComplete: false
+ [RouteTracker DEBUG] userInfo exists: false
+ [RouteTracker DEBUG] ====================
+ [RouteTracker DEBUG] Checking exemption for path: /home
+ [RouteTracker DEBUG] User is signed in: undefined
+ [RouteTracker DEBUG] Path exempt (standard): false
+ [RouteTracker DEBUG] Calculated effectiveOnboardingComplete: false targetScore: undefined
+ ðŸ‘‹ DebugPanel: Component initialized
+ ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+ ðŸ‘‹ DebugPanel: Not rendering panel (isDebug is false)
+ [DEBUG][StoreInitializer] Starting initialization...
+ [DEBUG][StoreInitializer] Checking raw Zustand state:
+ [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+ [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+ [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+ [RouteTracker DEBUG] isExemptPath changed to: false
+ [RouteTracker DEBUG] Current path: /home
+ [RouteTracker DEBUG] isSignedIn state: undefined
+ [RouteTracker DEBUG] Effect 1 - isSignedIn: undefined has userInfo: false
+ [RouteTracker DEBUG] Effect 1 - onboardingComplete: false
+ [RouteTracker DEBUG] Effect 2 - path: /home
+ [RouteTracker DEBUG] Effect 2 - isSignedIn: undefined onboarding complete: false
+ [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: false
+ [DEBUG][StoreInitializer] Starting initialization...
+ [DEBUG][StoreInitializer] Checking raw Zustand state:
+ [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+ [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+ [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+ [MusicPlayer] Initializing audio context
+ [MusicPlayer] Theme changed or component mounted, theme: cyberSpace
+ [MusicPlayer] Queue status: {initialized: false, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
+ [MusicPlayer] Updating song queue for theme: cyberSpace
+ [AudioSlice] Theme changed to cyberSpace wasPlaying: false
+ ðŸŽ« Subscription Status: FREE
+ ðŸ‘‹ DebugPanel: URL debug parameter = true
+ ðŸ‘‹ DebugPanel: Direct URL check = true http://localhost:3000/home?debug=true
+ ðŸ‘‹ DebugPanel: Debug mode ENABLED
+ ðŸ‘‹ DebugPanel: isDebug state = false
+ [DEBUG][StoreInitializer] Starting initialization...
+ [DEBUG][StoreInitializer] Checking raw Zustand state:
+ [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+ [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+ [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+ [RouteTracker DEBUG] isExemptPath changed to: false
+ [RouteTracker DEBUG] Current path: /home
+ [RouteTracker DEBUG] isSignedIn state: undefined
+ [RouteTracker DEBUG] Effect 1 - isSignedIn: undefined has userInfo: false
+ [RouteTracker DEBUG] Effect 1 - onboardingComplete: false
+ [RouteTracker DEBUG] Effect 2 - path: /home
+ [RouteTracker DEBUG] Effect 2 - isSignedIn: undefined onboarding complete: false
+ [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: false
+ [DEBUG][StoreInitializer] Starting initialization...
+ [DEBUG][StoreInitializer] Checking raw Zustand state:
+ [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+ [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+ [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+ [MusicPlayer] Initializing audio context
+ [MusicPlayer] Theme changed or component mounted, theme: cyberSpace
+ [MusicPlayer] Queue status: {initialized: true, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
+ [MusicPlayer] Updating song queue for theme: cyberSpace
+ [AudioSlice] Theme changed to cyberSpace wasPlaying: false
+ ðŸŽ« Subscription Status: FREE
+ ðŸ‘‹ DebugPanel: URL debug parameter = true
+ ðŸ‘‹ DebugPanel: Direct URL check = true http://localhost:3000/home?debug=true
+DebugPanel.tsx:39 ðŸ‘‹ DebugPanel: Debug mode ENABLED
+DebugPanel.tsx:52 ðŸ‘‹ DebugPanel: isDebug state = false
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: undefined
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: true
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: false
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: false
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for userState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingComplete', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+musicplayer.tsx:104 [MusicPlayer] Initializing audio context
+musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: mykonosBlue
+musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: false, shouldUpdateQueue: true}
+musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: mykonosBlue
+audioSlice.ts:200 [AudioSlice] Theme changed to mykonosBlue wasPlaying: false
+DebugPanel.tsx:52 ðŸ‘‹ DebugPanel: isDebug state = true
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: undefined
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: true
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: false
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: false
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for userState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingComplete', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: mykonosBlue
+musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: false}
+index.ts:122 COMBINED STATE KEYS: (116)Â ['masterVolume', 'isPlaying', 'currentMusic', 'currentLoop', 'audioContext', 'musicSource', 'loopSource', 'voiceSource', 'bufferCache', 'volume', 'currentSong', 'songQueue', 'currentSongIndex', 'masterGainNode', 'musicGainNode', 'sfxGainNode', 'loopGainNode', 'voiceGainNode', '_SOUND_MAPPINGS', '_isLoopLoading', '_pendingLoopName', '_isMusicLoading', '_pendingMusicTrack', '_lastPlayedSounds', '_soundDebounceTime', 'setSongQueue', 'getCurrentSongTitle', 'handleThemeChange', 'togglePlayPause', 'initializeAudioContext', 'setMasterVolume', 'setVolume', 'skipToNext', 'loadAudioBuffer', 'playMusic', 'stopMusic', 'playSound', 'playLoop', 'stopLoop', 'playVoice', 'stopVoice', 'window', 'currentRoute', 'theme', 'setWindowSize', 'setCurrentRoute', 'setTheme', 'patientsPerDay', 'streakDays', 'totalPatients', 'userLevel', 'userRooms', 'activeRooms', 'completeAllRoom', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'correctCount', 'testScore', 'userResponses', 'wrongCount', 'reportData', 'isClinicDataLoading', 'endGame', 'resetGameState', 'setActiveRooms', 'setCompleteAllRoom', 'setCorrectCount', 'setFlashcardRoomId', 'setIsFlashcardsOpen', 'setUserResponses', 'setTestScore', 'setTotalPatients', 'setWrongCount', 'setStreakDays', 'setUserRooms', 'startGame', 'unlockRoom', 'updateUserLevel', 'fetchClinicData', 'resetClinicData', 'performDailyCalculations', 'version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep',Â â€¦]
+index.ts:122 COMBINED STATE KEYS: (116)Â ['masterVolume', 'isPlaying', 'currentMusic', 'currentLoop', 'audioContext', 'musicSource', 'loopSource', 'voiceSource', 'bufferCache', 'volume', 'currentSong', 'songQueue', 'currentSongIndex', 'masterGainNode', 'musicGainNode', 'sfxGainNode', 'loopGainNode', 'voiceGainNode', '_SOUND_MAPPINGS', '_isLoopLoading', '_pendingLoopName', '_isMusicLoading', '_pendingMusicTrack', '_lastPlayedSounds', '_soundDebounceTime', 'setSongQueue', 'getCurrentSongTitle', 'handleThemeChange', 'togglePlayPause', 'initializeAudioContext', 'setMasterVolume', 'setVolume', 'skipToNext', 'loadAudioBuffer', 'playMusic', 'stopMusic', 'playSound', 'playLoop', 'stopLoop', 'playVoice', 'stopVoice', 'window', 'currentRoute', 'theme', 'setWindowSize', 'setCurrentRoute', 'setTheme', 'patientsPerDay', 'streakDays', 'totalPatients', 'userLevel', 'userRooms', 'activeRooms', 'completeAllRoom', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'correctCount', 'testScore', 'userResponses', 'wrongCount', 'reportData', 'isClinicDataLoading', 'endGame', 'resetGameState', 'setActiveRooms', 'setCompleteAllRoom', 'setCorrectCount', 'setFlashcardRoomId', 'setIsFlashcardsOpen', 'setUserResponses', 'setTestScore', 'setTotalPatients', 'setWrongCount', 'setStreakDays', 'setUserRooms', 'startGame', 'unlockRoom', 'updateUserLevel', 'fetchClinicData', 'resetClinicData', 'performDailyCalculations', 'version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep',Â â€¦]
+musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
+index.ts:122 COMBINED STATE KEYS: (116)Â ['masterVolume', 'isPlaying', 'currentMusic', 'currentLoop', 'audioContext', 'musicSource', 'loopSource', 'voiceSource', 'bufferCache', 'volume', 'currentSong', 'songQueue', 'currentSongIndex', 'masterGainNode', 'musicGainNode', 'sfxGainNode', 'loopGainNode', 'voiceGainNode', '_SOUND_MAPPINGS', '_isLoopLoading', '_pendingLoopName', '_isMusicLoading', '_pendingMusicTrack', '_lastPlayedSounds', '_soundDebounceTime', 'setSongQueue', 'getCurrentSongTitle', 'handleThemeChange', 'togglePlayPause', 'initializeAudioContext', 'setMasterVolume', 'setVolume', 'skipToNext', 'loadAudioBuffer', 'playMusic', 'stopMusic', 'playSound', 'playLoop', 'stopLoop', 'playVoice', 'stopVoice', 'window', 'currentRoute', 'theme', 'setWindowSize', 'setCurrentRoute', 'setTheme', 'patientsPerDay', 'streakDays', 'totalPatients', 'userLevel', 'userRooms', 'activeRooms', 'completeAllRoom', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'correctCount', 'testScore', 'userResponses', 'wrongCount', 'reportData', 'isClinicDataLoading', 'endGame', 'resetGameState', 'setActiveRooms', 'setCompleteAllRoom', 'setCorrectCount', 'setFlashcardRoomId', 'setIsFlashcardsOpen', 'setUserResponses', 'setTestScore', 'setTotalPatients', 'setWrongCount', 'setStreakDays', 'setUserRooms', 'startGame', 'unlockRoom', 'updateUserLevel', 'fetchClinicData', 'resetClinicData', 'performDailyCalculations', 'version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep',Â â€¦]
+index.ts:122 COMBINED STATE KEYS: (116)Â ['masterVolume', 'isPlaying', 'currentMusic', 'currentLoop', 'audioContext', 'musicSource', 'loopSource', 'voiceSource', 'bufferCache', 'volume', 'currentSong', 'songQueue', 'currentSongIndex', 'masterGainNode', 'musicGainNode', 'sfxGainNode', 'loopGainNode', 'voiceGainNode', '_SOUND_MAPPINGS', '_isLoopLoading', '_pendingLoopName', '_isMusicLoading', '_pendingMusicTrack', '_lastPlayedSounds', '_soundDebounceTime', 'setSongQueue', 'getCurrentSongTitle', 'handleThemeChange', 'togglePlayPause', 'initializeAudioContext', 'setMasterVolume', 'setVolume', 'skipToNext', 'loadAudioBuffer', 'playMusic', 'stopMusic', 'playSound', 'playLoop', 'stopLoop', 'playVoice', 'stopVoice', 'window', 'currentRoute', 'theme', 'setWindowSize', 'setCurrentRoute', 'setTheme', 'patientsPerDay', 'streakDays', 'totalPatients', 'userLevel', 'userRooms', 'activeRooms', 'completeAllRoom', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'correctCount', 'testScore', 'userResponses', 'wrongCount', 'reportData', 'isClinicDataLoading', 'endGame', 'resetGameState', 'setActiveRooms', 'setCompleteAllRoom', 'setCorrectCount', 'setFlashcardRoomId', 'setIsFlashcardsOpen', 'setUserResponses', 'setTestScore', 'setTotalPatients', 'setWrongCount', 'setStreakDays', 'setUserRooms', 'startGame', 'unlockRoom', 'updateUserLevel', 'fetchClinicData', 'resetClinicData', 'performDailyCalculations', 'version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep',Â â€¦]
+musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
+musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
+StoreInitializer.tsx:83 [DEBUG][StoreInitializer] After initialization:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+StoreInitializer.tsx:83 [DEBUG][StoreInitializer] After initialization:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+StoreInitializer.tsx:83 [DEBUG][StoreInitializer] After initialization:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+StoreInitializer.tsx:83 [DEBUG][StoreInitializer] After initialization:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+script.debug.js:1 [Vercel Web Analytics] Debug mode is enabled by default in development. No requests will be sent to the server.
+script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/home?debug=true {o: 'http://localhost:3000/home?debug=true', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742871036249,Â â€¦}
+audioSlice.ts:226 [AudioSlice] Not playing music after theme change
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: true
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: false
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: false
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+RouteTracker.tsx:59 [RouteTracker DEBUG] Checking exemption for path: /home
+RouteTracker.tsx:60 [RouteTracker DEBUG] User is signed in: true
+RouteTracker.tsx:71 [RouteTracker DEBUG] Path exempt (standard): false
+audioSlice.ts:226 [AudioSlice] Not playing music after theme change
+StoreInitializer.tsx:96 [DEBUG][StoreInitializer] User signed in, refreshing user info...
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+
+                
+          
+          
+          
+         Chrome is moving towards a new experience that allows users to choose to browse without third-party cookies.
+RouteTracker.tsx:174 [RouteTracker DEBUG] isExemptPath changed to: false
+RouteTracker.tsx:175 [RouteTracker DEBUG] Current path: /home
+RouteTracker.tsx:176 [RouteTracker DEBUG] isSignedIn state: true
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: false
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: false
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: false
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: false
+RouteTracker.tsx:367 [AUTH DEBUG] Auth state changed but NOT from login button - no redirect
+StoreInitializer.tsx:96 [DEBUG][StoreInitializer] User signed in, refreshing user info...
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:68 [DEBUG][StoreInitializer] No userInfo or onboardingInfo yet
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+audioSlice.ts:226 [AudioSlice] Not playing music after theme change
+StoreInitializer.tsx:117 [DEBUG][StoreInitializer] Running secondary refresh...
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:117 [DEBUG][StoreInitializer] Running secondary refresh...
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: true
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: false
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: false
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for userState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingComplete', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (14)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version', 'coins', 'isSubscribed', 'profile', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'isProfileComplete']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+RouteTracker.tsx:79 [RouteTracker DEBUG] effectiveOnboardingComplete: true (direct onboardingComplete flag)
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
+StoreInitializer.tsx:101 [DEBUG][StoreInitializer] After initial refresh:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:65 [DEBUG][StoreInitializer] Nested onboardingComplete: true
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+StoreInitializer.tsx:101 [DEBUG][StoreInitializer] After initial refresh:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:65 [DEBUG][StoreInitializer] Nested onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+userSlice.ts:334 [DEBUG][UserStore] Starting refreshUserInfo
+userSlice.ts:335 [DEBUG][UserStore] Current state keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: true
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+StoreInitializer.tsx:119 [DEBUG][StoreInitializer] After secondary refresh:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:65 [DEBUG][StoreInitializer] Nested onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+StoreInitializer.tsx:119 [DEBUG][StoreInitializer] After secondary refresh:
+StoreInitializer.tsx:28 [DEBUG][StoreInitializer] Checking raw Zustand state:
+StoreInitializer.tsx:29 [DEBUG][StoreInitializer] Keys: (26)Â ['version', 'profile', 'profileLoading', 'isProfileComplete', 'completedSteps', 'studyPreferences', 'interfaceSettings', 'tutorialProgress', 'lastVisitedRoute', 'userInfo', 'isSubscribed', 'coins', 'statsLoading', 'error', 'updateProfile', 'setCompletedSteps', 'addCompletedStep', 'updateStudyPreferences', 'updateInterfaceSettings', 'updateTutorialProgress', 'setOnboardingComplete', 'setLastVisitedRoute', 'refreshUserInfo', 'setIsSubscribed', 'updateCoins', 'updateCoinsDisplay']
+StoreInitializer.tsx:60 [DEBUG][StoreInitializer] âœ… No root-level onboardingComplete
+StoreInitializer.tsx:65 [DEBUG][StoreInitializer] Nested onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
+userSlice.ts:372 [DEBUG][UserStore] Raw API response from /api/user-info: {id: 'cm8notvdl000pdg8ot2z1qfoz', userId: 'user_2umbBNpR47nyyHjhbMFvNBd8csC', devUserId: null, bio: 'Excited to ace the MCAT!', updatedAt: '2025-03-24T23:18:38.048Z',Â â€¦}
+userSlice.ts:373 [DEBUG][UserStore] API response keys: (20)Â ['id', 'userId', 'devUserId', 'bio', 'updatedAt', 'apiCount', 'createdAt', 'score', 'clinicRooms', 'hasPaid', 'subscriptionType', 'diagnosticScores', 'firstName', 'profilePhoto', 'streak', 'notificationPreference', 'unlocks', 'onboardingInfo', 'patientRecord', 'email']
+userSlice.ts:393 [DEBUG][UserStore] Updating with these keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:418 [DEBUG][UserStore] Profile API response keys: (6)Â ['userId', 'firstName', 'bio', 'coins', 'profilePhoto', 'patientsCount']
+userSlice.ts:446 [DEBUG][UserStore] Final updates object keys: (5)Â ['userInfo', 'statsLoading', 'profileLoading', 'error', 'version']
+userSlice.ts:470 [DEBUG][UserStore] âœ… No root onboardingComplete after update
+RouteTracker.tsx:37 [RouteTracker DEBUG] === STATE DUMP ===
+RouteTracker.tsx:38 [RouteTracker DEBUG] Path: /home
+RouteTracker.tsx:39 [RouteTracker DEBUG] isSignedIn: true
+RouteTracker.tsx:40 [RouteTracker DEBUG] isLoaded: true
+RouteTracker.tsx:41 [RouteTracker DEBUG] profileLoading: false
+RouteTracker.tsx:42 [RouteTracker DEBUG] Zustand onboardingComplete: true
+RouteTracker.tsx:43 [RouteTracker DEBUG] userInfo exists: true
+RouteTracker.tsx:45 [RouteTracker DEBUG] userInfo.onboardingInfo: {gpa: 3.4, college: 'Non-Traditional', firstName: 'Dennis[FACEBOOK] ', isCanadian: false, currentStep: 4,Â â€¦}
+RouteTracker.tsx:47 [RouteTracker DEBUG] ====================
+DebugPanel.tsx:12 ðŸ‘‹ DebugPanel: Component initialized
+DebugPanel.tsx:19 ðŸ‘‹ DebugPanel: Current path and search params {pathname: '/home', searchParams: 'debug=true'}
+DebugPanel.tsx:233 ðŸ‘‹ DebugPanel: RENDERING PANEL!
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['currentRoute', 'theme', 'window']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for unknown state
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['coins', 'completedSteps', 'interfaceSettings', 'isProfileComplete', 'isSubscribed', 'lastVisitedRoute', 'onboardingInfo', 'profile', 'profileLoading', 'statsLoading', 'studyPreferences', 'tutorialProgress', 'userInfo']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for audioState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (13)Â ['audioContext', 'currentLoop', 'currentMusic', 'currentSong', 'currentSongIndex', 'currentSongTitle', 'gainNodes', 'isPlaying', 'masterVolume', 'queueLength', 'songQueue', 'sources', 'volume']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for gameState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (15)Â ['activeRooms', 'completeAllRoom', 'correctCount', 'currentUserTestId', 'flashcardRoomId', 'isFlashcardsOpen', 'isGameInProgress', 'patientsPerDay', 'streakDays', 'testScore', 'totalPatients', 'userLevel', 'userResponses', 'userRooms', 'wrongCount']
+DebugPanel.tsx:91 ðŸ‘‹ DebugPanel: stringifySorted called for vocabState
+DebugPanel.tsx:175 ðŸ‘‹ DebugPanel: Prepared object keys: (3)Â ['isCmdIEnabled', 'showVocabList', 'vocabList']
+RouteTracker.tsx:221 [RouteTracker DEBUG] Effect 1 - isSignedIn: true has userInfo: true
+RouteTracker.tsx:222 [RouteTracker DEBUG] Effect 1 - onboardingComplete: true
+RouteTracker.tsx:244 [RouteTracker DEBUG] Effect 2 - path: /home
+RouteTracker.tsx:245 [RouteTracker DEBUG] Effect 2 - isSignedIn: true onboarding complete: true
+RouteTracker.tsx:246 [RouteTracker DEBUG] Effect 2 - Zustand onboardingComplete: true
diff --git a/README_Docs/tasks/user-dennis/3-TestData-PrismaInstructions.md b/README_Docs/tasks/user-dennis/3-TestData-PrismaInstructions.md
new file mode 100644
index 0000000000000000000000000000000000000000..83b2917a2a01f4cdb7fc229d66d26a85f2ef404a
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/3-TestData-PrismaInstructions.md
@@ -0,0 +1,20 @@
+## UserInfo
+
+**userId**: user_2rFXhmeHNzY3irm9HShrGMGMY3M
+
+
+---- Completed Onboarding (routes to /home) ----
+*paste this into prisma*
+
+**onboardingInfo**: 
+```json
+{"gpa":3.8,"college":"University of California-Los Angeles","isCanadian":false,"currentStep":7,"targetScore":526,"hasNotTakenMCAT":false,"targetMedSchool":"UCLA","currentMcatScore":515,"isNonTraditional":false,"mcatAttemptNumber":"1","onboardingComplete":true}
+```
+
+---- User Without Completed Onboarding (routes to /onboarding) ----
+*paste this into prisma*
+
+**onboardingInfo**: 
+```json
+{"gpa":3.8,"college":"University of California-Los Angeles","isCanadian":false,"currentStep":4,"targetScore":null,"hasNotTakenMCAT":false,"targetMedSchool":"UCLA","currentMcatScore":515,"isNonTraditional":false,"mcatAttemptNumber":"1","onboardingComplete":false}
+```
\ No newline at end of file
diff --git a/README_Docs/tasks/user-dennis/3-pr-diff.txt b/README_Docs/tasks/user-dennis/3-pr-diff.txt
deleted file mode 100644
index 76a30fd1cafb7736cfb8f250a1c258eca070aa96..0000000000000000000000000000000000000000
--- a/README_Docs/tasks/user-dennis/3-pr-diff.txt
+++ /dev/null
@@ -1,3774 +0,0 @@
-diff --git a/.cursor/rules/state-management.mdc b/.cursor/rules/state-management.mdc
-new file mode 100644
-index 0000000000000000000000000000000000000000..a2e6b96e76aff28ef1c07725b2b5d6653ae4e990
---- /dev/null
-+++ b/.cursor/rules/state-management.mdc
-@@ -0,0 +1,47 @@
-+---
-+description: 
-+globs: 
-+alwaysApply: true
-+---
-+---
-+name: State Management Patterns
-+description: Guidelines for accessing store state and actions in components
-+globs: ["**/*.tsx", "**/*.ts"]
-+alwaysApply: true
-+---
-+
-+### State Management Patterns
-+
-+#### Store Access
-+Always use the consolidated selector pattern from `@/store/selectors.ts` instead of directly importing from slice files.
-+
-+âœ… Correct: Use consolidated selectors
-+```typescript
-+import { useUI, useUser, useAudio } from '@/store/selectors';
-+
-+const MyComponent = () => {
-+  const { theme } = useUI();
-+  const { isSubscribed } = useUser();
-+  const { playSound, stopLoop } = useAudio();
-+  
-+  // Component implementation
-+};
-+```
-+
-+âŒ Incorrect: Direct imports from slice files
-+```typescript
-+import { useUIStore } from '@/store/slices/uiSlice';
-+import { useUserStore } from '@/store/slices/userSlice';
-+import { useAudioStore } from '@/store/slices/audioSlice';
-+
-+const MyComponent = () => {
-+  const theme = useUIStore(state => state.theme);
-+  const isSubscribed = useUserStore(state => state.isSubscribed);
-+  const playSound = useAudioStore(state => state.playSound);
-+  
-+  // Component implementation
-+};
-+```
-+
-+#### Exception: Store Initialization Components
-+The only exception to this pattern is in components specifically designed for store initialization (e.g., `StoreInitializer.tsx`), where direct access to store actions may be required.
-diff --git a/.cursorrules b/.cursorrules
-deleted file mode 100644
-index e5ce9fd85fcb3a53d58eebbc398b787b63b6c829..0000000000000000000000000000000000000000
---- a/.cursorrules
-+++ /dev/null
-@@ -1,207 +0,0 @@
--# =====================
--# CURSOR AI GUIDELINES
--# =====================
--
--# Load developer configuration
--LOAD_CONFIG: |
--  const devConfig = require('./README_Docs/config/developer.json');
--  const DEVELOPER_NAME = devConfig.DEVELOPER_NAME;
--  const technical = require('./README_Docs/architecture/technical.md');
--  const architecture = require('./README_Docs/architecture/architecture.md');
--
--SYSTEM_CONTEXT: |
--  You are a senior developer working on the MYMCAT TypeScript/Next.js project.
--  
--  # Documentation Hierarchy
--  1. Primary Documentation:
--     - technical.md: Source of truth for coding standards
--     - architecture.md: System design and patterns
--     - tasks/${DEVELOPER_NAME}/tasks.md: Current tasks
--     - tasks/${DEVELOPER_NAME}/status.md: Progress tracking
--
--  2. Implementation Requirements:
--     - Follow section headers from technical.md
--     - Use animation patterns from technical.md
--     - Implement feature gates per architecture.md
--     - Follow component organization rules
--
--  3. Before ANY Code Changes:
--     - PARSE technical.md for relevant patterns
--     - VERIFY against architecture.md
--     - CHECK current task context
--     - VALIDATE component structure
--
--# Enforce Technical Standards
--ENFORCE_TECHNICAL: |
--  On every query:
--  1. Load technical.md section standards
--  2. Apply animation patterns
--  3. Follow component organization
--  4. Use proper section headers
--  5. Implement proper loading states
--  6. Follow markdown code block standards
--
--# Enforce Architectural Patterns
--ENFORCE_ARCHITECTURE: |
--  On every component:
--  1. Verify premium feature gates
--  2. Check component dependencies
--  3. Follow data flow patterns
--  4. Implement proper auth checks
--
--# Error Prevention
--VALIDATION_RULES: |
--  Before responding to any query:
--  1. Load and parse technical.md completely
--  2. Check section dividers (100 dashes)
--  3. Validate heading hierarchy
--  4. Ensure code blocks follow documentation rules
--  5. Verify file paths in examples
--
--# File Management Rules
--ON_FILE_CHANGE: |
--  Required actions after code changes:
--  1. VERIFY premium feature gates implementation
--  2. CHECK README_Docs/architecture/architecture.md compliance
--  3. UPDATE personal status.md with:
--     - Current progress
--     - Any blockers
--     - Completed items
--  4. VALIDATE against technical.md specifications
--  5. VERIFY task progress
--  6. NEVER modify package-lock.json directly
--
--# Package Management Rules
--PACKAGE_GUIDELINES: |
--  - Never manually edit package-lock.json
--  - Use npm install for adding new packages
--  - Commit both package.json and package-lock.json together
--  - Report conflicts in package-lock.json to team lead
--  - Run npm ci for clean installs
--  - Contact Josh for dependency updates
--
--# Code Style Reference
--CODE_STYLE_RULES: |
--  All code style, formatting, and organization rules are defined in technical.md:
--  - Component Structure
--  - Section Headers (100 characters)
--  - Import Standards
--  - Route-Component Relationships
--  - Component Naming
--  - File Organization
--  - Animation Patterns
--  - Error Handling
--  
--  Always parse technical.md before implementing any component or feature.
--
--  Component Template Requirements:
--  1. Import Order:
--     - React/Next.js
--     - External libraries
--     - Internal utilities/types
--     - Internal components
--  
--  2. Section Headers:
--     - Must be 100 characters wide
--     - Must follow standard order
--     - Constants/Types outside component
--  
--  3. Component Structure:
--     - Default export
--     - CamelCase naming
--     - Props interface with Types section
--
--# Architecture Understanding
--READ_ARCHITECTURE: |
--  File: README_Docs/architecture/architecture.md
--  Required parsing:
--  1. Load and parse Mermaid diagram focusing on:
--     - Auth -> Onboarding flow
--     - Feature Gates system
--     - Free vs Premium features
--     - Game systems
--     - Data collection flow
--  2. Extract and understand:
--     - Premium vs Free feature boundaries
--     - Clerk Auth integration points
--     - Data flow patterns
--     - Component dependencies
--  3. Validate changes against architectural constraints
--  4. Ensure proper feature gating
--
--# Task Management
--TASK_WORKFLOW: |
--  Required files:
--  - README_Docs/tasks/user-${DEVELOPER_NAME}/tasks.md
--  - README_Docs/tasks/user-${DEVELOPER_NAME}/status.md
--  - README_Docs/architecture/technical.md
--  
--  Workflow steps:
--  1. READ personal tasks.md:
--     - Parse requirements
--     - Check premium feature implications
--     - Identify dependencies
--  
--  2. VALIDATE against architecture.md:
--     - Verify feature gate compliance
--     - Check component interactions
--     - Confirm Clerk Auth integration
--  
--  3. UPDATE personal status.md:
--     - Track progress
--     - Document blockers
--     - Note premium feature considerations
--
--# Feature Gate Implementation
--PREMIUM_FEATURES: |
--  # AI Behavior for Premium Features
--  1. Source of Truth:
--     - Load feature definitions from "Feature Control" section in technical.md
--     - Follow implementation patterns from "Feature Gates" section
--     - Reference component examples from technical.md
--  
--  2. Validation Requirements:
--     - Verify component against documented feature gate patterns
--     - Ensure proper hook usage (useSubscriptionStatus) as shown in examples
--     - Confirm implementation matches technical.md specifications
--     
--  3. Documentation Requirements:
--     - Reference "Free Features" and "Premium Features" sections in technical.md
--     - Link to relevant implementation examples
--     - Keep implementation aligned with documentation
--
--  4. Response Guidelines:
--     - Always cite specific sections from technical.md
--     - Point developers to relevant code examples
--     - Ensure responses align with documented patterns
--
--# Technical Documentation Parser
--PARSE_TECHNICAL_MD: |
--  1. Section Hierarchy:
--     - Parse h1 (#) for main document title
--     - Parse h2 (##) for major sections
--     - Parse h3 (###) for subsections
--     - Parse h4 (####) for detailed guidelines
--  
--  2. Special Sections:
--     - Always validate Feature Control section for premium gates
--     - Check Component Guidelines for structure requirements
--     - Verify Documentation Guidelines for formatting rules
--
--# Component Structure Enforcement
--ENFORCE_COMPONENT_STRUCTURE: |
--  For all .tsx files:
--  1. Verify file header comment
--  2. Check import order against technical.md standards
--  3. Validate section headers match technical.md template
--  4. Ensure premium feature gates are implemented
--  5. Check component naming conventions
--
--# Documentation Standards
--DOCUMENTATION_RULES: |
--  For all .md files:
--  1. Verify proper markdown link syntax
--  2. Check code block formatting
--  3. Validate section dividers
--  4. Ensure proper heading hierarchy
--  5. Check for complete examples in guidelines
-\ No newline at end of file
-diff --git a/.eslintrc.json b/.eslintrc.json
-index a6ce61be266dcce75550cf2e383a77edd5d289ab..346aa0c75f86a3d47901ea282152e7fc47c4538b 100644
---- a/.eslintrc.json
-+++ b/.eslintrc.json
-@@ -23,7 +23,8 @@
-       }
-     ],
-     "import/no-unused-modules": ["warn", {
--      "unusedExports": true
-+      "unusedExports": true,
-+      "ignoreExports": ["**/api/**/*"]
-     }],
-     "@typescript-eslint/adjacent-overload-signatures": "warn",
-     "@typescript-eslint/ban-ts-comment": "warn",
-@@ -37,7 +38,7 @@
-     "@typescript-eslint/no-misused-new": "warn",
-     "@typescript-eslint/no-namespace": "warn",
-     "@typescript-eslint/no-non-null-asserted-optional-chain": "warn",
--    "@typescript-eslint/no-non-null-assertion": "warn",
-+    "@typescript-eslint/no-non-null-assertion": "off",
-     "@typescript-eslint/no-this-alias": "warn",
-     "@typescript-eslint/no-var-requires": "warn",
-     "@typescript-eslint/prefer-as-const": "warn",
-diff --git a/README_Docs/tasks/user-dennis/1-tasks-all.md b/README_Docs/tasks/user-dennis/1-tasks-all.md
-new file mode 100644
-index 0000000000000000000000000000000000000000..af0e6d753f3e19e666328d95a059335c89d65863
---- /dev/null
-+++ b/README_Docs/tasks/user-dennis/1-tasks-all.md
-@@ -0,0 +1,128 @@
-+# Features:
-+[ ] Talking to kalypso - better UI - waveform shows - when talking to Kalypso AI 
-+[ ] 
-+
-+
-+
-+---
-+
-+# Tech Debt:
-+
-+## Update Cursor Rules
-+[ ] .mdc - cursor rules - update to always use zustand not context API - also consider rules when creating a new state in a component? should multiple components have access to it? consider global state. 
-+[ ] when creating new global state - make sure our DebugPanel renders it too.
-+
-+### Unmigrated Content from .cursorrules
-+Content from .cursorrules that hasn't been migrated to .mdc files yet:
-+
-+#### Documentation Hierarchy
-+```markdown
-+# Documentation Hierarchy
-+1. Primary Documentation:
-+   - technical.md: Source of truth for coding standards
-+   - architecture.md: System design and patterns
-+   - tasks/${DEVELOPER_NAME}/tasks.md: Current tasks
-+   - tasks/${DEVELOPER_NAME}/status.md: Progress tracking
-+
-+2. Implementation Requirements:
-+   - Follow section headers from technical.md
-+   - Use animation patterns from technical.md
-+   - Implement feature gates per architecture.md
-+   - Follow component organization rules
-+
-+3. Before ANY Code Changes:
-+   - PARSE technical.md for relevant patterns
-+   - VERIFY against architecture.md
-+   - CHECK current task context
-+   - VALIDATE component structure
-+```
-+
-+#### Premium Features / Feature Gates
-+```markdown
-+# Feature Gate Implementation
-+1. Source of Truth:
-+   - Load feature definitions from "Feature Control" section in technical.md
-+   - Follow implementation patterns from "Feature Gates" section
-+   - Reference component examples from technical.md
-+
-+2. Validation Requirements:
-+   - Verify component against documented feature gate patterns
-+   - Ensure proper hook usage (useSubscriptionStatus) as shown in examples
-+   - Confirm implementation matches technical.md specifications
-+   
-+3. Documentation Requirements:
-+   - Reference "Free Features" and "Premium Features" sections in technical.md
-+   - Link to relevant implementation examples
-+   - Keep implementation aligned with documentation
-+```
-+
-+#### Architecture Understanding
-+```markdown
-+# Architecture Understanding
-+Required parsing:
-+1. Load and parse Mermaid diagram focusing on:
-+   - Auth -> Onboarding flow
-+   - Feature Gates system
-+   - Free vs Premium features
-+   - Game systems
-+   - Data collection flow
-+2. Extract and understand:
-+   - Premium vs Free feature boundaries
-+   - Clerk Auth integration points
-+   - Data flow patterns
-+   - Component dependencies
-+3. Validate changes against architectural constraints
-+4. Ensure proper feature gating
-+```
-+
-+#### Package Management
-+```markdown
-+# Package Management Rules
-+- Never manually edit package-lock.json
-+- Use npm install for adding new packages
-+- Commit both package.json and package-lock.json together
-+- Report conflicts in package-lock.json to team lead
-+- Run npm ci for clean installs
-+- Contact Josh for dependency updates
-+```
-+
-+#### Error Prevention & Documentation Standards
-+```markdown
-+# Error Prevention
-+Before responding to any query:
-+1. Load and parse technical.md completely
-+2. Check section dividers (100 dashes)
-+3. Validate heading hierarchy
-+4. Ensure code blocks follow documentation rules
-+5. Verify file paths in examples
-+
-+# Documentation Standards
-+For all .md files:
-+1. Verify proper markdown link syntax
-+2. Check code block formatting
-+3. Validate section dividers
-+4. Ensure proper heading hierarchy
-+5. Check for complete examples in guidelines
-+```
-+
-+#### File Management Rules
-+```markdown
-+# File Management Rules
-+Required actions after code changes:
-+1. VERIFY premium feature gates implementation
-+2. CHECK README_Docs/architecture/architecture.md compliance
-+3. UPDATE personal status.md with:
-+   - Current progress
-+   - Any blockers
-+   - Completed items
-+4. VALIDATE against technical.md specifications
-+5. VERIFY task progress
-+```
-+
-+[x] Create component-guidelines.mdc and state-management.mdc files
-+[ ] Migrate remaining content from .cursorrules to appropriate .mdc files
-+[ ] Delete .cursorrules file after migration is complete
-+
-+## Bugs
-+[ ] CARS Suite - take out sound when you select answer. (Prynce bug)
-+
-diff --git a/README_Docs/tasks/user-dennis/2-single-task-steps.md b/README_Docs/tasks/user-dennis/2-single-task-steps.md
-new file mode 100644
-index 0000000000000000000000000000000000000000..8e4907140e215b0b37cc1e2b1ff447b01ef25dac
---- /dev/null
-+++ b/README_Docs/tasks/user-dennis/2-single-task-steps.md
-@@ -0,0 +1 @@
-+### Branch TODO:
-diff --git a/store/slices/vocalSlice.ts b/README_Docs/tasks/user-dennis/3-pr-diff.txt
-similarity index 100%
-rename from store/slices/vocalSlice.ts
-rename to README_Docs/tasks/user-dennis/3-pr-diff.txt
-index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..cabc2379a6319719cbd31e5a69406b233be68402 100644
-diff --git a/README_Docs/tasks/user-dennis/4-debug-console.txt b/README_Docs/tasks/user-dennis/4-debug-console.txt
-new file mode 100644
-index 0000000000000000000000000000000000000000..b21b8195ed13cb7f9ccc5a0a96f3333808b4d360
---- /dev/null
-+++ b/README_Docs/tasks/user-dennis/4-debug-console.txt
-@@ -0,0 +1,106 @@
-+initializationContentScript.js:1 Chrome storage API available, initializing emoji style sync
-+content.js:1 [Deprecation] Listener added for a 'DOMNodeInserted' mutation event. Support for this event type has been removed, and this event will no longer be fired. See https://chromestatus.com/feature/5083947249172480 for more information.
-+(anonymous) @ content.js:1
-+j @ jquery.js:2
-+fireWith @ jquery.js:2
-+ready @ jquery.js:2
-+I @ jquery.js:2
-+contentScript.js:2 Chrome storage API available, initializing emoji style sync
-+
-+                
-+          
-+          
-+          
-+         Chrome is moving towards a new experience that allows users to choose to browse without third-party cookies.
-+script.debug.js:1 [Vercel Web Analytics] Debug mode is enabled by default in development. No requests will be sent to the server.
-+script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/ {o: 'http://localhost:3000/', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742417480019,Â â€¦}
-+hot-reloader-client.tsx:297 [Fast Refresh] rebuilding
-+hot-reloader-client.tsx:74 [Fast Refresh] done in 19811ms
-+script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/sign-in {o: 'http://localhost:3000/sign-in', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742417512522,Â â€¦}
-+ui-common_a52944_5.57.0.js:1 ðŸ”’ Clerk:
-+The <SignIn/> component cannot render when a user is already signed in, unless the application allows multiple sessions. Since a user is signed in and this application only allows a single session, Clerk is redirecting to the `afterSignIn` URL instead.
-+(This notice only appears in development)
-+script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/home {o: 'http://localhost:3000/home', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742417516507,Â â€¦}
-+musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-+musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-+musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: false, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-+musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: sakuraTrees
-+audioSlice.ts:193 [AudioSlice] Theme changed to sakuraTrees wasPlaying: false
-+layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
-+musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-+musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-+musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-+musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: sakuraTrees
-+audioSlice.ts:193 [AudioSlice] Theme changed to sakuraTrees wasPlaying: false
-+layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
-+musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-+musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: false}
-+musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-+musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-+audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-+audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-+hot-reloader-client.tsx:297 [Fast Refresh] rebuilding
-+purchase-button.tsx:52 Attempting MD_GOLD purchase... {productType: 'md_gold', isSubscribed: true}
-+purchase-button.tsx:58 User is already subscribed, redirecting to manage subscription
-+contentInt.js:1 
-+            
-+            
-+           GET http://localhost:3000/api/stripe 400 (Bad Request)
-+e.class.n.value.t.send @ contentInt.js:1
-+dispatchXhrRequest @ xhr.js:195
-+xhr @ xhr.js:15
-+dispatchRequest @ dispatchRequest.js:51
-+_request @ Axios.js:173
-+request @ Axios.js:40
-+Axios.<computed> @ Axios.js:199
-+wrap @ bind.js:5
-+handlePurchase @ purchase-button.tsx:59
-+onClick @ purchase-button.tsx:174
-+callCallback @ react-dom.development.js:20565
-+invokeGuardedCallbackImpl @ react-dom.development.js:20614
-+invokeGuardedCallback @ react-dom.development.js:20689
-+invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:20703
-+executeDispatch @ react-dom.development.js:32128
-+processDispatchQueueItemsInOrder @ react-dom.development.js:32160
-+processDispatchQueue @ react-dom.development.js:32173
-+dispatchEventsForPlugins @ react-dom.development.js:32184
-+eval @ react-dom.development.js:32374
-+batchedUpdates$1 @ react-dom.development.js:24953
-+batchedUpdates @ react-dom.development.js:28844
-+dispatchEventForPluginEventSystem @ react-dom.development.js:32373
-+dispatchEvent @ react-dom.development.js:30141
-+dispatchDiscreteEvent @ react-dom.development.js:30112
-+ChatContainer.tsx:117 [ChatContainer] KeyDown: Meta repeat: false cmdPressedRef: false
-+ChatContainer.tsx:121 [ChatContainer] Setting cmdPressedRef to true
-+ChatContainer.tsx:117 [ChatContainer] KeyDown: Shift repeat: false cmdPressedRef: true
-+ChatContainer.tsx:128 [ChatContainer] Combo detected, clearing cmdPressedTime
-+purchase-button.tsx:52 Attempting MD_GOLD purchase... {productType: 'md_gold', isSubscribed: true}
-+purchase-button.tsx:58 User is already subscribed, redirecting to manage subscription
-+contentInt.js:1 
-+            
-+            
-+           GET http://localhost:3000/api/stripe 400 (Bad Request)
-+e.class.n.value.t.send @ contentInt.js:1
-+dispatchXhrRequest @ xhr.js:195
-+xhr @ xhr.js:15
-+dispatchRequest @ dispatchRequest.js:51
-+_request @ Axios.js:173
-+request @ Axios.js:40
-+Axios.<computed> @ Axios.js:199
-+wrap @ bind.js:5
-+handlePurchase @ purchase-button.tsx:59
-+onClick @ purchase-button.tsx:174
-+callCallback @ react-dom.development.js:20565
-+invokeGuardedCallbackImpl @ react-dom.development.js:20614
-+invokeGuardedCallback @ react-dom.development.js:20689
-+invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:20703
-+executeDispatch @ react-dom.development.js:32128
-+processDispatchQueueItemsInOrder @ react-dom.development.js:32160
-+processDispatchQueue @ react-dom.development.js:32173
-+dispatchEventsForPlugins @ react-dom.development.js:32184
-+eval @ react-dom.development.js:32374
-+batchedUpdates$1 @ react-dom.development.js:24953
-+batchedUpdates @ react-dom.development.js:28844
-+dispatchEventForPluginEventSystem @ react-dom.development.js:32373
-+dispatchEvent @ react-dom.development.js:30141
-+dispatchDiscreteEvent @ react-dom.development.js:30112
-diff --git a/README_Docs/tasks/user-dennis/5-cursor-notes.md b/README_Docs/tasks/user-dennis/5-cursor-notes.md
-new file mode 100644
-index 0000000000000000000000000000000000000000..909495f5285da102e6fbf353f81bb494e9b96ea1
---- /dev/null
-+++ b/README_Docs/tasks/user-dennis/5-cursor-notes.md
-@@ -0,0 +1,33 @@
-+## Cursor Notes
-+
-+#### Prompts
-+` Do not apply code changes, just analyze the codebase and write out your steps to 2-single-task-steps.md`
-+
-+#### Compare functionality to main
-+To thoroughly evaluate whether our branch behaves functionally the same as main, use both approaches:
-+1. Add main branch to worktree for direct file comparison:
-+```bash
-+# Add main branch as a worktree for comparison
-+git worktree add main
-+# When finished with comparison
-+git worktree remove main
-+```
-+
-+2. Create a diff file for Cursor analysis:
-+```bash
-+# Generate detailed diff against main
-+git diff --full-index main -- > README_Docs/tasks/user-dennis/3-pr-diff.txt
-+```
-+
-+3. Working with Cursor:
-+Prompt to use for comparison
-+
-+```
-+Carefully examine both the diff against main @3-pr-diff.txt and our `main` branch repo itself, which was added to our worktree @main 
-+Evaluate whether our branch behaves and acts functionally the SAME as main.
-+```
-+
-+Having both the worktree and diff file available provides:
-+- Direct access to main branch files for inspection
-+- A comprehensive diff that Cursor can analyze
-+- The ability to verify functional equivalence with confidence
-\ No newline at end of file
-diff --git a/README_Docs/tasks/user-dennis/tasks.md b/README_Docs/tasks/user-dennis/tasks.md
-deleted file mode 100644
-index e2e1eaca7220ce90137d26ef9962411f472192f6..0000000000000000000000000000000000000000
---- a/README_Docs/tasks/user-dennis/tasks.md
-+++ /dev/null
-@@ -1,36 +0,0 @@
--TODO: 
--
--
--## Store Migration Progress
--[âœ“] Implemented audioSlice (complete)
--[âœ“] Implemented uiSlice (complete)
--[ ] Implement userSlice (files created but not implemented)
--[âœ“ ] Implement gameSlice (files created but not implemented)
--[ ] Implement vocabSlice (files created but not implemented)
--[ ] CARS Suite - take out sound when you select answer. (Prynce bug)
--
--
------
--## Cursor Notes
--
--#### Prompts
--` Do not apply code changes, just analyze the issue and respond to the question`
--
--#### Add new branch to worktree
--add new branch for Cursor to compare: 
--`git worktree add localstate-compare`
--
--remove it before pushing back up 
--`git worktree remove localstate-compare`
--
--#### Create diff file for Cursor
--
--To create a detailed diff against `main` with context:
--```
--git diff --full-index main > branch-diff-full.diff
--```
--
--To feed the diff back into Cursor:
--1. Create the diff file
--2. Open the diff file in Cursor
--3. Ask Cursor to analyze the changes
-\ No newline at end of file
-diff --git a/app/(auth)/(routes)/onboarding/components/GoldSubscriptionCard.tsx b/app/(auth)/(routes)/onboarding/components/GoldSubscriptionCard.tsx
-index 1d975e1c3809df4a6e0297b0c8e2803349719cce..8afe0a691181f7c9190d33221e8b542c04c536e8 100644
---- a/app/(auth)/(routes)/onboarding/components/GoldSubscriptionCard.tsx
-+++ b/app/(auth)/(routes)/onboarding/components/GoldSubscriptionCard.tsx
-@@ -36,6 +36,7 @@ export function GoldSubscriptionCard({ context }: { context: 'onboarding' | 'off
- 
-   const checkTrialEligibility = async () => {
-     try {
-+      // Instead of checking with Stripe, we check our internal trial eligibility
-       const response = await axios.get('/api/subscription/check-trial-eligibility');
-       setIsTrialEligible(response.data.isEligible);
-       
-@@ -52,7 +53,7 @@ export function GoldSubscriptionCard({ context }: { context: 'onboarding' | 'off
-   const handleStartTrial = async () => {
-     try {
-       setLocalLoading(true);
--      // Check eligibility first
-+      // Check eligibility first using our internal API
-       const response = await axios.get('/api/subscription/check-trial-eligibility');
-       if (!response.data.isEligible) {
-         toast.error("You're not eligible for a free trial at this time");
-@@ -60,8 +61,8 @@ export function GoldSubscriptionCard({ context }: { context: 'onboarding' | 'off
-         return;
-       }
-       
--      // Start the trial
--      const trialResponse = await axios.post('/api/subscription/start-trial');
-+      // Start the trial using our internal API
-+      const trialResponse = await axios.post('/api/user/start-trial');
-       if (trialResponse.data.success) {
-         toast.success("Your 14-day free trial has started!");
-         router.push('/examcalendar');
-@@ -79,26 +80,29 @@ export function GoldSubscriptionCard({ context }: { context: 'onboarding' | 'off
-   const handleAction = async () => {
-     try {
-       setIsLoading(true);
-+      console.log("GoldSubscriptionCard: handleAction initiated", { 
-+        isGold,
-+        context
-+      });
- 
-       if (isGold) {
--        // Manage existing subscription
--        const response = await axios.get("/api/stripe");
--        window.location.href = response.data.url;
--        return
-+        // Manage existing subscription - redirect to pricing instead of Stripe portal
-+        console.log("User is Gold member, redirecting to manage subscription");
-+        router.push('/pricing');
-+        return;
-       }
-       
-       if (context === 'onboarding') {
-         // Show the pricing page with more options
-+        console.log("Onboarding context, redirecting to pricing page");
-         router.push('/pricing');
-       } else {
--        // Direct checkout for gold
--        const response = await axios.post("/api/stripe/checkout", {
--          productType: "gold"
--        });
--        window.location.href = response.data.url;
-+        // Direct to pricing page instead of Stripe checkout
-+        console.log("Offer context, redirecting to pricing");
-+        router.push('/pricing');
-       }
-     } catch (error) {
--      console.error("Error:", error);
-+      console.error("Error in handleAction:", error);
-       toast.error("Failed to load page. Please try again.");
-     } finally {
-       setIsLoading(false);
-@@ -107,6 +111,11 @@ export function GoldSubscriptionCard({ context }: { context: 'onboarding' | 'off
- 
-   return (
-     <div 
-+      onClick={() => {
-+        if (!isGold) {
-+          router.push('/pricing');
-+        }
-+      }}
-       className={`relative h-full group transform transition-all duration-200 hover:scale-[1.02] cursor-pointer
-         ${isGold ? 'before:absolute before:inset-0 before:bg-gradient-to-br before:from-amber-400/10 before:via-yellow-400/5 before:to-amber-400/10 before:rounded-lg border-2 border-amber-300' : ''}`}
-     >
-diff --git a/app/api/stripe/checkout/route.ts b/app/api/stripe/checkout/route.ts
-index 80e97a6c12d3d3392e1f887659bdfbc5bc62bc8a..236d0d0ee1db1106ca7c5b2f26f15a349fdf4bce 100644
---- a/app/api/stripe/checkout/route.ts
-+++ b/app/api/stripe/checkout/route.ts
-@@ -24,59 +24,8 @@ export async function POST(request: Request) {
-     }
- 
-     const body = await request.json();
--    // Extract isTrial parameter
--    const isTrial = body.isTrial || false;
-     const priceType = body.priceType as ProductType;
-     const isSpecialStatus = body.isSpecialStatus || false;
--    
--    // If user is trying to start a trial, check eligibility first
--    if (isTrial) {
--      // Check if the user has had a subscription or trial before
--      const userInfo = await prismadb.userInfo.findUnique({
--        where: { userId }
--      });
--      
--      const userSubscription = await prismadb.userSubscription.findUnique({
--        where: { userId }
--      });
--      
--      // If user has had any subscription before, they're not eligible
--      if (userInfo?.subscriptionType && userInfo.subscriptionType !== "None") {
--        return new NextResponse(
--          JSON.stringify({ 
--            error: "You've already had a subscription and are not eligible for a trial" 
--          }), 
--          { status: 400 }
--        );
--      }
--      
--      // If they have a subscription record, check with Stripe
--      if (userSubscription?.stripeCustomerId) {
--        try {
--          // Look for trial history in Stripe
--          const subscriptions = await stripe.subscriptions.list({
--            customer: userSubscription.stripeCustomerId,
--            limit: 100,
--            status: 'all'
--          });
--          
--          // Check if any subscription has trial_start, indicating they've had a trial
--          const hadTrialBefore = subscriptions.data.some(sub => sub.trial_start !== null);
--          
--          if (hadTrialBefore) {
--            return new NextResponse(
--              JSON.stringify({ 
--                error: "You've already had a trial subscription" 
--              }), 
--              { status: 400 }
--            );
--          }
--        } catch (error) {
--          console.error("Error checking subscription history:", error);
--          // If we can't check, we'll allow them to continue
--        }
--      }
--    }
- 
-     // Make body parsing optional with default values
-     let friendEmail: string | undefined;
-@@ -89,111 +38,6 @@ export async function POST(request: Request) {
-       // If JSON parsing fails, we'll just use the default values
-     }
- 
--    // If there's a valid friend email, create UserInfo with bonus score instead of checkout
--    if (friendEmail?.trim()) {
--      const user = await currentUser();
--      if (!user) {
--        return new NextResponse("User not found", { status: 404 });
--      }
--
--      const userEmail = user.emailAddresses[0]?.emailAddress;
--
--      // Check if user exists
--      const existingUser = await prismadb.userInfo.findUnique({
--        where: { userId }
--      });
--
--      if (!existingUser) {
--        return new NextResponse("User not found. Please complete onboarding first.", { status: 404 });
--      }
--
--      // Update existing user
--      const userInfo = await prismadb.userInfo.update({
--        where: { userId },
--        data: {
--          score: {
--            increment: 5, // Add 5 to the existing score
--          },
--        },
--      });
--
--      // Handle referral logic
--      if (user) {
--        let referrerName: string | undefined;
--
--        referrerName = userInfo?.firstName || user.firstName || "A friend";
--
--        // Send both welcome and referral emails
--        await Promise.all([
--          sendWelcomeEmail(referrerName, userEmail),
--          sendReferralEmail(referrerName, friendEmail),
--        ]);
--
--        try {
--          await prismadb.referral.create({
--            data: {
--              userId,
--              referrerName: user.fullName ?? "Unknown",
--              referrerEmail: userEmail ?? "",
--              friendEmail,
--            },
--          });
--
--          const REFERRAL_REWARD = 10;
--          // Update joinedAt and friendUserId for all referrals if friendUserId is null
--          await prismadb.referral.updateMany({
--            where: {
--              friendEmail: userEmail,
--              friendUserId: null
--            },
--            data: {
--              joinedAt: new Date(),
--              friendUserId: userId
--            }
--          });
--
--          // Get the oldest referral record for this userEmail
--          const referral = await prismadb.referral.findFirst({
--            where: {
--              friendEmail: userEmail
--            },
--            orderBy: {
--              createdAt: 'asc'
--            }
--          })
--
--          if (referral) {
--            // Referral user get REFERRAL_REWARD coins
--            const referralUserId = referral.userId;
--
--            if (referralUserId !== userId) {
--              await prismadb.userInfo.update({
--                where: { userId: referralUserId },
--                data: {
--                  score: {
--                    increment: REFERRAL_REWARD
--                  }
--                }
--              })
--            }
--          }
--        } catch (error) {
--          console.error("Error creating referral:", error);
--          // Continue execution even if referral creation fails
--        }
--      }
--
--      // Return success response for referred users with redirect URL
--      return NextResponse.json(
--        {
--          success: true,
--          message: "User setup completed with referral bonus",
--          url: `${process.env.NEXT_PUBLIC_APP_URL}/home`,
--        },
--        { headers: corsHeaders }
--      );
--    }
--
-     // If no friend email, proceed with regular Stripe checkout
-     let priceId: string;
-     let productType: ProductType = ProductType.COINS_10; // Default product type
-@@ -232,15 +76,12 @@ export async function POST(request: Request) {
-           break;
-         case ProductType.COINS_10:
-         default:
--          priceId = process.env.STRIPE_PRICE_ID!;
-+          priceId = process.env.STRIPE_PRICE_ID!; // Default to 10 coins if invalid type
-       }
-     } else {
-       priceId = process.env.STRIPE_PRICE_ID!; // Default to 10 coins if invalid type
-     }
- 
--    // Set trial period days for subscription products if requested
--    const trialPeriodDays = isTrial && mode === 'subscription' ? 14 : undefined;
--
-     const stripeSession = await stripe.checkout.sessions.create({
-       success_url: absoluteUrl("/home?payment=success"),
-       cancel_url: absoluteUrl("/home?payment=cancelled"),
-@@ -248,9 +89,6 @@ export async function POST(request: Request) {
-       mode: mode,
-       billing_address_collection: "auto",
-       client_reference_id: userId,
--      subscription_data: trialPeriodDays ? {
--        trial_period_days: trialPeriodDays
--      } : undefined,
-       metadata: {
-         userId: userId,
-         productType: productType,
-@@ -259,8 +97,7 @@ export async function POST(request: Request) {
-           priceId === process.env.STRIPE_PRICE_GOLD_ID ? 'MDGold' :
-           priceId === process.env.STRIPE_PRICE_GOLD_ANNUAL_ID || priceId === process.env.STRIPE_PRICE_GOLD_ANNUAL_DISCOUNT_ID ? 'MDGoldAnnual' :
-           priceId === process.env.STRIPE_PRICE_GOLD_BIANNUAL_ID || priceId === process.env.STRIPE_PRICE_GOLD_BIANNUAL_DISCOUNT_ID ? 'MDGoldBiannual' : 'one_time_purchase'
--        ) : 'one_time_purchase',
--        isTrial: isTrial ? 'true' : 'false'
-+        ) : 'one_time_purchase'
-       },
-       line_items: [
-         {
-@@ -274,7 +111,6 @@ export async function POST(request: Request) {
-       userId,
-       mode,
-       productType,
--      isTrial,
-       metadata: stripeSession.metadata
-     });
- 
-diff --git a/app/api/subscription/check-trial-eligibility/route.ts b/app/api/subscription/check-trial-eligibility/route.ts
-index 62884d99f2e82289c8a479a452483038024d43c8..401b61de2e2f082bd20dcc9c3ef2a3c8f6e8a7b6 100644
---- a/app/api/subscription/check-trial-eligibility/route.ts
-+++ b/app/api/subscription/check-trial-eligibility/route.ts
-@@ -1,6 +1,5 @@
- import { NextResponse } from "next/server";
- import prismadb from "@/lib/prismadb";
--import { stripe } from "@/lib/stripe";
- import { auth } from "@clerk/nextjs/server";
- 
- export async function GET() {
-@@ -24,6 +23,7 @@ export async function GET() {
-     }
- 
-     // User is only eligible if they've never had any subscription status
-+    // This matches main branch logic but without checking Stripe history
-     const isEligible = !userInfo.subscriptionType || userInfo.subscriptionType === "";
-     const reason = isEligible 
-       ? "New user" 
-diff --git a/app/api/webhook/clerk/route.ts b/app/api/webhook/clerk/route.ts
-index adfe2227cac46e278a436e37cf4a7ce918ba7155..2165ba9ef8e04160892070dc88499967e20157c1 100644
---- a/app/api/webhook/clerk/route.ts
-+++ b/app/api/webhook/clerk/route.ts
-@@ -22,7 +22,7 @@ export async function POST(req: Request) {
-       status: 400
-     });
-   }
--
-+i
-   try {
-     // Get the body
-     const payload = await req.json();
-diff --git a/components/RouteTracker.tsx b/components/RouteTracker.tsx
-index 76a2738f71962de9bc7eba9a4b6f0149114605cd..bf8a1b1b2efabd341bbad112e5a29a828a799526 100644
---- a/components/RouteTracker.tsx
-+++ b/components/RouteTracker.tsx
-@@ -2,9 +2,7 @@
- 
- import { useEffect, useState } from 'react';
- import { usePathname, useRouter, useSearchParams } from 'next/navigation';
--import { useUI, useUser } from '@/store/selectors';
--import { useAudioStore } from '@/store/slices/audioSlice';
--import { OnboardingInfo } from '@/types';
-+import { useUI, useUser, useAudio } from '@/store/selectors';
- import { useUser as useClerkUser } from '@clerk/nextjs';
- 
- /**
-@@ -20,8 +18,7 @@ const RouteTracker = () => {
-   const { userInfo, isSubscribed, onboardingComplete, profileLoading, statsLoading } = useUser();
-   const { isSignedIn } = useClerkUser();
-   const [initialLoadComplete, setInitialLoadComplete] = useState(false);
--  const stopLoop = useAudioStore(state => state.stopLoop);
--  const currentLoop = useAudioStore(state => state.currentLoop);
-+  const { stopLoop, currentLoop } = useAudio();
- 
-   // Handle immediate redirection for users with no userInfo
-   useEffect(() => {
-@@ -39,7 +36,7 @@ const RouteTracker = () => {
-     // If user is signed in but has no userInfo, redirect to onboarding immediately
-     if (isSignedIn && !profileLoading && !userInfo) {
-       // Only allow exempt paths to proceed without redirection
--      if (!exemptPaths.some(path => pathname.startsWith(path))) {
-+      if (pathname && !exemptPaths.some(path => pathname.startsWith(path))) {
-         router.push('/onboarding');
-       }
-     }
-@@ -50,7 +47,6 @@ const RouteTracker = () => {
-     if (pathname) {
-       setCurrentRoute(pathname);
- 
--      // Define exempt paths that should never redirect to onboarding
-       const exemptPaths = [
-         '/auth',
-         '/api',
-@@ -61,7 +57,6 @@ const RouteTracker = () => {
-         '/register'
-       ];
- 
--      // Skip remaining redirection checks for exempt paths
-       if (exemptPaths.some(path => pathname.startsWith(path))) {
-         return;
-       }
-@@ -74,7 +69,13 @@ const RouteTracker = () => {
-       if (isSignedIn && !profileLoading && pathname !== '/onboarding') {
-         if (!onboardingComplete) {
-           router.push('/onboarding');
--          return;
-+          
-+          // Fallback for critical redirects
-+          const fallbackTimeout = setTimeout(() => {
-+            window.location.href = '/onboarding';
-+          }, 2000);
-+          
-+          return () => clearTimeout(fallbackTimeout);
-         }
-       }
-     }
-@@ -82,23 +83,19 @@ const RouteTracker = () => {
- 
-   // Handle ambient sound cleanup on route changes
-   useEffect(() => {    
--    // Only stop the ambient loop if we're not in AnkiClinic and it's currently playing
-     if (currentLoop === 'flashcard-loop-catfootsteps' && !pathname?.startsWith('/ankiclinic')) {
-       console.log('[RouteTracker] Stopping ambient loop - route changed to:', pathname);
-       stopLoop();
-     }
--  }, [pathname]); // Only depend on pathname changes, not currentLoop
-+  }, [pathname, currentLoop, stopLoop]);
- 
-   // Track when initial loading is complete - skip for onboarding
-   useEffect(() => {
--    // Skip loading state tracking if we're on onboarding
-     if (pathname === '/onboarding') {
-       setInitialLoadComplete(true);
-       return;
-     }
- 
--    // Consider data loaded when both profile and stats are loaded
--    // and we have userInfo data
-     if (!profileLoading && !statsLoading && userInfo && !initialLoadComplete) {
-       setInitialLoadComplete(true);
-     }
-@@ -106,16 +103,8 @@ const RouteTracker = () => {
- 
-   // Handle redirection logic
-   useEffect(() => {
--    // Skip redirection checks if we're on onboarding
--    if (pathname === '/onboarding') {
--      return;
--    }
--
--    // Only proceed if we have user info, a valid pathname, and initial loading is complete
--    // IMPORTANT: Also check if the user is signed in before redirecting
--    if (!userInfo || !pathname || !initialLoadComplete || !isSignedIn) {
--      return;
--    }
-+    if (pathname === '/onboarding') return;
-+    if (!userInfo || !pathname || !initialLoadComplete || !isSignedIn) return;
- 
-     const checkRedirectPath = async () => {
-       // Check for debug mode in query parameters
-@@ -129,19 +118,16 @@ const RouteTracker = () => {
-         return;
-       }
- 
--      // 1. Redirect to onboarding if user has not completed onboarding
-+      // 1. Redirect to onboarding if not complete
-       if (!onboardingComplete) {
-         router.push('/onboarding');
-         
-         // Fallback for critical redirects
-         const fallbackTimeout = setTimeout(() => {
-           window.location.href = '/onboarding';
--        }, 2000); // 2 second timeout
-+        }, 2000);
-         
--        // Clear timeout if component unmounts
-         return () => clearTimeout(fallbackTimeout);
--        
--        return;
-       }
- 
-       // 2. Redirect non-gold users to ankiclinic
-@@ -151,40 +137,39 @@ const RouteTracker = () => {
-         // Fallback for critical redirects
-         const fallbackTimeout = setTimeout(() => {
-           window.location.href = '/ankiclinic';
--        }, 2000); // 2 second timeout
-+        }, 2000);
-         
--        // Clear timeout if component unmounts
-         return () => clearTimeout(fallbackTimeout);
--        
--        return;
-       }
- 
--      // 3. Check if gold user needs study plan (skip for exempt paths)
--      // Match main branch exempt paths
--      const studyPlanExemptPaths = ['/examcalendar', '/api', '/auth', '/onboarding', '/redirect'];
-+      // 3. Check if gold user needs study plan
-+      const studyPlanExemptPaths = [
-+        '/examcalendar',
-+        '/api',
-+        '/auth',
-+        '/onboarding',
-+        '/redirect'
-+      ];
-       const shouldCheckStudyPlan = !studyPlanExemptPaths.some(path => pathname.startsWith(path));
-       
-       if (isSubscribed && shouldCheckStudyPlan) {
-         try {
-           const response = await fetch('/api/study-plan');
-           
--          // Add response validation like main branch
-           if (!response.ok) {
-             throw new Error('Failed to fetch study plan');
-           }
-           
-           const data = await response.json();
-           
--          // Redirect to examcalendar if no study plan
-           if (!data.studyPlan) {
-             router.push('/examcalendar');
-             
--            // Add fallback for critical redirects
-+            // Fallback for critical redirects
-             const fallbackTimeout = setTimeout(() => {
-               window.location.href = '/examcalendar';
--            }, 2000); // 2 second timeout
-+            }, 2000);
-             
--            // Clear timeout if component unmounts
-             return () => clearTimeout(fallbackTimeout);
-           }
-         } catch (error) {
-@@ -194,10 +179,6 @@ const RouteTracker = () => {
-     };
- 
-     checkRedirectPath();
--    
--    // onboardingComplete is critical in this dependency array
--    // When it changes (via store updates), this effect re-runs and ensures
--    // the user is redirected correctly based on their current onboarding status
-   }, [pathname, router, userInfo, isSubscribed, onboardingComplete, initialLoadComplete, isSignedIn, searchParams]);
- 
-   return null;
-diff --git a/components/ScoreDialog.tsx b/components/ScoreDialog.tsx
-index 9b34eaa96896485c9d76429a3de6e48eb87f0055..d22260e5fcaafb79b1b5b144a846594c81611416 100644
---- a/components/ScoreDialog.tsx
-+++ b/components/ScoreDialog.tsx
-@@ -1,12 +1,12 @@
- //components/ScoreDialog.tsx
- 'use client';
--import React, { useEffect, useRef, useState } from 'react';
-+import React, { useEffect, useRef, useState, useCallback } from 'react';
- import { Star } from 'lucide-react';
- import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
- import { useRouter } from 'next/navigation'; 
- import Link from 'next/link';
--import Image from 'next/image'; // Added import
--import { useAudio } from '@/store/selectors'; // Replace useAudioManager
-+import Image from 'next/image';
-+import { useAudio } from '@/store/selectors';
- 
- interface ScoreDialogProps {
-   open: boolean;
-@@ -39,74 +39,131 @@ const ScoreDialog: React.FC<ScoreDialogProps> = ({
-   const [timingStars, setTimingStars] = useState(0);
-   const [techniqueStars, setTechniqueStars] = useState(0);
-   const router = useRouter();
--  const audio = useAudio(); // Replace useAudioManager
-+  const audio = useAudio();
-+  
-+  // Track animation intervals for cleanup
-+  const intervalsRef = useRef<Array<NodeJS.Timeout>>([]);
-+  // Track animation values in refs to reduce renders
-+  const currentScoreRef = useRef(0);
-+  const animationCompleteRef = useRef(false);
-+  // Flag to ensure sound is played only once
-+  const soundPlayedRef = useRef(false);
-+  // Dialog previous state 
-+  const wasOpenRef = useRef(false);
- 
--  useEffect(() => {
--    if (open) {
--      // Play appropriate sound based on score
--      if (score === 100) {
--        audio.playSound('fanfare');
--      } else if (score >= 60) {
--        audio.playSound('levelup');
--      } else {
--        audio.playSound('sadfanfare');
--      }
-+  // Memoized cleanup function
-+  const cleanupIntervals = useCallback(() => {
-+    intervalsRef.current.forEach(interval => clearInterval(interval));
-+    intervalsRef.current = [];
-+  }, []);
- 
--      // Animate the score percentage
--      let currentScore = 0;
--      const scoreInterval = setInterval(() => {
--        if (currentScore < score) {
--          currentScore += 1;
--          setAnimatedScore(currentScore);
--        } else {
--          clearInterval(scoreInterval);
-+  // Play sound once when dialog opens
-+  useEffect(() => {
-+    // Only play sound when the dialog first opens
-+    if (open && !wasOpenRef.current && !soundPlayedRef.current) {
-+      soundPlayedRef.current = true;
-+      
-+      // Use setTimeout to ensure sound isn't played immediately during render loop
-+      setTimeout(() => {
-+        // Double check the flag hasn't changed
-+        if (soundPlayedRef.current && open) {
-+          // Play appropriate sound based on score
-+          if (score === 100) {
-+            audio.playSound('fanfare');
-+          } else if (score >= 60) {
-+            audio.playSound('levelup');
-+          } else {
-+            audio.playSound('sadfanfare');
-+          }
-         }
--      }, 20);
-+      }, 100);
-+    }
-+    
-+    // Reset sound played flag when dialog closes
-+    if (!open && wasOpenRef.current) {
-+      soundPlayedRef.current = false;
-+    }
-+    
-+    // Update previous state
-+    wasOpenRef.current = open;
-+  }, [open, score, audio]);
- 
--      // Animate stars for score
--      let currentScoreStars = 0;
--      const targetScoreStars = getStarCount(score);
--      const scoreStarsInterval = setInterval(() => {
--        if (currentScoreStars < targetScoreStars) {
--          currentScoreStars += 0.1;
--          setScoreStars(currentScoreStars);
--        } else {
--          clearInterval(scoreStarsInterval);
--        }
--      }, 50);
-+  useEffect(() => {
-+    // Reset values when dialog opens
-+    if (open) {
-+      animationCompleteRef.current = false;
-+      currentScoreRef.current = 0;
-+      setAnimatedScore(0);
-+      setScoreStars(0);
-+      setTimingStars(0);
-+      setTechniqueStars(0);
- 
--      // Animate stars for timing
--      let currentTimingStars = 0;
--      const targetTimingStars = getTimingStars(totalTimeTaken, totalQuestions);
--      const timingStarsInterval = setInterval(() => {
--        if (currentTimingStars < targetTimingStars) {
--          currentTimingStars += 0.1;
--          setTimingStars(currentTimingStars);
--        } else {
--          clearInterval(timingStarsInterval);
--        }
--      }, 50);
-+      // Create all animations at once with a single timeout
-+      setTimeout(() => {
-+        // Handle all animations after a brief delay
-+        startAnimations();
-+      }, 300);
-+    }
- 
--      // Animate stars for technique
--      let currentTechniqueStars = 0;
--      const targetTechniqueStars = getTechniqueStars(technique);
--      const techniqueStarsInterval = setInterval(() => {
--        if (currentTechniqueStars < targetTechniqueStars) {
--          currentTechniqueStars += 0.1;
--          setTechniqueStars(currentTechniqueStars);
--        } else {
--          clearInterval(techniqueStarsInterval);
--        }
--      }, 50);
-+    return () => {
-+      cleanupIntervals();
-+    };
-+  }, [open, cleanupIntervals, totalTimeTaken, totalQuestions, technique]);
- 
--      return () => {
--        clearInterval(scoreInterval);
--        clearInterval(scoreStarsInterval);
--        clearInterval(timingStarsInterval);
--        clearInterval(techniqueStarsInterval);
--      };
--    }
--  }, [open, score, audio]);
-+  // Function to start all animations
-+  const startAnimations = () => {
-+    if (animationCompleteRef.current) return;
-+    
-+    cleanupIntervals(); // Clear any existing intervals
-+    
-+    // Calculate target values
-+    const targetScore = score;
-+    const targetScoreStars = getStarCount(score);
-+    const targetTimingStars = getTimingStars(totalTimeTaken, totalQuestions);
-+    const targetTechniqueStars = getTechniqueStars(technique);
-+    
-+    // Use a single animation frame for all animations
-+    let frameCount = 0;
-+    const totalFrames = 15; // Complete all animations in 15 frames
-+    
-+    const animationInterval = setInterval(() => {
-+      frameCount++;
-+      
-+      if (frameCount >= totalFrames) {
-+        // Final frame - set exact values
-+        setAnimatedScore(targetScore);
-+        setScoreStars(targetScoreStars);
-+        setTimingStars(targetTimingStars);
-+        setTechniqueStars(targetTechniqueStars);
-+        animationCompleteRef.current = true;
-+        cleanupIntervals();
-+        return;
-+      }
-+      
-+      // Calculate progress (0 to 1)
-+      const progress = frameCount / totalFrames;
-+      
-+      // Update all values based on progress
-+      const newScore = Math.floor(targetScore * progress);
-+      const newScoreStars = targetScoreStars * progress;
-+      const newTimingStars = targetTimingStars * progress;
-+      const newTechniqueStars = targetTechniqueStars * progress;
-+      
-+      // Only update state if the value has changed significantly
-+      if (Math.abs(newScore - currentScoreRef.current) >= 5) {
-+        currentScoreRef.current = newScore;
-+        setAnimatedScore(newScore);
-+      }
-+      
-+      setScoreStars(newScoreStars);
-+      setTimingStars(newTimingStars);
-+      setTechniqueStars(newTechniqueStars);
-+      
-+    }, 100); // 100ms per frame, ~1.5 seconds total animation
-+    
-+    // Store interval for cleanup
-+    intervalsRef.current.push(animationInterval);
-+  };
- 
-   const getStarCount = (score: number) => {
-     if (score === 100) return 3;
-diff --git a/components/StoreInitializer.tsx b/components/StoreInitializer.tsx
-index f069d69db98090edc13beb96fef5d28f95a86c62..8f93c948910eda3c2f3cbb4c5907ce3b783b10d1 100644
---- a/components/StoreInitializer.tsx
-+++ b/components/StoreInitializer.tsx
-@@ -1,8 +1,8 @@
- "use client";
- 
- import { useEffect } from 'react';
--import { useUser } from '@clerk/nextjs';
--import { useStore } from '@/store/store';
-+import { useUser as useClerkUser } from '@clerk/nextjs';
-+import { useUser } from '@/store/selectors';
- import { useAudioStore } from '@/store/slices/audioSlice';
- import { initializeGlobalStore } from '@/store';
- 
-@@ -17,21 +17,23 @@ import { initializeGlobalStore } from '@/store';
-  * It doesn't render anything visible, just handles initialization.
-  */
- const StoreInitializer = () => {
--  const { isLoaded, isSignedIn } = useUser();
--  const refreshUserInfo = useStore(state => state.refreshUserInfo);
-+  const { isLoaded, isSignedIn } = useClerkUser();
-+  const { refreshUserInfo } = useUser();
-   const initializeAudioContext = useAudioStore(state => state.initializeAudioContext);
-   
-   // Initialize the global store when the app starts
-   useEffect(() => {
--    // Initialize audio context
--    initializeAudioContext().catch(error => {
--      console.error('[StoreInitializer] Error initializing audio context:', error);
--    });
-+    if (typeof window === 'undefined') return;
-     
--    // Initialize global store (will be expanded as we add more slices)
-+    // Initialize global store
-     initializeGlobalStore().catch(error => {
-       console.error('[StoreInitializer] Error initializing global store:', error);
-     });
-+    
-+    // Initialize audio context
-+    initializeAudioContext().catch(error => {
-+      console.error('[StoreInitializer] Error initializing audio context:', error);
-+    });
-   }, [initializeAudioContext]);
-   
-   // Refresh user information when the user is signed in
-diff --git a/components/pricing/options/SoftwareSection.tsx b/components/pricing/options/SoftwareSection.tsx
-index aa2451d7d08af36fdd19f0612319b1b6e1939698..783287eeea784384d5aee54193c8fee0431387f5 100644
---- a/components/pricing/options/SoftwareSection.tsx
-+++ b/components/pricing/options/SoftwareSection.tsx
-@@ -1,6 +1,6 @@
- import { CustomVideo } from "../CustomVideo";
- import Image from "next/image";
--import { useState, useEffect } from "react";
-+import { useState } from "react";
- import axios from "axios";
- import { toast } from "react-hot-toast";
- import { ProductType } from "@/types";
-@@ -28,8 +28,6 @@ const SoftwareSection = ({
- }: SoftwareSectionProps) => {
-   /* ---- State ----- */
-   const [showTestimonials, setShowTestimonials] = useState(false);
--  const [localLoading, setLocalLoading] = useState(false);
--  const [isTrialEligible, setIsTrialEligible] = useState(true);
-   const { isTrialing, isCanceled } = useSubscriptionStatus();
- 
-   /* ---- Helper Methods ----- */
-@@ -59,76 +57,11 @@ const SoftwareSection = ({
-     }
-   };
- 
--  /* ---- Animations & Effects --- */
--  useEffect(() => {
--    // Check trial eligibility when component mounts and user is available
--    if (user?.id) {
--      checkTrialEligibility();
--    }
--  }, [user?.id]);
--
-   /* ---- Event Handlers ----- */
-   const handlePeriodSelection = (period: 'monthly' | 'biannual' | 'annual') => {
-     setPricingPeriod(period);
-   };
- 
--  const checkTrialEligibility = async () => {
--    try {
--      const response = await axios.get('/api/subscription/check-trial-eligibility');
--      setIsTrialEligible(response.data.isEligible);
--      
--      if (!response.data.isEligible) {
--        console.log("User not eligible for trial:", response.data.reason);
--      }
--    } catch (error) {
--      console.error("Error checking trial eligibility:", error);
--      // Default to eligible if we can't check
--      setIsTrialEligible(true);
--    }
--  };
--
--  // Handle starting a free trial
--  const handleStartTrial = async () => {
--    try {
--      // Check eligibility first
--      const response = await axios.get('/api/subscription/check-trial-eligibility');
--      if (!response.data.isEligible) {
--        toast.error("You're not eligible for a free trial");
--        return;
--      }
--      
--      setLocalLoading(true);
--      
--      const userId = user?.id;
--      
--      if (!userId) {
--        // If not authenticated, redirect to sign-up with return URL
--        const returnUrl = encodeURIComponent(window.location.pathname);
--        window.location.href = `/sign-up?redirect_url=${returnUrl}`;
--        return;
--      }
--
--      // Map pricing period to the correct product type
--      const priceType = pricingPeriod === 'monthly' ? ProductType.MD_GOLD :
--                       pricingPeriod === 'annual' ? ProductType.MD_GOLD_ANNUAL :
--                       ProductType.MD_GOLD_BIANNUAL;
--
--      // Pass trial=true to the API
--      const checkoutResponse = await axios.post("/api/stripe/checkout", {
--        priceType: priceType,
--        isSpecialStatus: isSpecialStatus,
--        isTrial: true
--      });
--      
--      window.location.href = checkoutResponse.data.url;
--    } catch (error) {
--      console.error("Error:", error);
--      toast.error("Failed to start trial");
--    } finally {
--      setLocalLoading(false);
--    }
--  };
--
-   /* ---- Render Methods ----- */
-   return (
-     <div className="mt-8">
-@@ -147,9 +80,6 @@ const SoftwareSection = ({
-             <p className="text-white/60 text-sm mt-1">
-               ${getMonthlyPrice(pricingPeriod)}/month for comprehensive MCAT prep
-             </p>
--            <div className="mt-2 inline-flex items-center justify-center bg-blue-500/20 text-blue-300 px-3 py-1 rounded-full text-sm font-medium">
--              New 14-day free trial! âœ¨
--            </div>
-           </div>
- 
-           <div className="flex flex-col md:flex-row">
-@@ -348,7 +278,7 @@ const SoftwareSection = ({
-                     </button>
-                   </div>
- 
--                  {/* Upgrade button - Shows first */}
-+                  {/* Upgrade button */}
-                   <button
-                     onClick={handleUpgradeClick}
-                     className="w-full relative overflow-hidden bg-gradient-to-r from-amber-400 via-yellow-500 to-amber-500 text-black py-3 rounded-lg font-semibold 
-@@ -365,27 +295,6 @@ const SoftwareSection = ({
-                   >
-                     {isLoading ? 'Processing...' : `Get Gold ${pricingPeriod === 'monthly' ? 'Monthly' : pricingPeriod === 'biannual' ? 'Bi-Annual' : 'Annual'}`}
-                   </button>
--
--                  {/* Trial button - Only show if eligible, now appears below Gold button */}
--                  {isTrialEligible &&(
--                    <div className="space-y-2 mt-24">
--                      <button
--                        onClick={handleStartTrial}
--                        className="w-full relative overflow-hidden bg-gradient-to-r from-blue-500 to-blue-600 text-white py-3 rounded-lg font-semibold 
--                          transition-all duration-300
--                          hover:from-blue-400 hover:to-blue-700
--                          hover:shadow-[0_0_20px_rgba(59,130,246,0.5)]
--                          hover:scale-[1.02] hover:-translate-y-0.5
--                          active:scale-[0.98] active:shadow-[0_0_15px_rgba(59,130,246,0.4)]
--                          before:absolute before:content-[''] before:top-0 before:left-0 before:w-full before:h-full 
--                          before:bg-gradient-to-r before:from-transparent before:via-blue-200/10 before:to-transparent
--                          before:translate-x-[-100%] hover:before:translate-x-[100%] before:transition-transform before:duration-700"
--                        disabled={localLoading}
--                      >
--                        {localLoading ? 'Processing...' : 'Start 14-Day Free Trial'}
--                      </button>
--                    </div>
--                  )}
-                 </>
-               )}
-             </div>
-diff --git a/components/purchase-button.tsx b/components/purchase-button.tsx
-index 5e021add595fb9bb35c4d1b328af2ac2bd106394..5f65601f656ea9d17deb7bcd84a4dc6973e96e50 100644
---- a/components/purchase-button.tsx
-+++ b/components/purchase-button.tsx
-@@ -8,6 +8,7 @@ import axios from "axios";
- import { useState, useEffect } from "react";
- import { toast } from "react-hot-toast";
- import Image from "next/image";
-+import { useRouter } from "next/navigation";
- import { useUserInfo } from "@/hooks/useUserInfo";
- import { cn } from "@/lib/utils";
- 
-@@ -31,6 +32,7 @@ export function PurchaseButton({
-   const [loadingStates, setLoadingStates] = useState<Record<string, boolean>>({});
-   const [isModalOpen, setIsModalOpen] = useState(autoOpen);
-   const { isSubscribed, isLoading } = useUserInfo();
-+  const router = useRouter();
- 
-   useEffect(() => {
-     setIsModalOpen(autoOpen);
-@@ -49,21 +51,24 @@ export function PurchaseButton({
-       setLoadingStates(prev => ({ ...prev, [productType]: true }));
-       
-       if (productType === ProductType.MD_GOLD) {
--        if (isSubscribed) {
--          const response = await axios.get("/api/stripe");
--          window.location.href = response.data.url;
--          return;
--        }
--        window.location.href = '/pricing';
-+        console.log("Redirecting to pricing page for MD Gold subscription");
-+        router.push('/pricing');
-         return;
-       }
- 
-+      console.log("Initiating checkout for product type:", productType);
-       const response = await axios.post("/api/stripe/checkout", {
-         priceType: productType
-       });
-+      console.log("Checkout response:", response.data);
-       window.location.href = response.data.url;
--    } catch (error) {
--      console.error("Error:", error);
-+    } catch (error: any) {
-+      console.error("Error during purchase:", error);
-+      // Log more details if available
-+      if (error.response) {
-+        console.error("Error response data:", error.response.data);
-+        console.error("Error response status:", error.response.status);
-+      }
-       toast.error("Failed to initiate purchase. Please try again.");
-     } finally {
-       setLoadingStates(prev => ({ ...prev, [productType]: false }));
-diff --git a/components/ui/DebugPanel.tsx b/components/ui/DebugPanel.tsx
-index 6cdc43ac44354a32168255b2a5af87c9aa919c11..a73fa72c3df9c67cff6d8e59d27ab167e78d6e01 100644
---- a/components/ui/DebugPanel.tsx
-+++ b/components/ui/DebugPanel.tsx
-@@ -2,7 +2,7 @@
- 
- import { useState, useEffect } from 'react';
- import { usePathname, useSearchParams } from 'next/navigation';
--import { useUI, useUser, useGame, useAudio } from '@/store/selectors'
-+import { useUI, useUser, useGame, useAudio, useVocab } from '@/store/selectors'
- 
- /* --- Constants ----- */
- const DEBUG_PARAM = 'debug'
-@@ -18,6 +18,7 @@ const DebugPanel = () => {
-   const userState = useUser()
-   const gameState = useGame()
-   const audioState = useAudio()
-+  const vocabState = useVocab()
- 
-   /* --- Effects --- */
-   // Simple debug mode logic - only use URL parameter
-@@ -96,6 +97,11 @@ const DebugPanel = () => {
-           <h4 className="font-bold">User State</h4>
-           <pre>{JSON.stringify(userState, null, 2)}</pre>
-         </div>
-+        <hr className="border-white/30 my-2" />
-+        <div>
-+          <h4 className="font-bold">Vocab State</h4>
-+          <pre>{JSON.stringify(vocabState, null, 2)}</pre>
-+        </div>
-       </div>
-     </div>
-   )
-diff --git a/hooks/useOnboardingInfo.ts b/hooks/useOnboardingInfo.ts
-index 98f9c34265e89fdbb165fd1ad584e38ebdabc7b5..62517567e251a1c5ee3ff3ec1fdb726350752020 100644
---- a/hooks/useOnboardingInfo.ts
-+++ b/hooks/useOnboardingInfo.ts
-@@ -1,4 +1,4 @@
--import { useState, useEffect, useCallback } from 'react';
-+import { useState, useEffect } from 'react';
- import { OnboardingInfo } from '@/types';
- import { toast } from 'react-hot-toast';
- import { useRouter } from 'next/navigation';
-@@ -74,63 +74,52 @@ export function useOnboardingInfo() {
- 
-         // Set the step once we've determined the correct one
-         setCurrentStep(targetStep);
-+
-       } catch (error) {
-         console.error('Error fetching onboarding info:', error);
-+        toast.error('Failed to load your progress');
-       }
-     };
- 
-     fetchOnboardingInfo();
--  }, [router, onboardingComplete, setOnboardingComplete]);
-+  }, [onboardingComplete, router, setOnboardingComplete]);
- 
-+  // Update onboarding info in the database
-   const updateOnboardingInfo = async (updates: Partial<OnboardingInfo>) => {
-     try {
-       const response = await fetch('/api/user-info/onboarding', {
--        method: 'PUT',
-+        method: 'PATCH',
-         headers: { 'Content-Type': 'application/json' },
--        body: JSON.stringify(updates),
-+        body: JSON.stringify(updates)
-       });
- 
-       if (!response.ok) throw new Error('Failed to update onboarding info');
- 
-       const updatedInfo = await response.json();
--
--      // Update local state
-       setOnboardingInfo(updatedInfo);
-+
-+      // Update current step if provided
-       if (updates.currentStep && isValidStep(updates.currentStep)) {
-         setCurrentStep(updates.currentStep);
-       }
- 
-       return updatedInfo;
-     } catch (error) {
--      console.error('[updateOnboardingInfo] Error:', error);
-+      console.error('Error updating onboarding info:', error);
-       throw error;
-     }
-   };
- 
--  const handleNameSubmit = async (firstName: string) => {
-+  // Step submission handlers
-+  const handleNameSubmit = async (data: { firstName: string }) => {
-     try {
--      // Force create a new user info record
--      const response = await fetch("/api/user-info", {
--        method: "POST",
--        headers: { "Content-Type": "application/json" },
--        body: JSON.stringify({ firstName }),
--      });
--
--      if (!response.ok) throw new Error("Failed to create user info");
--
--      const data = await response.json();
--
--      // Store referral redemption status
--      localStorage.setItem('mymcat_show_redeem_referral_modal', data.referralRedeemed ? 'true' : 'false');
--
--      // Update onboarding info with fresh data
-       await updateOnboardingInfo({
--        firstName,
-+        ...data,
-         currentStep: ONBOARDING_STEPS.COLLEGE as OnboardingStep,
-       });
-     } catch (error) {
-       console.error("Error saving name:", error);
--      toast.error("Failed to save your information");
-+      toast.error("Failed to save your name");
-     }
-   };
- 
-@@ -204,38 +193,14 @@ export function useOnboardingInfo() {
-     }
-   };
- 
--  const handleReferralComplete = async (skipReferral: boolean = false) => {
--    try {
--      const updatedInfo = await updateOnboardingInfo({
--        currentStep: ONBOARDING_STEPS.UNLOCK as OnboardingStep,
--        onboardingComplete: true,
--      });
--
--      // Redirect immediately after successful update
--      if (updatedInfo?.onboardingComplete) {
--        if (isMobileButNotIpad()) {
--          router.push('/redirect');
--        } else {
--          router.push('/home');
--        }
--      } else {
--        console.error('[handleReferralComplete] Update successful but onboardingComplete not set');
--      }
--    } catch (error) {
--      console.error("[handleReferralComplete] Error:", error);
--      toast.error("Failed to proceed to next step");
--    }
--  };
--
-   return {
-     onboardingInfo,
--    updateOnboardingInfo,
-     currentStep,
-     handleNameSubmit,
-     handleCollegeSubmit,
-     handleAcademicsSubmit,
-     handleGoalsSubmit,
--    handleReferralComplete,
-     handleKalypsoComplete,
-+    ONBOARDING_STEPS
-   };
- } 
-\ No newline at end of file
-diff --git a/hooks/useSubscriptionStatus.ts b/hooks/useSubscriptionStatus.ts
-index f765d1a5bd871ed0bdcbdad43c465dcc46b6c296..c51e76c0c490b2d760a659afab4b60f6261898a1 100644
---- a/hooks/useSubscriptionStatus.ts
-+++ b/hooks/useSubscriptionStatus.ts
-@@ -81,7 +81,9 @@ export function useSubscriptionStatus() {
-   const isCanceled = stripeData.status?.subscription?.cancelAtPeriodEnd ?? false;
- 
-   // Calculate trial end date
--  const trialEnd = stripeData.status?.subscription?.trialEnd;
-+  const trialEnd = stripeData.status?.subscription?.trialEnd 
-+    ? new Date(stripeData.status?.subscription?.trialEnd) 
-+    : null;
-   
-   // Calculate days remaining in trial if in trial period
-   const trialDaysRemaining = trialEnd ? 
-@@ -98,7 +100,9 @@ export function useSubscriptionStatus() {
-     isNewUserTrial,
-     trialEnd,
-     trialDaysRemaining,
--    currentPeriodEnd: stripeData.status?.subscription?.currentPeriodEnd,
-+    currentPeriodEnd: stripeData.status?.subscription?.currentPeriodEnd 
-+      ? new Date(stripeData.status?.subscription?.currentPeriodEnd)
-+      : null,
-     isActive: isPremium || isGold,
-     stripeStatus: stripeData.status?.status || 'none',
-     // Map subscription type to a status
-diff --git a/state-management.mdc b/state-management.mdc
-new file mode 100644
-index 0000000000000000000000000000000000000000..8f7f2533f7c6474f51a33a163d671c7cd1a34eae
---- /dev/null
-+++ b/state-management.mdc
-@@ -0,0 +1,120 @@
-+---
-+description: 
-+globs: 
-+alwaysApply: false
-+---
-+ ---
-+name: State Management Patterns
-+description: Guidelines for managing state in the application
-+globs: ["**/*.tsx", "**/*.ts"]
-+alwaysApply: true
-+---
-+
-+### State Management Patterns
-+
-+#### Store Access
-+Always use the consolidated selector pattern from `@/store/selectors.ts` instead of directly importing from slice files.
-+
-+âœ… Correct: Use consolidated selectors
-+```typescript
-+import { useUI, useUser, useAudio } from '@/store/selectors';
-+
-+const MyComponent = () => {
-+  const { theme } = useUI();
-+  const { isSubscribed } = useUser();
-+  const { playSound, stopLoop } = useAudio();
-+  
-+  // Component implementation
-+};
-+```
-+
-+âŒ Incorrect: Direct imports from slice files
-+```typescript
-+import { useUIStore } from '@/store/slices/uiSlice';
-+import { useUserStore } from '@/store/slices/userSlice';
-+import { useAudioStore } from '@/store/slices/audioSlice';
-+
-+const MyComponent = () => {
-+  const theme = useUIStore(state => state.theme);
-+  const isSubscribed = useUserStore(state => state.isSubscribed);
-+  const playSound = useAudioStore(state => state.playSound);
-+  
-+  // Component implementation
-+};
-+```
-+
-+#### Local vs. Global State
-+
-+Consider using global state (Zustand) when:
-+
-+âœ… Use Global State When:
-+- State needs to be accessed by multiple components across different parts of the app
-+- State needs to persist between route changes
-+- State changes in one component need to trigger updates in other components
-+- You find yourself prop drilling (passing props through 3+ levels of components)
-+- State represents app-wide settings or user preferences
-+- The state represents a shared resource (e.g., audio player, notifications)
-+
-+âŒ Keep State Local When:
-+- State is only relevant to a single component or a small component tree
-+- State is temporary or transient (e.g., form inputs before submission)
-+- State represents UI-only concerns contained to a single component (e.g., isHovered, isExpanded)
-+- State is reset when the component unmounts
-+- Performance is critical and the state changes frequently
-+
-+#### Store Organization
-+
-+When adding state to the global Zustand store:
-+
-+1. **Choose the Appropriate Slice**
-+   - Identify which existing slice is most appropriate for your state:
-+     - `uiSlice`: UI-related state (themes, viewport, modals, navigation)
-+     - `userSlice`: User profile, authentication, preferences
-+     - `gameSlice`: Game mechanics, progress, scores
-+     - `audioSlice`: Sound effects, music, audio settings
-+     - `vocabSlice`: Vocabulary and content data
-+
-+2. **Create New Slices Sparingly**
-+   - Only create a new slice if the state represents an entirely new domain
-+   - Get approval before creating new slices to maintain architecture coherence
-+
-+3. **Slice Placement Guidelines**:
-+   ```typescript
-+   // UI State (uiSlice.ts)
-+   - Theme settings
-+   - Responsive layout information
-+   - Modal/drawer open states
-+   - Navigation state
-+   - Toast notifications
-+   
-+   // User State (userSlice.ts)
-+   - User profile/authentication
-+   - User preferences
-+   - Study settings
-+   - Progress tracking
-+   - Subscription status
-+   
-+   // Game State (gameSlice.ts)
-+   - Active game session data
-+   - Scores and statistics
-+   - Game progression
-+   - Game mechanics state
-+   
-+   // Audio State (audioSlice.ts)
-+   - Sound effect states
-+   - Music playback
-+   - Volume settings
-+   - Audio resources
-+   
-+   // Vocab State (vocabSlice.ts)
-+   - Content and vocabulary data
-+   - Learning materials
-+   - Study resources
-+   ```
-+
-+4. **Update Selectors**
-+   - When adding new state, create or update the appropriate selectors in `selectors.ts`
-+   - Consider creating granular selectors for specific use cases to minimize re-renders
-+
-+#### Exception: Store Initialization Components
-+The only exception to this pattern is in components specifically designed for store initialization (e.g., `StoreInitializer.tsx`), where direct access to store actions may be required.
-\ No newline at end of file
-diff --git a/store/index.ts b/store/index.ts
-index bf1e9e6743b34f074104a4c04974983ccea88a60..8e8adb1872c497be8b2031834636aa3a762928ef 100644
---- a/store/index.ts
-+++ b/store/index.ts
-@@ -2,6 +2,8 @@
- export { useAudioStore } from './slices/audioSlice';
- export { useUIStore } from './slices/uiSlice';
- export { useGameStore } from './slices/gameSlice';
-+export { useUserStore } from './slices/userSlice';
-+export { useVocabStore } from './slices/vocabSlice';
- 
- // Re-export all types
- export * from './types';
-@@ -11,29 +13,37 @@ export type { ThemeType, WindowSize } from './slices/uiSlice';
- import { useAudioStore } from './slices/audioSlice';
- import { useUIStore } from './slices/uiSlice';
- import { useGameStore } from './slices/gameSlice';
--import { create } from 'zustand';
-+import { useUserStore } from './slices/userSlice';
-+import { useVocabStore } from './slices/vocabSlice';
- 
- // Flag to track global initialization
- let isStoreInitialized = false;
- 
--// Create a combined store for backward compatibility
--// This will be expanded as we migrate more slices
-+type StoreUpdates = Record<string, any>;
-+
- export const useStore = {
-   getState: () => ({
-     ...useAudioStore.getState(),
-     ...useUIStore.getState(),
-     ...useGameStore.getState(),
-+    ...useUserStore.getState(),
-+    ...useVocabStore.getState(),
-   }),
--  setState: (updates: any) => {
-+  
-+  setState: (updates: StoreUpdates) => {
-     // Determine which slice each update belongs to and apply accordingly
-     const audioKeys = new Set(Object.keys(useAudioStore.getState()));
-     const uiKeys = new Set(Object.keys(useUIStore.getState()));
-     const gameKeys = new Set(Object.keys(useGameStore.getState()));
-+    const userKeys = new Set(Object.keys(useUserStore.getState()));
-+    const vocabKeys = new Set(Object.keys(useVocabStore.getState()));
-     
-     // Extract updates for each slice
--    const audioUpdates: Record<string, any> = {};
--    const uiUpdates: Record<string, any> = {};
--    const gameUpdates: Record<string, any> = {};
-+    const audioUpdates: StoreUpdates = {};
-+    const uiUpdates: StoreUpdates = {};
-+    const gameUpdates: StoreUpdates = {};
-+    const userUpdates: StoreUpdates = {};
-+    const vocabUpdates: StoreUpdates = {};
-     
-     // Sort updates into appropriate slices
-     Object.entries(updates).forEach(([key, value]) => {
-@@ -43,6 +53,10 @@ export const useStore = {
-         uiUpdates[key] = value;
-       } else if (gameKeys.has(key)) {
-         gameUpdates[key] = value;
-+      } else if (userKeys.has(key)) {
-+        userUpdates[key] = value;
-+      } else if (vocabKeys.has(key)) {
-+        vocabUpdates[key] = value;
-       }
-     });
-     
-@@ -56,27 +70,39 @@ export const useStore = {
-     if (Object.keys(gameUpdates).length > 0) {
-       useGameStore.setState(gameUpdates);
-     }
-+    if (Object.keys(userUpdates).length > 0) {
-+      useUserStore.setState(userUpdates);
-+    }
-+    if (Object.keys(vocabUpdates).length > 0) {
-+      useVocabStore.setState(vocabUpdates);
-+    }
-   },
-+  
-   subscribe: (callback: (state: any, prevState: any) => void) => {
-     // Subscribe to all slice stores
-     const unsubAudio = useAudioStore.subscribe(callback);
-     const unsubUI = useUIStore.subscribe(callback);
-     const unsubGame = useGameStore.subscribe(callback);
-+    const unsubUser = useUserStore.subscribe(callback);
-+    const unsubVocab = useVocabStore.subscribe(callback);
-     
-     // Return a function to unsubscribe from all
-     return () => {
-       unsubAudio();
-       unsubUI();
-       unsubGame();
-+      unsubUser();
-+      unsubVocab();
-     };
-   }
- };
- 
- // Export a function to initialize the store at the app level
--export const initializeGlobalStore = async () => {
-+export const initializeGlobalStore = async (options?: { forceOnboarding?: boolean }): Promise<void> => {
-   if (typeof window !== 'undefined' && !isStoreInitialized) {
-     console.debug('[DEBUG][Store] Initializing global store from exported function');
-     try {
-+      // Initialize audio context
-       await useAudioStore.getState().initializeAudioContext();
-       
-       // Initialize UI state
-@@ -85,10 +111,17 @@ export const initializeGlobalStore = async () => {
-         useUIStore.getState().setTheme(savedTheme as any);
-       }
-       
-+      // Process debug options
-+      if (options?.forceOnboarding) {
-+        console.debug('[DEBUG][Store] DEBUG MODE: Forcing onboardingComplete to true for testing');
-+        useUserStore.getState().setOnboardingComplete(true);
-+      }
-+      
-       isStoreInitialized = true;
-       console.debug('[DEBUG][Store] Store initialization complete');
-     } catch (error) {
-       console.error('[DEBUG][Store] Store initialization failed:', error);
-+      throw error;
-     }
-   }
- }; 
-\ No newline at end of file
-diff --git a/store/selectors.ts b/store/selectors.ts
-index 41348a50142d8d1425258f5e589a7b541803cd35..fbeb875883ff68209558b34ea6f41890f0da7ae5 100644
---- a/store/selectors.ts
-+++ b/store/selectors.ts
-@@ -1,8 +1,9 @@
--import { useStore } from './store'
- import { useEffect, useCallback, useRef } from 'react'
- import { useAudioStore } from './slices/audioSlice'
- import { useUIStore } from './slices/uiSlice'
- import { useGameStore } from './slices/gameSlice'
-+import { useUserStore } from './slices/userSlice'
-+import { useVocabStore } from './slices/vocabSlice'
- 
- /* --- UI Selectors ---- */
- export const useUI = () => {
-@@ -23,7 +24,6 @@ export const useUI = () => {
-   }
- }
- 
--// Individual property selectors for performance
- export const useTheme = () => useUIStore(state => state.theme)
- export const useWindowSize = () => useUIStore(state => state.window)
- export const useCurrentRoute = () => useUIStore(state => state.currentRoute)
-@@ -32,44 +32,40 @@ export const useCurrentRoute = () => useUIStore(state => state.currentRoute)
- // Consolidated user selector that provides all user-related state and actions
- export const useUser = () => {
-   // Profile state and actions
--  const profile = useStore((state) => state.profile)
--  const profileLoading = useStore((state) => state.profileLoading)
--  const updateProfile = useStore((state) => state.updateProfile)
--  const isProfileComplete = useStore((state) => state.isProfileComplete)
--  const completedSteps = useStore((state) => state.completedSteps)
--  const studyPreferences = useStore((state) => state.studyPreferences)
--  const interfaceSettings = useStore((state) => state.interfaceSettings)
--  const tutorialProgress = useStore((state) => state.tutorialProgress)
--  const onboardingComplete = useStore((state) => state.onboardingComplete)
--  const lastVisitedRoute = useStore((state) => state.lastVisitedRoute)
--  const onboardingRoute = useStore((state) => state.onboardingRoute)
-+  const profile = useUserStore((state) => state.profile)
-+  const profileLoading = useUserStore((state) => state.profileLoading)
-+  const updateProfile = useUserStore((state) => state.updateProfile)
-+  const isProfileComplete = useUserStore((state) => state.isProfileComplete)
-+  const completedSteps = useUserStore((state) => state.completedSteps)
-+  const studyPreferences = useUserStore((state) => state.studyPreferences)
-+  const interfaceSettings = useUserStore((state) => state.interfaceSettings)
-+  const tutorialProgress = useUserStore((state) => state.tutorialProgress)
-+  const onboardingComplete = useUserStore((state) => state.onboardingComplete)
-+  const lastVisitedRoute = useUserStore((state) => state.lastVisitedRoute)
-   
-   // Profile actions
--  const setCompletedSteps = useStore((state) => state.setCompletedSteps)
--  const addCompletedStep = useStore((state) => state.addCompletedStep)
--  const updateStudyPreferences = useStore((state) => state.updateStudyPreferences)
--  const updateInterfaceSettings = useStore((state) => state.updateInterfaceSettings)
--  const updateTutorialProgress = useStore((state) => state.updateTutorialProgress)
--  const setOnboardingComplete = useStore((state) => state.setOnboardingComplete)
--  const setLastVisitedRoute = useStore((state) => state.setLastVisitedRoute)
--  const setOnboardingRoute = useStore((state) => state.setOnboardingRoute)
-+  const setCompletedSteps = useUserStore((state) => state.setCompletedSteps)
-+  const addCompletedStep = useUserStore((state) => state.addCompletedStep)
-+  const updateStudyPreferences = useUserStore((state) => state.updateStudyPreferences)
-+  const updateInterfaceSettings = useUserStore((state) => state.updateInterfaceSettings)
-+  const updateTutorialProgress = useUserStore((state) => state.updateTutorialProgress)
-+  const setOnboardingComplete = useUserStore((state) => state.setOnboardingComplete)
-+  const setLastVisitedRoute = useUserStore((state) => state.setLastVisitedRoute)
-   
-   // User info state and actions
--  const userInfo = useStore((state) => state.userInfo)
--  const isSubscribed = useStore((state) => state.isSubscribed)
--  const setIsSubscribed = useStore((state) => state.setIsSubscribed)
-+  const userInfo = useUserStore((state) => state.userInfo)
-+  const isSubscribed = useUserStore((state) => state.isSubscribed)
-+  const setIsSubscribed = useUserStore((state) => state.setIsSubscribed)
-   
-   // User stats state and actions
--  const coins = useStore((state) => state.coins)
--  const statsLoading = useStore((state) => state.statsLoading)
--  const updateCoins = useStore((state) => state.updateCoins)
--  const updateCoinsDisplay = useStore((state) => state.updateCoinsDisplay)
--  
--  // Shared actions
--  const refreshUserInfo = useStore((state) => state.refreshUserInfo)
--  
-+  const coins = useUserStore((state) => state.coins)
-+  const statsLoading = useUserStore((state) => state.statsLoading)
-+  const updateCoins = useUserStore((state) => state.updateCoins)
-+  const updateCoinsDisplay = useUserStore((state) => state.updateCoinsDisplay)
-+  const refreshUserInfo = useUserStore((state) => state.refreshUserInfo)
-+
-   return {
--    // Profile state and actions
-+    // Profile state
-     profile,
-     profileLoading,
-     updateProfile,
-@@ -80,7 +76,6 @@ export const useUser = () => {
-     tutorialProgress,
-     onboardingComplete,
-     lastVisitedRoute,
--    onboardingRoute,
-     
-     // Profile actions
-     setCompletedSteps,
-@@ -90,20 +85,17 @@ export const useUser = () => {
-     updateTutorialProgress,
-     setOnboardingComplete,
-     setLastVisitedRoute,
--    setOnboardingRoute,
-     
--    // User info state and actions
-+    // User info
-     userInfo,
-     isSubscribed,
-     setIsSubscribed,
-     
--    // User stats state and actions
-+    // Stats
-     coins,
-     statsLoading,
-     updateCoins,
-     updateCoinsDisplay,
--    
--    // Shared actions
-     refreshUserInfo,
-   }
- }
-@@ -192,18 +184,6 @@ export const useGame = () => {
-   }
- }
- 
--/* --- Individual Profile Selectors ---- */
--// For components that only need specific profile data
--export const useProfileComplete = () => useStore(state => state.isProfileComplete)
--export const useCompletedSteps = () => useStore(state => state.completedSteps)
--export const useStudyPreferences = () => useStore(state => state.studyPreferences)
--export const useInterfaceSettings = () => useStore(state => state.interfaceSettings)
--export const useTutorialProgress = () => useStore(state => state.tutorialProgress)
--export const useOnboardingStatus = () => ({
--  onboardingComplete: useStore(state => state.onboardingComplete),
--  lastVisitedRoute: useStore(state => state.lastVisitedRoute),
--  onboardingRoute: useStore(state => state.onboardingRoute)
--})
- 
- /* --- Audio Selector ---- */
- // Consolidated audio selector that provides all audio-related state and actions
-@@ -324,15 +304,15 @@ export const useAudio = () => {
- // Consolidated vocab selector that provides all vocabulary-related state and actions
- export const useVocab = () => {
-   // Vocab state
--  const vocabList = useStore((state) => state.vocabList)
--  const showVocabList = useStore((state) => state.showVocabList)
--  const isCmdIEnabled = useStore((state) => state.isCmdIEnabled)
-+  const vocabList = useVocabStore((state) => state.vocabList)
-+  const showVocabList = useVocabStore((state) => state.showVocabList)
-+  const isCmdIEnabled = useVocabStore((state) => state.isCmdIEnabled)
-   
-   // Vocab actions
--  const addVocabWord = useStore((state) => state.addVocabWord)
--  const removeVocabWord = useStore((state) => state.removeVocabWord)
--  const toggleVocabList = useStore((state) => state.toggleVocabList)
--  const toggleCmdI = useStore((state) => state.toggleCmdI)
-+  const addVocabWord = useVocabStore((state) => state.addVocabWord)
-+  const removeVocabWord = useVocabStore((state) => state.removeVocabWord)
-+  const toggleVocabList = useVocabStore((state) => state.toggleVocabList)
-+  const toggleCmdI = useVocabStore((state) => state.toggleCmdI)
-   
-   return {
-     // State
-@@ -349,9 +329,10 @@ export const useVocab = () => {
- }
- 
- // Individual property selectors for performance
--export const useVocabList = () => useStore(state => state.vocabList)
--export const useShowVocabList = () => useStore(state => state.showVocabList)
--export const useIsCmdIEnabled = () => useStore(state => state.isCmdIEnabled)
-+// Commented out as they're currently unused in the codebase
-+// export const useVocabList = () => useVocabStore(state => state.vocabList)
-+// export const useShowVocabList = () => useVocabStore(state => state.showVocabList)
-+// export const useIsCmdIEnabled = () => useVocabStore(state => state.isCmdIEnabled)
- 
- /* --- Clinic Data Management ---- */
- export const useClinicData = () => {
-diff --git a/store/slices/audioSlice.ts b/store/slices/audioSlice.ts
-index ece5e87c2103ea91964699a35559ebcd95964ca3..9703fe72c5ce1b23264dc16be0ce5265620ac2e5 100644
---- a/store/slices/audioSlice.ts
-+++ b/store/slices/audioSlice.ts
-@@ -48,6 +48,9 @@ interface AudioState {
-   // Track loading state to prevent duplicate playback
-   _isLoopLoading: boolean;
-   _pendingLoopName: string | null;
-+  // Debouncing for sounds
-+  _lastPlayedSounds: Record<string, number>;
-+  _soundDebounceTime: number;
- }
- 
- interface AudioActions {
-@@ -134,6 +137,7 @@ export const useAudioStore = create<AudioState & AudioActions>()(
-       'notification': 'notification',
-       'cardFlip': 'cardFlip',
-       'levelUp': 'levelUp',
-+      'levelup': 'levelUp', // Adding alias with lowercase for consistency
-       'coin': 'coin',
-       'achievement': 'achievement',
-       'flashcard-startup': 'flashcard-startup',
-@@ -141,12 +145,24 @@ export const useAudioStore = create<AudioState & AudioActions>()(
-       'flashcard-select': 'flashcard-select',
-       'correct': 'correct',
-       'whoosh': 'whoosh',
-+      'fanfare': 'fanfare',
-+      'sadfanfare': 'sadfanfare', // Map to actual file now instead of fallback
-+      'beep-tone': 'beep-tone',
-+      'chatbot-open': 'chatbot-open',
-+      'short-choir': 'short-choir',
-+      'streakdaily': 'streakdaily',
-+      'streakmonth': 'streakmonth',
-+      'warning': 'warning',
-     },
- 
-     // Initialize new properties for loop loading state
-     _isLoopLoading: false,
-     _pendingLoopName: null,
- 
-+    // Store last played sound with timestamp to prevent multiple rapid plays
-+    _lastPlayedSounds: {} as Record<string, number>,
-+    _soundDebounceTime: 3000, // Increased to 3 seconds (3000ms) from 1000ms
-+
-     // Set song queue
-     setSongQueue: (queue) => {
-       const state = get();
-@@ -643,14 +659,47 @@ export const useAudioStore = create<AudioState & AudioActions>()(
-     playSound: async (sfxName) => {
-       console.log(`[AudioSlice] Attempting to play sound effect: ${sfxName}`);
-       const state = get();
-+      
-+      // Prevent rapid repeated plays of the same sound
-+      const now = Date.now();
-+      const lastPlayed = state._lastPlayedSounds[sfxName] || 0;
-+      if (now - lastPlayed < state._soundDebounceTime) {
-+        console.log(`[AudioSlice] Skipping sound "${sfxName}" - played too recently (${now - lastPlayed}ms ago)`);
-+        return Promise.resolve(); // Return resolved promise to avoid the async chain continuing
-+      }
-+      
-+      // Update last played timestamp IMMEDIATELY before any async operations
-+      // This prevents multiple calls while the first one is still initializing
-+      set({ 
-+        _lastPlayedSounds: { 
-+          ...state._lastPlayedSounds, 
-+          [sfxName]: now 
-+        } 
-+      });
-+      
-+      // Check if this is a duplicate call within 10ms (additional protection)
-+      const callTime = now;
-+      console.log(`[AudioSlice] Sound ${sfxName} - Processing started at ${callTime}`);
-+      
-       if (!state.audioContext) {
-         console.log(`[AudioSlice] Audio context not initialized for sound: ${sfxName}, initializing now...`);
-         await get().initializeAudioContext();
-       }
-       
--      const sfxPath = state._SOUND_MAPPINGS[sfxName];
-+      // Try exact name first, then try lowercase version for case-insensitive match
-+      let sfxPath = state._SOUND_MAPPINGS[sfxName];
-+      if (!sfxPath && typeof sfxName === 'string') {
-+        // Try lowercase version
-+        const lcName = sfxName.toLowerCase();
-+        sfxPath = state._SOUND_MAPPINGS[lcName];
-+        if (sfxPath) {
-+          console.log(`[AudioSlice] Found sound using case-insensitive match: ${lcName}`);
-+        }
-+      }
-+      
-       if (!sfxPath) {
-         console.error(`[AudioSlice] Sound effect not found in mappings: ${sfxName}`);
-+        console.log(`[AudioSlice] Available sounds: ${Object.keys(state._SOUND_MAPPINGS).join(', ')}`);
-         return;
-       }
- 
-diff --git a/store/slices/userSlice.ts b/store/slices/userSlice.ts
-index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0fff0cfe0fc6c71d45167edf52b37444bcfce379 100644
---- a/store/slices/userSlice.ts
-+++ b/store/slices/userSlice.ts
-@@ -0,0 +1,747 @@
-+import { create } from 'zustand';
-+import { devtools } from 'zustand/middleware';
-+import { UserInfo } from '@/types/user';
-+
-+//========================= Helpers ===============================
-+// Helper function to check if a date is within 14 days of now
-+const isWithin14Days = (date: Date): boolean => {
-+  const now = new Date();
-+  const diffTime = Math.abs(now.getTime() - date.getTime());
-+  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
-+  return diffDays <= 14;
-+};
-+
-+//========================= Types ===============================
-+interface UserProfile {
-+  userId?: string;
-+  firstName?: string;
-+  bio?: string;
-+  coins?: number;
-+  patientsCount?: number;
-+  profilePhoto?: string;
-+  studyPreferences?: {
-+    dailyGoal?: number;
-+    reminderTime?: string;
-+  };
-+  interfaceSettings?: {
-+    darkMode?: boolean;
-+    fontSize?: string;
-+  };
-+  tutorialProgress?: {
-+    currentStep?: number;
-+    completedRoutes?: string[];
-+  };
-+  completedSteps?: string[];
-+  onboardingComplete?: boolean;
-+  lastVisitedRoute?: string;
-+}
-+
-+interface UserState {
-+  // Version tracking
-+  version: number;
-+  isHydrated: boolean;
-+  
-+  // Profile state
-+  profile: UserProfile | null;
-+  profileLoading: boolean;
-+  isProfileComplete: boolean;
-+  completedSteps: string[];
-+  studyPreferences: {
-+    dailyGoal: number;
-+    reminderTime: string;
-+  };
-+  interfaceSettings: {
-+    darkMode: boolean;
-+    fontSize: string;
-+  };
-+  tutorialProgress: {
-+    currentStep: number;
-+    completedRoutes: string[];
-+  };
-+  onboardingComplete: boolean;
-+  lastVisitedRoute: string;
-+  
-+  // User info state
-+  userInfo: UserInfo | null;
-+  isSubscribed: boolean;
-+  
-+  // Stats state
-+  coins: number;
-+  statsLoading: boolean;
-+  error: string | null;
-+}
-+
-+interface UserActions {
-+  // Profile actions
-+  updateProfile: (updates: any) => Promise<void>;
-+  setCompletedSteps: (steps: string[]) => void;
-+  addCompletedStep: (step: string) => void;
-+  
-+  // Preferences actions
-+  updateStudyPreferences: (preferences: Partial<UserState['studyPreferences']>) => void;
-+  updateInterfaceSettings: (settings: Partial<UserState['interfaceSettings']>) => void;
-+  updateTutorialProgress: (progress: Partial<UserState['tutorialProgress']>) => void;
-+  
-+  // Onboarding actions
-+  setOnboardingComplete: (completed: boolean) => void;
-+  setLastVisitedRoute: (route: string) => void;
-+  
-+  // User info actions
-+  refreshUserInfo: () => Promise<void>;
-+  setIsSubscribed: (status: boolean) => void;
-+  
-+  // Stats actions
-+  updateCoins: (amount: number) => Promise<void>;
-+  updateCoinsDisplay: (newAmount: number) => void;
-+}
-+
-+interface OnboardingInfo {
-+  currentStep: number;
-+  startedAt: string;
-+  lastUpdated: string;
-+  onboardingComplete: boolean;
-+  firstName: string | null;
-+  targetScore: number | null;
-+  college: string | null;
-+  year: string | null;
-+  referralSource: string | null;
-+}
-+
-+//========================= Store Creation ===============================
-+export const useUserStore = create<UserState & UserActions>()(
-+  devtools((set, get) => ({
-+    // Version tracking
-+    version: 1,
-+    isHydrated: false,
-+    
-+    // Profile state
-+    profile: null,
-+    profileLoading: true,
-+    isProfileComplete: false,
-+    completedSteps: [],
-+    studyPreferences: {
-+      dailyGoal: 30,
-+      reminderTime: '09:00'
-+    },
-+    interfaceSettings: {
-+      darkMode: false,
-+      fontSize: 'medium'
-+    },
-+    tutorialProgress: {
-+      currentStep: 0,
-+      completedRoutes: []
-+    },
-+    onboardingComplete: false,
-+    lastVisitedRoute: '/',
-+    
-+    // User info state
-+    userInfo: null,
-+    isSubscribed: false,
-+    
-+    // Stats state
-+    coins: 0,
-+    statsLoading: false,
-+    error: null,
-+    
-+    // Profile actions
-+    updateProfile: async (updates) => {
-+      try {
-+        // Get the current profile and email/userId for the API call
-+        const userInfo = get().userInfo;
-+        
-+        if (!userInfo || (!userInfo.email && !userInfo.userId)) {
-+          console.error('Cannot update profile: No user email or ID available');
-+          return;
-+        }
-+        
-+        // Validate updates
-+        const currentProfile = get().profile;
-+        const updatedProfile = { ...currentProfile, ...updates };
-+        const validation = validateProfile(updatedProfile);
-+        
-+        if (!validation.isValid) {
-+          console.error('Invalid profile updates:', validation.errors);
-+          set({
-+            error: validation.errors.join('. '),
-+            profileLoading: false
-+          });
-+          return;
-+        }
-+        
-+        // Determine which query param to use
-+        const queryParam = userInfo.email 
-+          ? `email=${encodeURIComponent(userInfo.email)}`
-+          : `userId=${userInfo.userId}`;
-+        
-+        set({ profileLoading: true, error: null });
-+        
-+        // Send update to API
-+        const response = await fetch(`/api/user-info/profile?${queryParam}`, {
-+          method: 'PATCH',
-+          headers: { 'Content-Type': 'application/json' },
-+          body: JSON.stringify(updates)
-+        });
-+        
-+        if (!response.ok) {
-+          throw new Error('Failed to update profile');
-+        }
-+        
-+        const updatedProfileFromServer = await response.json();
-+        
-+        // Update local state with server response
-+        set({
-+          profile: updatedProfileFromServer,
-+          profileLoading: false,
-+          error: null,
-+          ...(updatedProfileFromServer.completedSteps && { completedSteps: updatedProfileFromServer.completedSteps }),
-+          ...(updatedProfileFromServer.studyPreferences && { studyPreferences: updatedProfileFromServer.studyPreferences }),
-+          ...(updatedProfileFromServer.interfaceSettings && { interfaceSettings: updatedProfileFromServer.interfaceSettings }),
-+          ...(updatedProfileFromServer.tutorialProgress && { tutorialProgress: updatedProfileFromServer.tutorialProgress }),
-+          ...(updatedProfileFromServer.onboardingComplete !== undefined && { onboardingComplete: updatedProfileFromServer.onboardingComplete }),
-+          ...(updatedProfileFromServer.lastVisitedRoute && { lastVisitedRoute: updatedProfileFromServer.lastVisitedRoute }),
-+          isProfileComplete: isProfileComplete(updatedProfileFromServer)
-+        });
-+      } catch (error) {
-+        console.error('Failed to update profile:', error);
-+        set({
-+          profileLoading: false,
-+          error: error instanceof Error ? error.message : 'Failed to update profile'
-+        });
-+      }
-+    },
-+    
-+    setCompletedSteps: (steps) => {
-+      set({ completedSteps: steps });
-+      set({ isProfileComplete: steps.length >= 3 });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, completedSteps: steps } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ completedSteps: steps });
-+    },
-+    
-+    addCompletedStep: (step) => {
-+      const currentSteps = get().completedSteps;
-+      if (!currentSteps.includes(step)) {
-+        const newSteps = [...currentSteps, step];
-+        set({ completedSteps: newSteps });
-+        set({ isProfileComplete: newSteps.length >= 3 });
-+        
-+        // Also update the profile object for consistency
-+        const profile = get().profile;
-+        if (profile) {
-+          set({ profile: { ...profile, completedSteps: newSteps } });
-+        }
-+        
-+        // Persist to backend if possible
-+        get().updateProfile({ completedSteps: newSteps });
-+      }
-+    },
-+    
-+    updateStudyPreferences: (preferences) => {
-+      const currentPreferences = get().studyPreferences;
-+      const updatedPreferences = { ...currentPreferences, ...preferences };
-+      set({ studyPreferences: updatedPreferences });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, studyPreferences: updatedPreferences } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ studyPreferences: updatedPreferences });
-+    },
-+    
-+    updateInterfaceSettings: (settings) => {
-+      const currentSettings = get().interfaceSettings;
-+      const updatedSettings = { ...currentSettings, ...settings };
-+      set({ interfaceSettings: updatedSettings });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, interfaceSettings: updatedSettings } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ interfaceSettings: updatedSettings });
-+    },
-+    
-+    updateTutorialProgress: (progress) => {
-+      const currentProgress = get().tutorialProgress;
-+      const updatedProgress = { ...currentProgress, ...progress };
-+      set({ tutorialProgress: updatedProgress });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, tutorialProgress: updatedProgress } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ tutorialProgress: updatedProgress });
-+    },
-+    
-+    setOnboardingComplete: (completed) => {
-+      set({ onboardingComplete: completed });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, onboardingComplete: completed } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ onboardingComplete: completed });
-+    },
-+    
-+    setLastVisitedRoute: (route) => {
-+      set({ lastVisitedRoute: route });
-+      
-+      // Also update the profile object for consistency
-+      const profile = get().profile;
-+      if (profile) {
-+        set({ profile: { ...profile, lastVisitedRoute: route } });
-+      }
-+      
-+      // Persist to backend if possible
-+      get().updateProfile({ lastVisitedRoute: route });
-+    },
-+    
-+    refreshUserInfo: async () => {
-+      try {
-+        // Only set loading if not already loading
-+        const currentState = get();
-+        if (!currentState.statsLoading && !currentState.profileLoading) {
-+          set({ statsLoading: true, profileLoading: true, error: null });
-+        }
-+
-+        // Add loading timeout
-+        const loadingTimeout = setTimeout(() => {
-+          const state = get();
-+          if (state.statsLoading || state.profileLoading) {
-+            set({ 
-+              statsLoading: false,
-+              profileLoading: false,
-+              error: 'Loading timeout - please try again'
-+            });
-+          }
-+        }, 10000);
-+
-+        // Batch all fetch requests together
-+        const [userInfoResponse, profileResponse] = await Promise.all([
-+          fetch('/api/user-info'),
-+          fetch('/api/user-info/profile')
-+        ]);
-+
-+        clearTimeout(loadingTimeout);
-+
-+        if (!userInfoResponse.ok) throw new Error('Failed to fetch user info');
-+        const userInfo = await userInfoResponse.json();
-+        
-+        // Check if user is in 14-day free trial period
-+        const isNewUserTrial = userInfo.createdAt ? isWithin14Days(new Date(userInfo.createdAt)) : false;
-+
-+        // Prepare single state update with only changed values
-+        const updates: Partial<UserState> = {
-+          userInfo,
-+          statsLoading: false,
-+          profileLoading: false,
-+          error: null,
-+          isHydrated: true,
-+          version: CURRENT_VERSION
-+        };
-+
-+        // Only update coins if changed
-+        if (userInfo.score !== get().coins) {
-+          updates.coins = userInfo.score || 0;
-+        }
-+
-+        // Only update subscription if changed
-+        const newSubStatus = 
-+          userInfo.subscriptionType === 'gold' || 
-+          userInfo.subscriptionType === 'premium' ||
-+          userInfo.subscriptionType?.startsWith('Gold') ||
-+          userInfo.subscriptionType?.includes('_Trial') || 
-+          isNewUserTrial || 
-+          false;
-+          
-+        if (newSubStatus !== get().isSubscribed) {
-+          updates.isSubscribed = newSubStatus;
-+        }
-+
-+        if (profileResponse.ok) {
-+          const profileData = await profileResponse.json();
-+          const currentProfile = get().profile;
-+          
-+          // Only update profile fields that have changed
-+          if (JSON.stringify(currentProfile) !== JSON.stringify(profileData)) {
-+            Object.assign(updates, {
-+              profile: profileData,
-+              completedSteps: profileData.completedSteps || [],
-+              studyPreferences: profileData.studyPreferences || {
-+                dailyGoal: 30,
-+                reminderTime: '09:00'
-+              },
-+              interfaceSettings: profileData.interfaceSettings || {
-+                darkMode: false,
-+                fontSize: 'medium'
-+              },
-+              tutorialProgress: profileData.tutorialProgress || {
-+                currentStep: 0,
-+                completedRoutes: []
-+              },
-+              lastVisitedRoute: profileData.lastVisitedRoute || '/',
-+              isProfileComplete: (profileData.completedSteps || []).length >= 3
-+            });
-+          }
-+        }
-+
-+        // Apply all updates in a single state update
-+        set(updates);
-+
-+      } catch (error) {
-+        console.error('Error in refreshUserInfo:', error);
-+        set({ 
-+          error: error instanceof Error ? error.message : 'Failed to refresh user info',
-+          statsLoading: false,
-+          profileLoading: false,
-+          isHydrated: false
-+        });
-+      }
-+    },
-+    
-+    setIsSubscribed: (status) => {
-+      set({ isSubscribed: status });
-+    },
-+    
-+    updateCoins: async (amount) => {
-+      try {
-+        const response = await fetch('/api/user/score', {
-+          method: 'POST',
-+          headers: { 'Content-Type': 'application/json' },
-+          body: JSON.stringify({ amount })
-+        });
-+        
-+        if (!response.ok) throw new Error('Failed to update coins');
-+        
-+        await get().refreshUserInfo();
-+      } catch (error) {
-+        console.error('Failed to update coins:', error);
-+      }
-+    },
-+    
-+    updateCoinsDisplay: (newAmount) => {
-+      set({ coins: newAmount });
-+    }
-+  }))
-+);
-+
-+interface ValidationResult {
-+  isValid: boolean;
-+  missingFields: string[];
-+  invalidFields: string[];
-+  errors: string[];
-+}
-+
-+// Constants for validation
-+const ONBOARDING_STEPS = {
-+  NAME: 1,
-+  COLLEGE: 2,
-+  ACADEMICS: 3,
-+  GOALS: 4,
-+  KALYPSO_DIALOGUE: 5,
-+  REFERRAL: 6,
-+  UNLOCK: 7
-+} as const;
-+
-+const REQUIRED_STEPS = 3; // Minimum number of steps required for profile completion
-+
-+type OnboardingStep = typeof ONBOARDING_STEPS[keyof typeof ONBOARDING_STEPS];
-+
-+interface StepDependency {
-+  step: OnboardingStep;
-+  requires: OnboardingStep[];
-+  validates: (info: OnboardingInfo) => boolean;
-+}
-+
-+const STEP_DEPENDENCIES: Record<OnboardingStep, StepDependency> = {
-+  [ONBOARDING_STEPS.NAME]: {
-+    step: ONBOARDING_STEPS.NAME,
-+    requires: [],
-+    validates: (info) => !!info.firstName
-+  },
-+  [ONBOARDING_STEPS.COLLEGE]: {
-+    step: ONBOARDING_STEPS.COLLEGE,
-+    requires: [ONBOARDING_STEPS.NAME],
-+    validates: (info) => !!info.college
-+  },
-+  [ONBOARDING_STEPS.ACADEMICS]: {
-+    step: ONBOARDING_STEPS.ACADEMICS,
-+    requires: [ONBOARDING_STEPS.COLLEGE],
-+    validates: (info) => !!info.year
-+  },
-+  [ONBOARDING_STEPS.GOALS]: {
-+    step: ONBOARDING_STEPS.GOALS,
-+    requires: [ONBOARDING_STEPS.ACADEMICS],
-+    validates: (info) => typeof info.targetScore === 'number' && info.targetScore > 0
-+  },
-+  [ONBOARDING_STEPS.KALYPSO_DIALOGUE]: {
-+    step: ONBOARDING_STEPS.KALYPSO_DIALOGUE,
-+    requires: [ONBOARDING_STEPS.GOALS],
-+    validates: () => true // Dialogue completion is tracked separately
-+  },
-+  [ONBOARDING_STEPS.REFERRAL]: {
-+    step: ONBOARDING_STEPS.REFERRAL,
-+    requires: [ONBOARDING_STEPS.KALYPSO_DIALOGUE],
-+    validates: () => true // Optional step
-+  },
-+  [ONBOARDING_STEPS.UNLOCK]: {
-+    step: ONBOARDING_STEPS.UNLOCK,
-+    requires: [ONBOARDING_STEPS.KALYPSO_DIALOGUE],
-+    validates: (info) => {
-+      const requiredFields = [
-+        'firstName',
-+        'college',
-+        'year',
-+        'targetScore'
-+      ];
-+      return requiredFields.every(field => !!info[field as keyof OnboardingInfo]);
-+    }
-+  }
-+};
-+
-+// Cache for onboarding completion status
-+let cachedOnboardingStatus: { userId: string; isComplete: boolean } | null = null;
-+
-+// Validation function for onboarding state
-+const validateOnboardingState = (userInfo: UserInfo, profile: UserProfile | null): boolean => {
-+  // Check if we have all required data
-+  if (!userInfo || !userInfo.onboardingInfo || !profile) {
-+    return false;
-+  }
-+
-+  const { currentStep } = userInfo.onboardingInfo;
-+  
-+  // Check if all steps are completed
-+  const hasCompletedAllSteps = (currentStep ?? 0) >= ONBOARDING_STEPS.UNLOCK;
-+  if (!hasCompletedAllSteps) return false;
-+  
-+  // Validate all step dependencies
-+  for (const stepNum of Object.values(ONBOARDING_STEPS)) {
-+    const dependency = STEP_DEPENDENCIES[stepNum];
-+    if (!dependency.validates(userInfo.onboardingInfo)) {
-+      return false;
-+    }
-+  }
-+
-+  // Check profile completion
-+  const hasValidProfile = isProfileComplete(profile);
-+
-+  return hasValidProfile;
-+};
-+
-+// Async onboarding completion check with caching
-+const isOnboardingComplete = async (userId: string): Promise<boolean> => {
-+  // Check cache first
-+  if (cachedOnboardingStatus?.userId === userId) {
-+    return cachedOnboardingStatus.isComplete;
-+  }
-+  
-+  try {
-+    // Fetch latest user info
-+    const response = await fetch('/api/user-info');
-+    if (!response.ok) throw new Error('Failed to fetch user info');
-+    
-+    const userInfo = await response.json();
-+    const profileResponse = await fetch('/api/user-info/profile');
-+    const profile = profileResponse.ok ? await profileResponse.json() : null;
-+    
-+    // Determine completion status
-+    const isComplete = validateOnboardingState(userInfo, profile);
-+    
-+    // Update cache
-+    cachedOnboardingStatus = { userId, isComplete };
-+    
-+    return isComplete;
-+  } catch (error) {
-+    console.error('Error checking onboarding completion:', error);
-+    return false;
-+  }
-+};
-+
-+// Profile validation functions
-+const validateProfile = (profile: UserProfile): ValidationResult => {
-+  const missingFields: string[] = [];
-+  const invalidFields: string[] = [];
-+  
-+  // Check required fields
-+  if (!profile.firstName) missingFields.push('firstName');
-+  if (!profile.completedSteps || profile.completedSteps.length < REQUIRED_STEPS) {
-+    missingFields.push('completedSteps');
-+  }
-+  
-+  // Validate field types and values
-+  if (profile.coins !== undefined && (typeof profile.coins !== 'number' || profile.coins < 0)) {
-+    invalidFields.push('coins');
-+  }
-+  
-+  // Validate study preferences
-+  if (profile.studyPreferences) {
-+    const { dailyGoal, reminderTime } = profile.studyPreferences;
-+    if (dailyGoal !== undefined && (typeof dailyGoal !== 'number' || dailyGoal < 0)) {
-+      invalidFields.push('studyPreferences.dailyGoal');
-+    }
-+    if (reminderTime && !/^([01]\d|2[0-3]):([0-5]\d)$/.test(reminderTime)) {
-+      invalidFields.push('studyPreferences.reminderTime');
-+    }
-+  }
-+  
-+  // Validate interface settings
-+  if (profile.interfaceSettings) {
-+    const { fontSize } = profile.interfaceSettings;
-+    if (fontSize && !['small', 'medium', 'large'].includes(fontSize)) {
-+      invalidFields.push('interfaceSettings.fontSize');
-+    }
-+  }
-+  
-+  // Generate validation errors
-+  const errors = generateValidationErrors(missingFields, invalidFields);
-+  
-+  return {
-+    isValid: missingFields.length === 0 && invalidFields.length === 0,
-+    missingFields,
-+    invalidFields,
-+    errors
-+  };
-+};
-+
-+const generateValidationErrors = (missing: string[], invalid: string[]): string[] => {
-+  const errors: string[] = [];
-+  if (missing.length > 0) {
-+    errors.push(`Missing required fields: ${missing.join(', ')}`);
-+  }
-+  if (invalid.length > 0) {
-+    errors.push(`Invalid values for fields: ${invalid.join(', ')}`);
-+  }
-+  return errors;
-+};
-+
-+const isProfileComplete = (profile: UserProfile | null): boolean => {
-+  if (!profile) return false;
-+  
-+  const validation = validateProfile(profile);
-+  if (!validation.isValid) return false;
-+  
-+  return (
-+    !!profile.firstName &&
-+    (profile.completedSteps?.length ?? 0) >= REQUIRED_STEPS
-+  );
-+};
-+
-+// State update utility with optimistic updates and rollback
-+const updateState = async (
-+  set: (state: Partial<UserState> | ((state: UserState) => Partial<UserState>)) => void,
-+  get: () => UserState,
-+  updates: Partial<UserState>,
-+  options: { sync?: boolean } = {}
-+) => {
-+  try {
-+    // Store previous state for rollback
-+    const previousState = get();
-+    
-+    // Optimistically update local state
-+    set((state) => ({
-+      ...state,
-+      ...updates,
-+      error: null
-+    }));
-+
-+    // If sync is requested, update database
-+    if (options.sync) {
-+      try {
-+        const response = await fetch('/api/user-info', {
-+          method: 'PATCH',
-+          headers: { 'Content-Type': 'application/json' },
-+          body: JSON.stringify(updates)
-+        });
-+
-+        if (!response.ok) {
-+          throw new Error('Failed to sync with database');
-+        }
-+
-+        // Update local state with server response
-+        const serverState = await response.json();
-+        set((state) => ({
-+          ...state,
-+          ...serverState
-+        }));
-+      } catch (error) {
-+        // Rollback on sync failure
-+        console.error('Sync failed, rolling back:', error);
-+        set(previousState);
-+        throw error;
-+      }
-+    }
-+  } catch (error) {
-+    set((state) => ({
-+      ...state,
-+      error: error instanceof Error ? error.message : 'Update failed'
-+    }));
-+    throw error;
-+  }
-+};
-+
-+// Constants for state management
-+const CURRENT_VERSION = 1;
-+
-+const initialState: UserState = {
-+  // Version tracking
-+  version: CURRENT_VERSION,
-+  isHydrated: false,
-+  
-+  // Profile state
-+  profile: null,
-+  profileLoading: true,
-+  isProfileComplete: false,
-+  completedSteps: [],
-+  studyPreferences: {
-+    dailyGoal: 30,
-+    reminderTime: '09:00'
-+  },
-+  interfaceSettings: {
-+    darkMode: false,
-+    fontSize: 'medium'
-+  },
-+  tutorialProgress: {
-+    currentStep: 0,
-+    completedRoutes: []
-+  },
-+  onboardingComplete: false,
-+  lastVisitedRoute: '/',
-+  
-+  // User info state
-+  userInfo: null,
-+  isSubscribed: false,
-+  
-+  // Stats state
-+  coins: 0,
-+  statsLoading: false,
-+  error: null
-+};
-+
-+// Hydration check utility
-+const isStateHydrated = (state: UserState): boolean => {
-+  return state.isHydrated && state.version === CURRENT_VERSION;
-+};
-+
-+// State reset utility
-+const resetState = (): UserState => ({
-+  ...initialState,
-+  version: CURRENT_VERSION
-+});
-diff --git a/store/slices/vocabSlice.ts b/store/slices/vocabSlice.ts
-new file mode 100644
-index 0000000000000000000000000000000000000000..44f675079306377d3a4e227d12c28a7f9fe5b5a9
---- /dev/null
-+++ b/store/slices/vocabSlice.ts
-@@ -0,0 +1,61 @@
-+import { create } from 'zustand';
-+import { devtools } from 'zustand/middleware';
-+
-+//========================= Types ===============================
-+interface VocabWord {
-+  word: string;
-+  definitions: string;
-+}
-+
-+interface VocabState {
-+  // Vocab state
-+  vocabList: VocabWord[];
-+  showVocabList: boolean;
-+  isCmdIEnabled: boolean;
-+}
-+
-+interface VocabActions {
-+  // Vocab actions
-+  addVocabWord: (word: string, definition: string) => void;
-+  removeVocabWord: (word: string) => void;
-+  toggleVocabList: () => void;
-+  toggleCmdI: () => void;
-+}
-+
-+//========================= Store Creation ===============================
-+export const useVocabStore = create<VocabState & VocabActions>()(
-+  devtools((set, get) => ({
-+    // Vocab state
-+    vocabList: [],
-+    showVocabList: false,
-+    isCmdIEnabled: true,
-+    
-+    // Vocab actions
-+    addVocabWord: (word, definition) => {
-+      set((state) => ({
-+        vocabList: [
-+          ...state.vocabList,
-+          { word, definitions: definition }
-+        ]
-+      }));
-+    },
-+    
-+    removeVocabWord: (word) => {
-+      set((state) => ({
-+        vocabList: state.vocabList.filter((item) => item.word !== word)
-+      }));
-+    },
-+    
-+    toggleVocabList: () => {
-+      set((state) => ({
-+        showVocabList: !state.showVocabList
-+      }));
-+    },
-+    
-+    toggleCmdI: () => {
-+      set((state) => ({
-+        isCmdIEnabled: !state.isCmdIEnabled
-+      }));
-+    },
-+  }))
-+);
-\ No newline at end of file
-diff --git a/store/store.ts b/store/store.ts
-deleted file mode 100644
-index 341f139718b3bbd14f143720b5ace0944d450948..0000000000000000000000000000000000000000
---- a/store/store.ts
-+++ /dev/null
-@@ -1,592 +0,0 @@
--import { create } from 'zustand'
--import { devtools } from 'zustand/middleware'
--import { UserInfo } from '@/types/user'
--import type { DoctorOfficeStats } from '@/types'
--import { toast } from 'react-hot-toast'
--import { isWithin14Days } from '@/lib/utils'
--// Import the audio slice for initialization
--import { useAudioStore } from './slices/audioSlice'
--// Import the UI slice for initialization
--import { useUIStore } from './slices/uiSlice'
--// Import the Game slice for initialization
--import { useGameStore } from './slices/gameSlice'
--
--// Add a flag to track global initialization
--let isStoreInitialized = false;
--
--//***************************************** User Slice ********************************************************//
--//************************* UserProfile, UserInfo, UserStats, User  *******************************************//
--
--interface UserProfile {
--  profile: {
--    userId?: string;
--    firstName?: string;
--    bio?: string;
--    coins?: number;
--    patientsCount?: number;
--    profilePhoto?: string;
--    studyPreferences?: {
--      dailyGoal?: number;
--      reminderTime?: string;
--    };
--    interfaceSettings?: {
--      darkMode?: boolean;
--      fontSize?: string;
--    };
--    tutorialProgress?: {
--      currentStep?: number;
--      completedRoutes?: string[];
--    };
--    completedSteps?: string[];
--    onboardingComplete?: boolean;
--    lastVisitedRoute?: string;
--    onboardingRoute?: string;
--  } | null;
--  isLoading: boolean;
--}
--
--interface UserInfoState {
--  userInfo: UserInfo | null;
--  isSubscribed: boolean;
--}
--
--interface UserStats {
--  coins: number;
--  isLoading: boolean;
--}
--
--/* --- User Slice ---- */
--interface UserSlice {
--  // UserProfile state
--  profile: UserProfile['profile'];
--  profileLoading: boolean;
--  isProfileComplete: boolean;
--  completedSteps: string[];
--  studyPreferences: {
--    dailyGoal: number;
--    reminderTime: string;
--  };
--  interfaceSettings: {
--    darkMode: boolean;
--    fontSize: string;
--  };
--  tutorialProgress: {
--    currentStep: number;
--    completedRoutes: string[];
--  };
--  onboardingComplete: boolean;
--  lastVisitedRoute: string;
--  onboardingRoute: string;
--  
--  // UserInfo state
--  userInfo: UserInfoState['userInfo'];
--  isSubscribed: boolean;
--  
--  // UserStats state
--  coins: number;
--  statsLoading: boolean;
--  error: string | null;
--  
--  // Actions
--  updateProfile: (updates: any) => Promise<void>;
--  refreshUserInfo: () => Promise<void>;
--  updateCoins: (amount: number) => Promise<void>;
--  updateCoinsDisplay: (newAmount: number) => void;
--  setIsSubscribed: (status: boolean) => void;
--  setCompletedSteps: (steps: string[]) => void;
--  addCompletedStep: (step: string) => void;
--  updateStudyPreferences: (preferences: Partial<UserSlice['studyPreferences']>) => void;
--  updateInterfaceSettings: (settings: Partial<UserSlice['interfaceSettings']>) => void;
--  updateTutorialProgress: (progress: Partial<UserSlice['tutorialProgress']>) => void;
--  setOnboardingComplete: (completed: boolean) => void;
--  setLastVisitedRoute: (route: string) => void;
--  setOnboardingRoute: (route: string) => void;
--}
--
--// Audio Slice has been moved to its own file: slices/audioSlice.ts
--// Game Slice has been moved to its own file: slices/gameSlice.ts
--
--//******************************************* Vocab Slice ****************************************************//
--interface VocabSlice {
--  // Vocab state
--  vocabList: Array<{
--    word: string;
--    definitions: string;
--  }>;
--  showVocabList: boolean;
--  isCmdIEnabled: boolean;
--  
--  // Vocab actions
--  addVocabWord: (word: string, definition: string) => void;
--  removeVocabWord: (word: string) => void;
--  toggleVocabList: () => void;
--  toggleCmdI: () => void;
--}
--
--// Updated to exclude AudioSlice, UISlice, and GameSlice since they're now in their own files
--type Store = UserSlice & VocabSlice;
--
--//====================================================================================================//
--//================================= Store Initialization =============================================//
--//====================================================================================================//
--
--export const useStore = create<Store>()(
--  devtools(
--    (set, get) => ({
--      //***********************************************************************************************//
--      //************************************** USER State *********************************************//
--      //***********************************************************************************************//
--      // User State
--      profile: null,
--      profileLoading: true,
--      isProfileComplete: false,
--      completedSteps: [],
--      studyPreferences: {
--        dailyGoal: 30, // Default: 30 minutes
--        reminderTime: '09:00', // Default: 9 AM
--      },
--      interfaceSettings: {
--        darkMode: false,
--        fontSize: 'medium',
--      },
--      tutorialProgress: {
--        currentStep: 0,
--        completedRoutes: [],
--      },
--      onboardingComplete: false,
--      lastVisitedRoute: '/',
--      onboardingRoute: '/onboarding',
--      userInfo: null,
--      isSubscribed: false,
--      coins: 0,
--      statsLoading: true,
--      error: null,
--
--      // User Actions
--      updateProfile: async (updates) => {
--        try {
--          // Get the current profile and email/userId for the API call
--          const currentProfile = get().profile;
--          const userInfo = get().userInfo;
--          
--          if (!userInfo || (!userInfo.email && !userInfo.userId)) {
--            console.error('Cannot update profile: No user email or ID available');
--            return;
--          }
--          
--          // Determine query parameter
--          
--          const queryParam = userInfo.email 
--            ? `email=${encodeURIComponent(userInfo.email)}` 
--            : `userId=${userInfo.userId}`;
--          
--          // Implement your API call here
--          const response = await fetch(`/api/user-info/profile?${queryParam}`, {
--            method: 'PATCH',
--            headers: { 'Content-Type': 'application/json' },
--            body: JSON.stringify(updates)
--          });
--          
--          if (!response.ok) throw new Error('Failed to update profile');
--          
--          const updatedProfile = await response.json();
--          
--          // Update the profile and related state
--          set({ 
--            profile: updatedProfile,
--            profileLoading: false,
--            // Update other profile-related state if present in the response
--            ...(updatedProfile.completedSteps && { completedSteps: updatedProfile.completedSteps }),
--            ...(updatedProfile.studyPreferences && { studyPreferences: updatedProfile.studyPreferences }),
--            ...(updatedProfile.interfaceSettings && { interfaceSettings: updatedProfile.interfaceSettings }),
--            ...(updatedProfile.tutorialProgress && { tutorialProgress: updatedProfile.tutorialProgress }),
--            ...(updatedProfile.onboardingComplete !== undefined && { 
--              onboardingComplete: updatedProfile.onboardingComplete 
--            }),
--            ...(updatedProfile.lastVisitedRoute && { lastVisitedRoute: updatedProfile.lastVisitedRoute }),
--            ...(updatedProfile.onboardingRoute && { onboardingRoute: updatedProfile.onboardingRoute }),
--          });
--          
--          // Update isProfileComplete based on completedSteps
--          const steps = updatedProfile.completedSteps || get().completedSteps;
--          set({ isProfileComplete: steps.length >= 3 }); // Assuming 3 steps is complete
--        } catch (error) {
--          console.error('Failed to update profile:', error);
--        }
--      },
--      
--      refreshUserInfo: async () => {
--        try {
--          // Only set loading if not already loading
--          const currentState = get();
--          if (!currentState.statsLoading && !currentState.profileLoading) {
--            set({ statsLoading: true, profileLoading: true, error: null });
--          }
--
--          // Add loading timeout
--          const loadingTimeout = setTimeout(() => {
--            const state = get();
--            if (state.statsLoading || state.profileLoading) {
--              set({ 
--                statsLoading: false,
--                profileLoading: false,
--                error: 'Loading timeout - please try again'
--              });
--            }
--          }, 10000);
--
--          // Batch all fetch requests together
--          const [userInfoResponse, profileResponse] = await Promise.all([
--            fetch('/api/user-info'),
--            fetch('/api/user-info/profile')
--          ]);
--
--          clearTimeout(loadingTimeout);
--
--          if (!userInfoResponse.ok) throw new Error('Failed to fetch user info');
--          const userInfo = await userInfoResponse.json();
--          
--          // Check if user is in 14-day free trial period based on account creation date
--          const isNewUserTrial = userInfo.createdAt ? isWithin14Days(new Date(userInfo.createdAt)) : false;
--
--          // Prepare single state update with only changed values
--          const updates: Partial<Store> = {
--            userInfo,
--            statsLoading: false,
--            profileLoading: false,
--            error: null
--          };
--
--          // Only update coins if changed
--          if (userInfo.score !== get().coins) {
--            updates.coins = userInfo.score || 0;
--          }
--
--          // Only update subscription if changed
--          // Match main branch behavior by including trial subscriptions
--          // Also include users in their 14-day trial period
--          const newSubStatus = 
--            userInfo.subscriptionType === 'gold' || 
--            userInfo.subscriptionType === 'premium' ||
--            userInfo.subscriptionType?.startsWith('Gold') ||
--            userInfo.subscriptionType?.includes('_Trial') || 
--            isNewUserTrial || 
--            false;
--            
--          if (newSubStatus !== get().isSubscribed) {
--            updates.isSubscribed = newSubStatus;
--          }
--
--          // IMPORTANT: Check onboarding status from userInfo.onboardingInfo
--          if (userInfo.onboardingInfo && typeof userInfo.onboardingInfo === 'object') {
--            // Check if targetScore exists (main branch logic)
--            const targetScore = userInfo.onboardingInfo.targetScore;
--            const isOnboardingComplete = targetScore !== undefined && 
--                                  targetScore !== null && 
--                                  targetScore > 0;
--            
--            // Set onboardingComplete based on targetScore criteria to match main branch
--            if (isOnboardingComplete !== get().onboardingComplete) {
--              // Apply this update immediately and separately from the batch update
--              set({ onboardingComplete: isOnboardingComplete });
--              
--              // Remove from batch updates to avoid overwriting
--              delete updates.onboardingComplete;
--              
--              // Sync with database if there's a mismatch
--              const dbOnboardingComplete = userInfo.onboardingInfo.onboardingComplete === true;
--              if (dbOnboardingComplete !== isOnboardingComplete) {
--                // Queue an update to sync the database value
--                setTimeout(() => {
--                  get().updateProfile({ onboardingComplete: isOnboardingComplete });
--                }, 0);
--              }
--            }
--          }
--
--          if (profileResponse.ok) {
--            const profileData = await profileResponse.json();
--            const currentProfile = get().profile;
--            
--            // Only update profile fields that have changed
--            if (JSON.stringify(currentProfile) !== JSON.stringify(profileData)) {
--              Object.assign(updates, {
--                profile: profileData,
--                completedSteps: profileData.completedSteps || [],
--                studyPreferences: profileData.studyPreferences || {
--                  dailyGoal: 30,
--                  reminderTime: '09:00'
--                },
--                interfaceSettings: profileData.interfaceSettings || {
--                  darkMode: false,
--                  fontSize: 'medium'
--                },
--                tutorialProgress: profileData.tutorialProgress || {
--                  currentStep: 0,
--                  completedRoutes: []
--                },
--                lastVisitedRoute: profileData.lastVisitedRoute || '/',
--                onboardingRoute: profileData.onboardingRoute || '/onboarding',
--                isProfileComplete: (profileData.completedSteps || []).length >= 3
--              });
--            }
--          }
--
--          // Single state update for all other fields
--          set(updates);
--
--        } catch (error) {
--          console.error('Error in refreshUserInfo:', error);
--          set({ 
--            error: error instanceof Error ? error.message : 'Failed to refresh user info',
--            statsLoading: false,
--            profileLoading: false
--          });
--        }
--      },
--      
--      updateCoins: async (amount) => {
--        try {
--          // Implement your API call to update coins/score
--          const response = await fetch('/api/user/score', {
--            method: 'POST',
--            headers: { 'Content-Type': 'application/json' },
--            body: JSON.stringify({ amount })
--          });
--          
--          if (!response.ok) throw new Error('Failed to update coins');
--          
--          // After successful update, refresh user info to get updated data
--          await get().refreshUserInfo();
--        } catch (error) {
--          console.error('Failed to update coins:', error);
--        }
--      },
--      
--      updateCoinsDisplay: (newAmount) => {
--        set({ coins: newAmount });
--      },
--      
--      setIsSubscribed: (status) => {
--        set({ isSubscribed: status });
--      },
--      
--      // New profile-related actions
--      setCompletedSteps: (steps) => {
--        set({ completedSteps: steps });
--        set({ isProfileComplete: steps.length >= 3 }); // Assuming 3 steps is complete
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ profile: { ...profile, completedSteps: steps } });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ completedSteps: steps });
--      },
--      
--      addCompletedStep: (step) => {
--        const currentSteps = get().completedSteps;
--        if (!currentSteps.includes(step)) {
--          const newSteps = [...currentSteps, step];
--          set({ completedSteps: newSteps });
--          set({ isProfileComplete: newSteps.length >= 3 }); // Assuming 3 steps is complete
--          
--          // Also update the profile object for consistency
--          const profile = get().profile;
--          if (profile) {
--            set({ profile: { ...profile, completedSteps: newSteps } });
--          }
--          
--          // Persist to backend if possible
--          get().updateProfile({ completedSteps: newSteps });
--        }
--      },
--      
--      updateStudyPreferences: (preferences) => {
--        const currentPreferences = get().studyPreferences;
--        const updatedPreferences = { ...currentPreferences, ...preferences };
--        set({ studyPreferences: updatedPreferences });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              studyPreferences: updatedPreferences 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ studyPreferences: updatedPreferences });
--      },
--      
--      updateInterfaceSettings: (settings) => {
--        const currentSettings = get().interfaceSettings;
--        const updatedSettings = { ...currentSettings, ...settings };
--        set({ interfaceSettings: updatedSettings });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              interfaceSettings: updatedSettings 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ interfaceSettings: updatedSettings });
--      },
--      
--      updateTutorialProgress: (progress) => {
--        const currentProgress = get().tutorialProgress;
--        const updatedProgress = { ...currentProgress, ...progress };
--        set({ tutorialProgress: updatedProgress });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              tutorialProgress: updatedProgress 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ tutorialProgress: updatedProgress });
--      },
--      
--      setOnboardingComplete: (completed) => {
--        set({ onboardingComplete: completed });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              onboardingComplete: completed 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ onboardingComplete: completed });
--      },
--      
--      setLastVisitedRoute: (route) => {
--        set({ lastVisitedRoute: route });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              lastVisitedRoute: route 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ lastVisitedRoute: route });
--      },
--      
--      setOnboardingRoute: (route) => {
--        set({ onboardingRoute: route });
--        
--        // Also update the profile object for consistency
--        const profile = get().profile;
--        if (profile) {
--          set({ 
--            profile: { 
--              ...profile, 
--              onboardingRoute: route 
--            } 
--          });
--        }
--        
--        // Persist to backend if possible
--        get().updateProfile({ onboardingRoute: route });
--      },
--
--      //************************************************************************************************//
--      //************************************** Vocab State *******************************************//
--      //***********************************************************************************************//
--      
--      // Vocab state
--      vocabList: [],
--      showVocabList: false,
--      isCmdIEnabled: false,
--      
--      // Vocab actions
--      addVocabWord: (word, definition) => {
--        set((state) => ({
--          vocabList: [...state.vocabList, { word, definitions: definition }],
--          showVocabList: true
--        }));
--      },
--      removeVocabWord: (word) => {
--        set((state) => ({
--          vocabList: state.vocabList.filter((v) => v.word !== word),
--          showVocabList: state.vocabList.length > 1
--        }));
--      },
--      toggleVocabList: () => {
--        set((state) => ({
--          showVocabList: !state.showVocabList
--        }));
--      },
--      toggleCmdI: () => {
--        set((state) => ({
--          isCmdIEnabled: !state.isCmdIEnabled
--        }));
--      }
--    }),
--    {
--      name: 'main-store'
--    }
--  )
--) 
--
--// Export a function to initialize the store at the app level
--export const initializeGlobalStore = async () => {
--  if (typeof window !== 'undefined' && !isStoreInitialized) {
--    console.debug('[DEBUG][Store] Initializing global store from exported function');
--    
--    try {
--      // Initialize audio context from the audio slice
--      await useAudioStore.getState().initializeAudioContext();
--      
--      // Initialize UI state
--      const savedTheme = localStorage.getItem('theme');
--      if (savedTheme && ['cyberSpace', 'sakuraTrees', 'sunsetCity', 'mykonosBlue'].includes(savedTheme)) {
--        useUIStore.getState().setTheme(savedTheme as any);
--      }
--      
--      // Set initialization flag
--      isStoreInitialized = true;
--      console.debug('[DEBUG][Store] Store initialization complete');
--    } catch (error) {
--      console.error('[DEBUG][Store] Store initialization failed:', error);
--    }
--  }
--};
--
--export type Card = {
--  id: string;
--  question: string;
--  answer: string;
--  explanation?: string;
--  category?: string;
--  difficulty?: string;
--  otherOptions?: string[];
--}; 
-\ No newline at end of file
-diff --git a/types/user.ts b/types/user.ts
-index fbfebfd1ee6aedbc07291a8e11c0e9b571da8789..9d2768fc5bd35c2f9cabf06bb48cc9856034b4da 100644
---- a/types/user.ts
-+++ b/types/user.ts
-@@ -4,6 +4,10 @@
- export interface OnboardingInfo {
-   targetScore?: number;
-   testDate?: string;
-+  currentStep?: number;
-+  firstName?: string;
-+  college?: string;
-+  onboardingComplete?: boolean;
-   // Add other onboarding fields as needed
- }
- 
diff --git a/README_Docs/tasks/user-dennis/4-PR-Diff.txt b/README_Docs/tasks/user-dennis/4-PR-Diff.txt
new file mode 100644
index 0000000000000000000000000000000000000000..2ac744eeeed50914497849b410955d0758e436df
diff --git a/README_Docs/tasks/user-dennis/4-PR-Notes.md b/README_Docs/tasks/user-dennis/4-PR-Notes.md
new file mode 100644
index 0000000000000000000000000000000000000000..cac8fa863930be166e61e03335928118f3e82497
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/4-PR-Notes.md
@@ -0,0 +1,107 @@
+# PR Analysis Notes
+
+## Summary of Key Changes
+
+This PR addresses several critical bugs and implements significant improvements in the onboarding and user authentication flows. The primary focus has been eliminating race conditions, improving state management, and ensuring a more reliable user experience.
+
+### 1. Fixed Core Navigation Bug
+- Resolved the issue where users were inappropriately redirected from the root URL (`localhost:3000` or `mymcat.ai`).
+- Implemented proper logic to ensure redirects only occur when users explicitly click the login button.
+- Added specific handling for various user flows (new users, returning users, post-login, post-logout).
+
+### 2. Eliminated Race Conditions
+- Replaced arbitrary timeouts (1-second delay in `StoreInitializer`) with dependency-based approaches.
+- Implemented comprehensive loading state management:
+  - Added detailed tracking of async operations
+  - Created proper state transition handling
+  - Eliminated cascading and redundant data fetches
+- Fixed the "duplicate onboardingComplete" bug by implementing defensive programming patterns.
+
+### 3. Improved State Management
+- Enhanced the Zustand store implementation with better error handling and loading states.
+- Implemented atomic state updates to prevent UI inconsistencies.
+- Added safeguards against root-level `onboardingComplete` property bug.
+- Improved data synchronization patterns between the client and server.
+
+### 4. Enhanced Developer Experience
+- Removed redundant debug statements and console logs.
+- Simplified logging to focus on critical events and errors.
+- Organized code with clearer structure and proper section headers.
+- Improved documentation with detailed notes on implementation patterns.
+
+### 5. Code Quality Improvements
+- Refactored `StoreInitializer` component to use dependency-based refreshes.
+- Enhanced `RouteTracker` with better loading state detection and management.
+- Improved `useOnboardingInfo` hook with proper request state tracking.
+- Implemented defensive coding patterns to prevent data inconsistencies.
+
+## Impact Areas
+
+1. **User Authentication Flow**
+   - Landing page behavior
+   - Login/registration process
+   - Session management
+   - Post-authentication redirects
+
+2. **Onboarding Process**
+   - Step progression
+   - Data persistence
+   - State synchronization
+   - Validation checks
+
+3. **Global State Management**
+   - User data handling
+   - Loading states
+   - Error handling
+   - Data fetching patterns
+
+## Testing Recommendations
+
+1. **Core Navigation Scenarios**
+   - Verify root URL (`localhost:3000`) behavior when:
+     - A new user visits the site
+     - A returning user (who completed onboarding) visits
+     - A user with incomplete onboarding visits
+     - A user manually navigates to root after being logged in
+     - A user returns to the site after logging out
+
+2. **Onboarding Flow**
+   - Test all onboarding steps, especially:
+     - Incomplete onboarding resumption
+     - Final step completion
+     - Validation of required fields
+     - Proper redirects after completion
+
+3. **Edge Cases**
+   - Interrupted network connections during onboarding
+   - Multiple concurrent sessions
+   - Browser refresh during critical state transitions
+
+## Questions for Review
+
+1. Should we implement the suggested `refreshUserInfo()` call in `handleReferralComplete` for complete synchronization?
+2. Are there any remaining edge cases in the navigation flow that should be addressed?
+3. Should we consider adopting React Query or SWR for data fetching in future updates?
+
+## Next Steps
+
+If this PR is approved, we should consider the following future improvements:
+
+1. âœ… Implemented critical state synchronization improvements:
+   - Added a full `refreshUserInfo()` call after setting `onboardingComplete: true` in `handleReferralComplete()`
+   - Implemented atomic updates for related state changes with the new `batchUpdateProfile` function
+   - Added error handling with rollback capabilities for failed API operations
+   - Replaced individual property updates with batch updates for related changes
+
+2. Additional recommended improvements:
+   - Reduce API calls through batching and caching
+   - Enhance error handling with retry logic
+   - Further streamline state management
+   - Improve auth flow with session persistence
+
+3. Add comprehensive automated tests for all critical user flows
+
+4. Consider performance optimizations:
+   - Caching strategies for user data
+   - Optimistic UI updates
+   - Lazy loading of non-critical components
\ No newline at end of file
diff --git a/README_Docs/tasks/user-dennis/4-PR-[Command].md b/README_Docs/tasks/user-dennis/4-PR-[Command].md
new file mode 100644
index 0000000000000000000000000000000000000000..c89176020271ca14214276ec0960db4e47b4fa87
--- /dev/null
+++ b/README_Docs/tasks/user-dennis/4-PR-[Command].md
@@ -0,0 +1,21 @@
+# PR Diff Analysis Workflow
+
+## Step 1: Generate the diff
+Run the following command to write the diff to 4-PR-Diff.txt:
+
+```bash
+# Generate detailed diff against main
+git diff --full-index main -- > README_Docs/tasks/user-dennis/4-PR-Diff.txt
+```
+
+## Step 2: Analyze the diff
+Carefully examine 4-PR-Diff.txt to identify all changes between your branch and main:
+- Review file additions, deletions, and modifications
+- Understand functional changes vs. cosmetic changes
+
+## Step 3: Document your analysis
+Write a detailed analysis of your findings in 4-PR-Notes.md, including:
+- Summary of key changes
+- Potential impact areas
+- Recommendations for the PR review
+- Any questions that need to be addressed before merging 
\ No newline at end of file
diff --git a/README_Docs/tasks/user-dennis/4-debug-console.txt b/README_Docs/tasks/user-dennis/4-debug-console.txt
deleted file mode 100644
index 75f5ba87bf2e3d07cf04f27d592a91337c8554b0..0000000000000000000000000000000000000000
--- a/README_Docs/tasks/user-dennis/4-debug-console.txt
+++ /dev/null
@@ -1,217 +0,0 @@
-initializationContentScript.js:1 Chrome storage API available, initializing emoji style sync
-content.js:1 [Deprecation] Listener added for a 'DOMNodeInserted' mutation event. Support for this event type has been removed, and this event will no longer be fired. See https://chromestatus.com/feature/5083947249172480 for more information.
-(anonymous) @ content.js:1
-j @ jquery.js:2
-fireWith @ jquery.js:2
-ready @ jquery.js:2
-I @ jquery.js:2
-contentScript.js:2 Chrome storage API available, initializing emoji style sync
-musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: cyberSpace
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: false, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: cyberSpace
-audioSlice.ts:193 [AudioSlice] Theme changed to cyberSpace wasPlaying: false
-layout.tsx:46 ðŸŽ« Subscription Status: FREE
-musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: cyberSpace
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 0, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: cyberSpace
-audioSlice.ts:193 [AudioSlice] Theme changed to cyberSpace wasPlaying: false
-layout.tsx:46 ðŸŽ« Subscription Status: FREE
-musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: sakuraTrees
-audioSlice.ts:193 [AudioSlice] Theme changed to sakuraTrees wasPlaying: false
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: false}
-musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-script.debug.js:1 [Vercel Web Analytics] Debug mode is enabled by default in development. No requests will be sent to the server.
-script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/home?debug=true {o: 'http://localhost:3000/home?debug=true', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742498654486,Â â€¦}
-audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-
-                
-          
-          
-          
-         Chrome is moving towards a new experience that allows users to choose to browse without third-party cookies.
-layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
-script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/ {o: 'http://localhost:3000/', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742498669025,Â â€¦}
-script.debug.js:1 [Vercel Web Analytics] [pageview] http://localhost:3000/home {o: 'http://localhost:3000/home', sv: '0.1.2', sdkn: '@vercel/analytics/react', sdkv: '1.3.1', ts: 1742498670288,Â â€¦}
-musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: false, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: true}
-musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: sakuraTrees
-audioSlice.ts:193 [AudioSlice] Theme changed to sakuraTrees wasPlaying: false
-layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
-musicplayer.tsx:104 [MusicPlayer] Initializing audio context
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: sakuraTrees
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: false}
-layout.tsx:46 ðŸŽ« Subscription Status: GOLD or PREMIUM
-musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-musicplayer.tsx:107 [MusicPlayer] Audio context initialized successfully
-audioSlice.ts:219 [AudioSlice] Not playing music after theme change
-useNotifications.ts:32 
-            
-            
-           GET http://localhost:3000/api/notifications 500 (Internal Server Error)
-eval @ useNotifications.ts:32
-useNotifications.ts:32 
-            
-            
-           GET http://localhost:3000/api/notifications 500 (Internal Server Error)
-eval @ useNotifications.ts:32
-useNotifications.ts:32 
-            
-            
-           GET http://localhost:3000/api/notifications 500 (Internal Server Error)
-eval @ useNotifications.ts:32
-useNotifications.ts:32 
-            
-            
-           GET http://localhost:3000/api/notifications 500 (Internal Server Error)
-eval @ useNotifications.ts:32
-useNotifications.ts:32 
-            
-            
-           GET http://localhost:3000/api/notifications 500 (Internal Server Error)
-eval @ useNotifications.ts:32
-musicplayer.tsx:150 [MusicPlayer] Toggle play button clicked
-musicplayer.tsx:177 [MusicPlayer] Toggling playback with existing queue
-audioSlice.ts:225 [AudioSlice] togglePlayPause called, checking current state
-audioSlice.ts:256 [AudioSlice] Starting playback from queue
-audioSlice.ts:259 [AudioSlice] Playing song at index 0 : /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2FsakuraTrees1.mp3
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2FsakuraTrees1.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2FsakuraTrees1.mp3
-audioSlice.ts:419 [AudioSlice] Fetching audio from: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2FsakuraTrees1.mp3
-audioSlice.ts:426 [AudioSlice] Audio fetch successful, processing array buffer...
-audioSlice.ts:436 [AudioSlice] Decoding audio data...
-audioSlice.ts:438 [AudioSlice] Audio data decoded successfully, caching buffer
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.699999988079071
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:263 [AudioSlice] Playback started successfully
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: mykonosBlue
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: false, shouldUpdateQueue: true}
-musicplayer.tsx:139 [MusicPlayer] Updating song queue for theme: mykonosBlue
-audioSlice.ts:193 [AudioSlice] Theme changed to mykonosBlue wasPlaying: false
-audioSlice.ts:198 [AudioSlice] Stopping current music before theme change
-audioSlice.ts:564 [AudioSlice] stopMusic called
-audioSlice.ts:572 [AudioSlice] Stopping music with audio context
-audioSlice.ts:581 [AudioSlice] Using gain node for smooth fade-out
-audioSlice.ts:655 [AudioSlice] Music playback stopped
-musicplayer.tsx:116 [MusicPlayer] Theme changed or component mounted, theme: mykonosBlue
-musicplayer.tsx:131 [MusicPlayer] Queue status: {initialized: true, queueLength: 10, firstSongMatchesTheme: true, shouldUpdateQueue: false}
-audioSlice.ts:600 [AudioSlice] Music source stopped with fade-out
-audioSlice.ts:533 [AudioSlice] Track ended naturally, advancing to next song
-audioSlice.ts:210 [AudioSlice] Auto-playing first song from new theme
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:419 [AudioSlice] Fetching audio from: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-musicplayer.tsx:150 [MusicPlayer] Toggle play button clicked
-musicplayer.tsx:177 [MusicPlayer] Toggling playback with existing queue
-audioSlice.ts:225 [AudioSlice] togglePlayPause called, checking current state
-audioSlice.ts:256 [AudioSlice] Starting playback from queue
-audioSlice.ts:259 [AudioSlice] Playing song at index 0 : /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:419 [AudioSlice] Fetching audio from: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-musicplayer.tsx:150 [MusicPlayer] Toggle play button clicked
-musicplayer.tsx:177 [MusicPlayer] Toggling playback with existing queue
-audioSlice.ts:225 [AudioSlice] togglePlayPause called, checking current state
-audioSlice.ts:256 [AudioSlice] Starting playback from queue
-audioSlice.ts:259 [AudioSlice] Playing song at index 0 : /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:419 [AudioSlice] Fetching audio from: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:426 [AudioSlice] Audio fetch successful, processing array buffer...
-audioSlice.ts:426 [AudioSlice] Audio fetch successful, processing array buffer...
-audioSlice.ts:426 [AudioSlice] Audio fetch successful, processing array buffer...
-audioSlice.ts:436 [AudioSlice] Decoding audio data...
-audioSlice.ts:436 [AudioSlice] Decoding audio data...
-audioSlice.ts:436 [AudioSlice] Decoding audio data...
-audioSlice.ts:438 [AudioSlice] Audio data decoded successfully, caching buffer
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.009999999776482582
-audioSlice.ts:523 [AudioSlice] Gain node volume too low, resetting to: 0.7
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:263 [AudioSlice] Playback started successfully
-audioSlice.ts:438 [AudioSlice] Audio data decoded successfully, caching buffer
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.699999988079071
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:263 [AudioSlice] Playback started successfully
-audioSlice.ts:438 [AudioSlice] Audio data decoded successfully, caching buffer
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.699999988079071
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:214 [AudioSlice] New theme music started successfully
-musicplayer.tsx:150 [MusicPlayer] Toggle play button clicked
-musicplayer.tsx:177 [MusicPlayer] Toggling playback with existing queue
-audioSlice.ts:225 [AudioSlice] togglePlayPause called, checking current state
-audioSlice.ts:229 [AudioSlice] Currently playing, stopping music
-audioSlice.ts:241 [AudioSlice] Music source stopped and disconnected
-audioSlice.ts:533 [AudioSlice] Track ended naturally, advancing to next song
-musicplayer.tsx:150 [MusicPlayer] Toggle play button clicked
-musicplayer.tsx:177 [MusicPlayer] Toggling playback with existing queue
-audioSlice.ts:225 [AudioSlice] togglePlayPause called, checking current state
-audioSlice.ts:256 [AudioSlice] Starting playback from queue
-audioSlice.ts:259 [AudioSlice] Playing song at index 0 : /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:413 [AudioSlice] Using cached buffer for: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue1.mp3
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.699999988079071
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:263 [AudioSlice] Playback started successfully
-musicplayer.tsx:182 [MusicPlayer] Next song button clicked
-musicplayer.tsx:188 [MusicPlayer] Skipping to next song
-audioSlice.ts:360 [AudioSlice] skipToNext called
-audioSlice.ts:372 [AudioSlice] Advancing from index 0 to 1
-audioSlice.ts:379 [AudioSlice] Storing current volume for restoration: 0.7
-audioSlice.ts:564 [AudioSlice] stopMusic called
-audioSlice.ts:572 [AudioSlice] Stopping music with audio context
-audioSlice.ts:581 [AudioSlice] Using gain node for smooth fade-out
-audioSlice.ts:655 [AudioSlice] Music playback stopped
-audioSlice.ts:600 [AudioSlice] Music source stopped with fade-out
-audioSlice.ts:533 [AudioSlice] Track ended naturally, advancing to next song
-audioSlice.ts:386 [AudioSlice] Timeout completed, playing next song: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue2.mp3
-audioSlice.ts:391 [AudioSlice] Reset music gain node to original volume: 0.7
-audioSlice.ts:449 [AudioSlice] playMusic called with URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue2.mp3
-audioSlice.ts:489 [AudioSlice] Loading audio buffer for track
-audioSlice.ts:405 [AudioSlice] Loading audio buffer for URL: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue2.mp3
-audioSlice.ts:419 [AudioSlice] Fetching audio from: /api/audio?url=https%3A%2F%2Fmy-mcat.s3.us-east-2.amazonaws.com%2Fmusic%2Fmykonosblue2.mp3
-audioSlice.ts:426 [AudioSlice] Audio fetch successful, processing array buffer...
-audioSlice.ts:436 [AudioSlice] Decoding audio data...
-audioSlice.ts:438 [AudioSlice] Audio data decoded successfully, caching buffer
-audioSlice.ts:492 [AudioSlice] Audio buffer loaded successfully
-audioSlice.ts:508 [AudioSlice] Reset music gain node to volume: 0.7
-audioSlice.ts:512 [AudioSlice] Creating audio source node
-audioSlice.ts:518 [AudioSlice] Connecting to music gain node with volume: 0.699999988079071
-audioSlice.ts:543 [AudioSlice] Starting playback
-audioSlice.ts:553 [AudioSlice] Playback started, state updated
-audioSlice.ts:396 [AudioSlice] Next song playback started successfully
diff --git a/README_Docs/tasks/user-dennis/5-cursor-notes.md b/README_Docs/tasks/user-dennis/5-cursor-notes.md
index 909495f5285da102e6fbf353f81bb494e9b96ea1..fe351b945000e48f239c50fa54d09644e02e1d40 100644
--- a/README_Docs/tasks/user-dennis/5-cursor-notes.md
+++ b/README_Docs/tasks/user-dennis/5-cursor-notes.md
@@ -4,7 +4,8 @@
 ` Do not apply code changes, just analyze the codebase and write out your steps to 2-single-task-steps.md`
 
 #### Compare functionality to main
-To thoroughly evaluate whether our branch behaves functionally the same as main, use both approaches:
+To thoroughly evaluate whether our branch behaves functionally the same as main:
+
 1. Add main branch to worktree for direct file comparison:
 ```bash
 # Add main branch as a worktree for comparison
@@ -13,21 +14,14 @@ git worktree add main
 git worktree remove main
 ```
 
-2. Create a diff file for Cursor analysis:
-```bash
-# Generate detailed diff against main
-git diff --full-index main -- > README_Docs/tasks/user-dennis/3-pr-diff.txt
-```
-
-3. Working with Cursor:
+2. Working with Cursor:
 Prompt to use for comparison
 
 ```
-Carefully examine both the diff against main @3-pr-diff.txt and our `main` branch repo itself, which was added to our worktree @main 
+Carefully examine our `main` branch repo itself, which was added to our worktree @main 
 Evaluate whether our branch behaves and acts functionally the SAME as main.
 ```
 
-Having both the worktree and diff file available provides:
+Having the worktree available provides:
 - Direct access to main branch files for inspection
-- A comprehensive diff that Cursor can analyze
 - The ability to verify functional equivalence with confidence
\ No newline at end of file
diff --git a/components/RouteTracker.tsx b/components/RouteTracker.tsx
index 23f2464e2fbec6f8328276ad0173b1f30cffda01..d75cb33bb122fc749406926d61dfc6c01b2c54ef 100644
--- a/components/RouteTracker.tsx
+++ b/components/RouteTracker.tsx
@@ -14,9 +14,31 @@ import { useAuth as useClerkAuth } from '@clerk/nextjs';
 // Define auth-related paths that should be exempt from redirects
 const AUTH_PATHS = ['/sign-in', '/sign-up', '/login', '/register', '/auth', '/sso-callback'];
 
-// Define other exempt paths
+// Define other exempt paths - Remove '/' from this list since we handle it specially
 const EXEMPT_PATHS = ['/auth', '/api', '/redirect', '/examcalendar', '/pricing', '/terms'];
 
+// Type for tracking loading states
+type LoadingState = {
+  auth: boolean;      // Clerk auth loaded
+  profile: boolean;   // User profile data loaded
+  stats: boolean;     // User stats loaded
+  studyPlan: boolean; // Study plan check loading
+  redirect: boolean;  // Redirect in progress
+};
+
+// Type for tracking async operations
+type AsyncOpState = {
+  loading: boolean;
+  error: Error | null;
+  complete: boolean;
+};
+
+const initialAsyncState: AsyncOpState = {
+  loading: false,
+  error: null,
+  complete: false
+};
+
 const RouteTracker = () => {
   const pathname = usePathname();
   const searchParams = useSearchParams();
@@ -27,22 +49,88 @@ const RouteTracker = () => {
   const { isLoaded } = useClerkAuth();
   const { stopLoop, currentLoop } = useAudio();
   
+  // Consolidated loading state
+  const [loadingState, setLoadingState] = useState<LoadingState>({
+    auth: true,
+    profile: true,
+    stats: true,
+    studyPlan: false,
+    redirect: false
+  });
+  
+  // Request state for study plan check
+  const [studyPlanCheckState, setStudyPlanCheckState] = useState<AsyncOpState>(initialAsyncState);
+  
+  // State flags
+  const [justLoggedIn, setJustLoggedIn] = useState(false);
   const [initialLoadComplete, setInitialLoadComplete] = useState(false);
+  
+  // Refs for redirection management
   const lastRedirectTime = useRef<number>(0);
   const isRedirecting = useRef<boolean>(false);
-
+  const prevSignedInState = useRef<boolean | undefined>(undefined);
+  
+  // Debug mode - Set to true to enable verbose logging
+  const isDebugMode = searchParams?.get('debug') === 'true';
+  
+  // Debug logging helper that only logs in debug mode
+  const debugLog = useCallback((section: string, ...args: unknown[]) => {
+    if (isDebugMode) {
+      console.log(`[${section}]`, ...args);
+    }
+  }, [isDebugMode]);
+  
+  // Update loading state when auth or data loading status changes
+  useEffect(() => {
+    setLoadingState(prev => ({
+      ...prev,
+      auth: !isLoaded,
+      profile: profileLoading,
+      stats: statsLoading
+    }));
+    
+    // Track initial load completion when all primary data is loaded
+    if (isLoaded && !profileLoading && !statsLoading && userInfo && !initialLoadComplete) {
+      setInitialLoadComplete(true);
+    }
+  }, [isLoaded, profileLoading, statsLoading, userInfo, initialLoadComplete]);
+  
   // Memoize values that are used in effect dependencies to prevent unnecessary re-renders
   const isExemptPath = useMemo(() => {
+    // Root path is always exempt
+    if (pathname === '/') {
+      debugLog('PATH_CHECK', 'Root path is exempt');
+      return true;
+    }
+    
     if (!pathname) return false;
-    return AUTH_PATHS.some(path => pathname.includes(path)) || 
-           EXEMPT_PATHS.some(path => pathname.startsWith(path));
-  }, [pathname]);
+    
+    // Always exempt auth-related paths
+    if (AUTH_PATHS.some(path => pathname.includes(path))) {
+      debugLog('PATH_CHECK', 'Auth path is exempt');
+      return true;
+    }
+    
+    // Other standard exempt paths
+    const isStandardExempt = EXEMPT_PATHS.some(path => pathname.startsWith(path));
+    debugLog('PATH_CHECK', `Path ${pathname} exempt: ${isStandardExempt}`);
+    return isStandardExempt;
+  }, [pathname, debugLog]);
 
   // Validate onboarding status (memoized)
   const effectiveOnboardingComplete = useMemo(() => {
+    // First check the direct onboardingComplete flag from onboardingInfo
+    if (userInfo?.onboardingInfo?.onboardingComplete === true) {
+      debugLog('ONBOARDING', 'Complete via direct flag');
+      return true;
+    }
+    
+    // Then fall back to targetScore validation as a secondary check
     const targetScore = userInfo?.onboardingInfo?.targetScore;
-    return targetScore !== undefined && targetScore !== null && targetScore > 0;
-  }, [userInfo?.onboardingInfo?.targetScore]);
+    const isComplete = targetScore !== undefined && targetScore !== null && targetScore > 0;
+    debugLog('ONBOARDING', `Complete via target score: ${isComplete}`);
+    return isComplete;
+  }, [userInfo?.onboardingInfo?.onboardingComplete, userInfo?.onboardingInfo?.targetScore, debugLog]);
 
   // Local utility function for preserving debug parameter
   const preserveDebugParam = useCallback((path: string): string => {
@@ -60,10 +148,15 @@ const RouteTracker = () => {
   const performRedirect = useCallback((targetPath: string, reason: string) => {
     // Prevent duplicate redirects and throttle redirect attempts
     if (Date.now() - lastRedirectTime.current < 1000 || isRedirecting.current) {
-      return false;
+      debugLog('REDIRECT', `Skipping redirect to ${targetPath} - too soon or already redirecting`);
+      return undefined;
     }
 
+    debugLog('REDIRECT', `Redirecting to ${targetPath} - reason: ${reason}`);
+
+    // Set redirect state
     isRedirecting.current = true;
+    setLoadingState(prev => ({ ...prev, redirect: true }));
     lastRedirectTime.current = Date.now();
     
     // Use the local function to preserve debug parameter
@@ -81,11 +174,45 @@ const RouteTracker = () => {
     // Reset redirect flag after 1.5 seconds
     setTimeout(() => {
       isRedirecting.current = false;
+      setLoadingState(prev => ({ ...prev, redirect: false }));
     }, 1500);
     
     // Return the fallback timeout to allow cleanup
     return fallbackTimeout;
-  }, [router, preserveDebugParam]);
+  }, [router, preserveDebugParam, debugLog]);
+
+  // Check study plan with proper async state tracking
+  const checkStudyPlan = useCallback(async (): Promise<boolean> => {
+    // Set loading state
+    setStudyPlanCheckState({ loading: true, error: null, complete: false });
+    setLoadingState(prev => ({ ...prev, studyPlan: true }));
+    
+    try {
+      const response = await fetch('/api/study-plan');
+      
+      if (!response.ok) {
+        throw new Error('Failed to fetch study plan');
+      }
+      
+      const data = await response.json();
+      
+      // Update states
+      setStudyPlanCheckState({ loading: false, error: null, complete: true });
+      setLoadingState(prev => ({ ...prev, studyPlan: false }));
+      
+      // Return whether study plan exists
+      return !!data.studyPlan;
+    } catch (error) {
+      debugLog('STUDY_PLAN', 'Error checking study plan:', error);
+      
+      // Set error state
+      const typedError = error instanceof Error ? error : new Error('Unknown error checking study plan');
+      setStudyPlanCheckState({ loading: false, error: typedError, complete: true });
+      setLoadingState(prev => ({ ...prev, studyPlan: false }));
+      
+      return false;
+    }
+  }, [debugLog]);
 
   // Update current route in the store
   useEffect(() => {
@@ -94,23 +221,6 @@ const RouteTracker = () => {
     }
   }, [pathname, setCurrentRoute]);
 
-  // Track initial load completion - match main branch behavior
-  useEffect(() => {
-    // Skip loading state tracking if we're on onboarding
-    if (pathname === '/onboarding') {
-      if (!initialLoadComplete) {
-        setInitialLoadComplete(true);
-      }
-      return;
-    }
-
-    // Consider data loaded when both profile and stats are loaded
-    // and we have userInfo data (like main branch)
-    if (!profileLoading && !statsLoading && userInfo && !initialLoadComplete) {
-      setInitialLoadComplete(true);
-    }
-  }, [profileLoading, statsLoading, userInfo, initialLoadComplete, pathname]);
-
   // Handle ambient sound cleanup on route changes
   useEffect(() => {    
     // Only stop the ambient loop if we're not in AnkiClinic and it's currently playing
@@ -119,47 +229,114 @@ const RouteTracker = () => {
     }
   }, [pathname, stopLoop, currentLoop]);
 
-  // EFFECT 1: Handle immediate redirection for users with no userInfo (like main branch)
+  // Track if user just logged in
   useEffect(() => {
-    // Don't redirect during loads or for exempt paths
-    if (!isLoaded || isRedirecting.current || isExemptPath) {
-      return;
+    const wasExplicitLogin = localStorage.getItem('explicit_login_click') === 'true';
+    
+    // If signed in state changed AND it was an explicit login button click
+    if (isSignedIn === true && prevSignedInState.current !== true && wasExplicitLogin) {
+      debugLog('AUTH', 'Login detected from explicit button click');
+      setJustLoggedIn(true);
+      // Clear the flag
+      localStorage.removeItem('explicit_login_click');
     }
+    
+    // Update previous state for next comparison
+    prevSignedInState.current = isSignedIn;
+  }, [isSignedIn, debugLog]);
 
-    // If user is signed in but has no userInfo, redirect to onboarding immediately
-    if (isSignedIn && !profileLoading && !userInfo && !pathname?.startsWith('/onboarding')) {
-      const fallback = performRedirect('/onboarding', 'No userInfo');
+  // Special effect for handling login from root path
+  useEffect(() => {
+    // Only handle explicit login redirects on root path
+    if (pathname !== '/' || !justLoggedIn) return;
+
+    // Skip if still loading or redirect in progress
+    if (!isLoaded || loadingState.profile || isRedirecting.current) return;
+    
+    // Decide where to redirect based on onboarding status
+    if (isSignedIn) {
+      console.log('[CRITICAL_DEBUG] Login Redirect Decision:', {
+        onboardingFlag: userInfo?.onboardingInfo?.onboardingComplete,
+        targetScore: userInfo?.onboardingInfo?.targetScore,
+        effectiveOnboardingComplete: effectiveOnboardingComplete,
+        willRedirectTo: effectiveOnboardingComplete ? '/home' : '/onboarding'
+      });
       
-      // Clean up fallback timeout if component unmounts
-      return () => {
-        if (fallback) clearTimeout(fallback);
-      };
+      if (effectiveOnboardingComplete) {
+        debugLog('ROOT_PATH', 'Redirecting to /home - onboarding complete');
+        const fallback = performRedirect('/home', 'Login with onboarding complete');
+        setJustLoggedIn(false); // Reset flag
+        return () => { if (fallback) clearTimeout(fallback); };
+      } else {
+        debugLog('ROOT_PATH', 'Redirecting to /onboarding - onboarding incomplete');
+        const fallback = performRedirect('/onboarding', 'Login with onboarding incomplete');
+        setJustLoggedIn(false); // Reset flag
+        return () => { if (fallback) clearTimeout(fallback); };
+      }
     }
-  }, [isSignedIn, userInfo, profileLoading, pathname, isLoaded, isExemptPath, performRedirect]);
+  }, [
+    pathname, 
+    isSignedIn, 
+    isLoaded, 
+    justLoggedIn, 
+    effectiveOnboardingComplete, 
+    loadingState.profile, 
+    performRedirect,
+    debugLog,
+    userInfo
+  ]);
 
-  // EFFECT 2: Handle redirects based on onboarding status (like main branch)
+  // Handle redirection for users with no userInfo
   useEffect(() => {
-    if (pathname === '/onboarding' || isExemptPath) {
+    // Skip if any of these conditions are true
+    if (
+      !isLoaded || 
+      isRedirecting.current || 
+      isExemptPath || 
+      !isSignedIn || 
+      loadingState.profile || 
+      pathname?.startsWith('/onboarding')
+    ) {
       return;
     }
     
-    // Only redirect to onboarding if:
-    // 1. User is signed in
-    // 2. Not already on onboarding page
-    // 3. Not in loading state
-    // 4. Onboarding is not complete
-    if (isSignedIn && !profileLoading && !isRedirecting.current && !effectiveOnboardingComplete) {
-      const fallback = performRedirect('/onboarding', 'Onboarding not complete');
+    // If user is signed in but has no userInfo, redirect to onboarding immediately
+    if (!userInfo) {
+      debugLog('USERINFO', 'No userInfo - redirecting to onboarding');
+      const fallback = performRedirect('/onboarding', 'No userInfo');
       
       // Clean up fallback timeout if component unmounts
       return () => {
         if (fallback) clearTimeout(fallback);
       };
     }
+  }, [
+    isSignedIn, 
+    userInfo, 
+    loadingState.profile, 
+    pathname, 
+    isLoaded, 
+    isExemptPath, 
+    performRedirect,
+    debugLog
+  ]);
+
+  // Handle redirects based on onboarding status
+  useEffect(() => {
+    // Skip if any of these conditions are true
+    if (
+      pathname === '/onboarding' || 
+      isExemptPath || 
+      loadingState.redirect || 
+      loadingState.profile
+    ) {
+      return;
+    }
     
-    // Onboarding complete but on onboarding page, redirect to home
-    if (isSignedIn && !profileLoading && effectiveOnboardingComplete && pathname === '/onboarding') {
-      const fallback = performRedirect('/home', 'Onboarding complete but on onboarding page');
+    // Redirect to onboarding if needed
+    if (isSignedIn && !effectiveOnboardingComplete) {
+      debugLog('ONBOARDING_CHECK', 'Redirecting to onboarding - incomplete');
+      const fallback = performRedirect('/onboarding', 'Onboarding not complete');
       
       // Clean up fallback timeout if component unmounts
       return () => {
@@ -167,74 +344,79 @@ const RouteTracker = () => {
       };
     }
     
-    // Special case: If on root path and signed in with completed onboarding, redirect to home
-    if (isSignedIn && !profileLoading && effectiveOnboardingComplete && pathname === '/') {
-      const fallback = performRedirect('/home', 'On root with completed onboarding');
+    // Redirect from onboarding page if already complete
+    if (isSignedIn && effectiveOnboardingComplete && pathname === '/onboarding') {
+      debugLog('ONBOARDING_CHECK', 'Redirecting to home - already complete');
+      const fallback = performRedirect('/home', 'Onboarding already complete');
       
       // Clean up fallback timeout if component unmounts
       return () => {
         if (fallback) clearTimeout(fallback);
       };
     }
-  }, [isSignedIn, profileLoading, pathname, effectiveOnboardingComplete, isExemptPath, performRedirect]);
+  }, [
+    isSignedIn, 
+    loadingState.profile, 
+    loadingState.redirect,
+    pathname, 
+    effectiveOnboardingComplete, 
+    isExemptPath, 
+    performRedirect,
+    debugLog
+  ]);
 
-  // EFFECT 3: Main redirection logic for subscription checks (like main branch)
+  // Handle subscription and study plan checks
   useEffect(() => {
-    // Skip redirection checks for specific paths
+    // Skip checks if any of these conditions are true
     if (
+      !initialLoadComplete ||
+      !isLoaded || 
+      !isSignedIn ||
+      !userInfo ||
+      !effectiveOnboardingComplete ||
+      loadingState.redirect ||
+      loadingState.studyPlan ||
+      isExemptPath ||
       pathname === '/onboarding' || 
       pathname === '/redirect' ||
       pathname?.startsWith('/onboarding') ||
-      pathname?.startsWith('/pricing') ||
-      isExemptPath ||
-      isRedirecting.current ||
-      !initialLoadComplete ||
-      !isLoaded ||
-      !isSignedIn ||
-      !userInfo
+      pathname?.startsWith('/pricing')
     ) {
       return;
     }
 
-    // Check if we have userInfo, if not refresh it
-    if (isSignedIn && !userInfo) {
-      refreshUserInfo();
-      return;
-    }
-
-    const checkRedirectPath = async () => {
-      // 1. Subscription check - redirect non-subscribers to ankiclinic
-      if (effectiveOnboardingComplete && !isSubscribed && pathname && !pathname.startsWith('/ankiclinic')) {
+    // Check subscription status
+    const checkSubscriptionAndStudyPlan = async () => {
+      // Subscription check - redirect non-subscribers to ankiclinic
+      if (!isSubscribed && pathname && !pathname.startsWith('/ankiclinic')) {
+        debugLog('SUBSCRIPTION', 'Not subscribed - redirecting to ankiclinic');
         const fallback = performRedirect('/ankiclinic', 'Not subscribed');
-        if (fallback) return fallback;
+        return fallback;
       }
 
-      // 2. Check study plan for subscribed users
-      const studyPlanExemptPaths = ['/examcalendar', '/api', '/auth', '/onboarding', '/redirect'];
-      const shouldCheckStudyPlan = pathname ? !studyPlanExemptPaths.some(path => pathname.startsWith(path)) : false;
+      // Only check study plan for subscribed users on certain paths
+      const studyPlanExemptPaths = ['/examcalendar', '/api', '/auth', '/onboarding', '/redirect', '/ankiclinic'];
+      const shouldCheckStudyPlan = !studyPlanExemptPaths.some(path => pathname?.startsWith(path));
       
-      if (effectiveOnboardingComplete && isSubscribed && shouldCheckStudyPlan) {
-        try {
-          const response = await fetch('/api/study-plan');
-          if (!response.ok) {
-            throw new Error('Failed to fetch study plan');
-          }
-          
-          const data = await response.json();
-          
-          if (!data.studyPlan) {
-            const fallback = performRedirect('/examcalendar', 'No study plan');
-            if (fallback) return fallback;
-          }
-        } catch (error) {
-          console.error('[RouteTracker] Error checking study plan:', error);
+      if (isSubscribed && shouldCheckStudyPlan) {
+        debugLog('STUDY_PLAN', 'Checking study plan existence');
+        
+        // Check if study plan exists
+        const hasStudyPlan = await checkStudyPlan();
+        
+        if (!hasStudyPlan) {
+          debugLog('STUDY_PLAN', 'No study plan - redirecting to examcalendar');
+          const fallback = performRedirect('/examcalendar', 'No study plan');
+          return fallback;
         }
       }
+      
+      return null;
     };
     
-    // Handle async redirects with proper typing
+    // Handle async operations with proper cleanup
     let fallbackTimeout: ReturnType<typeof setTimeout> | undefined;
-    checkRedirectPath().then(timeout => {
+    checkSubscriptionAndStudyPlan().then(timeout => {
       fallbackTimeout = timeout;
     });
     
@@ -250,11 +432,31 @@ const RouteTracker = () => {
     userInfo,
     effectiveOnboardingComplete,
     isSubscribed,
-    refreshUserInfo,
+    loadingState.redirect,
+    loadingState.studyPlan,
     isExemptPath,
-    performRedirect
+    performRedirect,
+    checkStudyPlan,
+    debugLog
   ]);
 
+  // Expose core loading state for the application
+  const isApplicationLoading = useMemo(() => {
+    return (
+      loadingState.auth || 
+      loadingState.profile || 
+      loadingState.redirect || 
+      isRedirecting.current
+    );
+  }, [loadingState]);
+
+  // Expose consolidated state to components via Zustand if needed
+  useEffect(() => {
+    // Here you could update a loading state in a Zustand store
+    // This would make the loading state available to all components
+    // Example: setAppLoading(isApplicationLoading);
+  }, [isApplicationLoading]);
+
   return null;
 };
 
diff --git a/components/StoreInitializer.tsx b/components/StoreInitializer.tsx
index 8f93c948910eda3c2f3cbb4c5907ce3b783b10d1..6838179f6108d037fc799b9b7205f6046b242954 100644
--- a/components/StoreInitializer.tsx
+++ b/components/StoreInitializer.tsx
@@ -1,10 +1,32 @@
 "use client";
 
-import { useEffect } from 'react';
+import { useEffect, useState, useRef, useCallback } from 'react';
 import { useUser as useClerkUser } from '@clerk/nextjs';
-import { useUser } from '@/store/selectors';
+import { useUserStore } from '@/store/slices/userSlice';
 import { useAudioStore } from '@/store/slices/audioSlice';
-import { initializeGlobalStore } from '@/store';
+import { useUIStore } from '@/store/slices/uiSlice';
+import type { ThemeType } from '@/store/slices/uiSlice';
+
+/**
+ * Initialize global store with theme and audio settings
+ */
+const initializeGlobalStore = async (): Promise<void> => {
+  if (typeof window !== 'undefined') {
+    try {
+      // Initialize audio context
+      await useAudioStore.getState().initializeAudioContext();
+      
+      // Initialize UI state
+      const savedTheme = localStorage.getItem('theme');
+      if (savedTheme && ['cyberSpace', 'sakuraTrees', 'sunsetCity', 'mykonosBlue'].includes(savedTheme)) {
+        useUIStore.getState().setTheme(savedTheme as ThemeType);
+      }
+    } catch (error) {
+      console.error('[Store] Store initialization failed:', error);
+      throw error;
+    }
+  }
+};
 
 /**
  * StoreInitializer component
@@ -18,9 +40,13 @@ import { initializeGlobalStore } from '@/store';
  */
 const StoreInitializer = () => {
   const { isLoaded, isSignedIn } = useClerkUser();
-  const { refreshUserInfo } = useUser();
+  const refreshUserInfo = useUserStore(state => state.refreshUserInfo);
   const initializeAudioContext = useAudioStore(state => state.initializeAudioContext);
   
+  // Track data refresh state
+  const [isInitialRefreshComplete, setIsInitialRefreshComplete] = useState(false);
+  const refreshAttemptRef = useRef(0);
+  
   // Initialize the global store when the app starts
   useEffect(() => {
     if (typeof window === 'undefined') return;
@@ -36,30 +62,55 @@ const StoreInitializer = () => {
     });
   }, [initializeAudioContext]);
   
-  // Refresh user information when the user is signed in
+  // Helper to log performance info during refresh
+  const logRefreshAttempt = useCallback((action: string, attempt: number) => {
+    // Simplified: Only log critical user refresh events
+    if (action.includes('failed')) {
+      console.log(`[StoreInitializer] ${action} (attempt: ${attempt})`);
+    }
+  }, []);
+  
+  // Refresh user information when the user is signed in - dependency-based approach
   useEffect(() => {
-    if (isLoaded && isSignedIn) {
-      // Initial refresh
-      refreshUserInfo();
+    if (!isLoaded || !isSignedIn) return;
+    
+    // Track this refresh attempt
+    const currentAttempt = refreshAttemptRef.current;
+    refreshAttemptRef.current += 1;
+    
+    logRefreshAttempt('User signed in, refreshing user info', currentAttempt);
+    
+    refreshUserInfo()
+      .then(() => {
+        logRefreshAttempt('User refresh complete', currentAttempt);
+        setIsInitialRefreshComplete(true);
+      })
+      .catch(error => {
+        console.error(`[StoreInitializer] User refresh failed (attempt: ${currentAttempt}):`, error);
+      });
       
-      /**
-       * IMPORTANT: Secondary refresh to ensure state synchronization
-       * 
-       * This solves a race condition where:
-       * 1. The first refreshUserInfo() updates hasCompletedOnboarding in the store
-       * 2. But RouteTracker might read the old value before the update is fully applied
-       * 3. This causes incorrect redirects (e.g., to onboarding when it should go to home)
-       * 
-       * The delayed second refresh ensures all components have the correct state
-       * after the initial data load is complete.
-       */
-      const refreshTimeout = setTimeout(() => {
-        refreshUserInfo();
-      }, 1000);
+  }, [isLoaded, isSignedIn, refreshUserInfo, logRefreshAttempt]);
+  
+  // Secondary refresh effect that depends on initial refresh being complete
+  // This replaces the arbitrary timeout with a dependency-based approach
+  useEffect(() => {
+    if (!isInitialRefreshComplete || !isLoaded || !isSignedIn) return;
+    
+    // Track this refresh attempt
+    const currentAttempt = refreshAttemptRef.current;
+    refreshAttemptRef.current += 1;
+    
+    logRefreshAttempt('Initial refresh complete, performing verification refresh', currentAttempt);
+    
+    refreshUserInfo()
+      .then(() => {
+        logRefreshAttempt('Verification refresh complete', currentAttempt);
+      })
+      .catch(error => {
+        console.error(`[StoreInitializer] Verification refresh failed (attempt: ${currentAttempt}):`, error);
+      });
       
-      return () => clearTimeout(refreshTimeout);
-    }
-  }, [isLoaded, isSignedIn, refreshUserInfo]);
+  }, [isInitialRefreshComplete, isLoaded, isSignedIn, refreshUserInfo, logRefreshAttempt]);
   
   // This component doesn't render anything
   return null;
diff --git a/components/landingpage/landing-navbar.tsx b/components/landingpage/landing-navbar.tsx
index 17467e97d39b1883ba4034c8ec9c68fba64069de..f7187d7d428e29d9669cc280c3728060618dec70 100644
--- a/components/landingpage/landing-navbar.tsx
+++ b/components/landingpage/landing-navbar.tsx
@@ -63,7 +63,13 @@ const LandingNavbar = () => {
             </button>
           </Link>
           <Link href={"/sign-in"}>
-            <button className="bg-white text-black py-2 text-[16px] px-6 rounded-lg hover:bg-white/90 transition-colors duration-300">
+            <button 
+              className="bg-white text-black py-2 text-[16px] px-6 rounded-lg hover:bg-white/90 transition-colors duration-300"
+              onClick={() => {
+                console.log('[LOGIN BUTTON] Login button clicked explicitly by user');
+                localStorage.setItem('explicit_login_click', 'true');
+              }}
+            >
               Login
             </button>
           </Link>
@@ -113,7 +119,13 @@ const LandingNavbar = () => {
             </button>
           </Link>
           <Link href={"/sign-in"} >
-            <button className="w-full bg-white text-black py-3 text-lg rounded-lg hover:bg-white/90 transition-colors duration-300 mt-4">
+            <button 
+              className="w-full bg-white text-black py-3 text-lg rounded-lg hover:bg-white/90 transition-colors duration-300 mt-4"
+              onClick={() => {
+                console.log('[LOGIN BUTTON] Login button clicked explicitly by user');
+                localStorage.setItem('explicit_login_click', 'true');
+              }}
+            >
               Login
             </button>
           </Link>
diff --git a/components/ui/DebugPanel.tsx b/components/ui/DebugPanel.tsx
index a73fa72c3df9c67cff6d8e59d27ab167e78d6e01..1aeb7e9e2c1fb2364c8e8df4134f03a14f5e296b 100644
--- a/components/ui/DebugPanel.tsx
+++ b/components/ui/DebugPanel.tsx
@@ -3,16 +3,19 @@
 import { useState, useEffect } from 'react';
 import { usePathname, useSearchParams } from 'next/navigation';
 import { useUI, useUser, useGame, useAudio, useVocab } from '@/store/selectors'
+import { useUserStore } from '@/store/slices/userSlice'
 
 /* --- Constants ----- */
 const DEBUG_PARAM = 'debug'
 
 const DebugPanel = () => {
+  
   /* ---- State ----- */
   const searchParams = useSearchParams()
   const pathname = usePathname() || ''
   const [isDebug, setIsDebug] = useState(false)
   
+  
   // Zustand state
   const uiState = useUI()
   const userState = useUser()
@@ -25,7 +28,10 @@ const DebugPanel = () => {
   useEffect(() => {
     const debugValue = searchParams?.get(DEBUG_PARAM)
     
-    if (debugValue === 'true') {
+    // Add a direct check for the debug parameter in URL
+    const urlContainsDebug = typeof window !== 'undefined' && window.location.href.includes('debug=true');
+    
+    if (debugValue === 'true' || urlContainsDebug) {
       setIsDebug(true)
       document.body.classList.add('debug-mode')
     } else {
@@ -33,7 +39,8 @@ const DebugPanel = () => {
       setIsDebug(false)
       document.body.classList.remove('debug-mode')
     }
-  }, [searchParams, pathname])
+  }, [searchParams])
+
 
   // Create a safe version of audio state for display (without functions)
   const displayAudioState = {
@@ -69,38 +76,161 @@ const DebugPanel = () => {
     }
   };
 
+  // Function to stringify with sorted keys - using a custom serialization approach
+  const stringifySorted = (obj: any) => {
+    // First, build a clean object removing functions and preserving order
+    const prepareObject = (input: any): any => {
+      // Handle primitives, null and undefined
+      if (input === null || input === undefined || typeof input !== 'object') {
+        return input;
+      }
+      
+      // Handle arrays
+      if (Array.isArray(input)) {
+        return input.map(item => prepareObject(item));
+      }
+      
+      // Create an object without functions, sorting keys alphabetically
+      const result: any = {};
+      
+      // Get sorted keys
+      const keys = Object.keys(input).sort((a, b) => 
+        a.localeCompare(b, 'en', { sensitivity: 'base' })
+      );
+      
+      // Add keys in sorted order
+      keys.forEach(key => {
+        if (typeof input[key] !== 'function') {
+          result[key] = prepareObject(input[key]);
+        }
+      });
+      
+      return result;
+    };
+    
+    // Manually handle JSON string creation with sorted keys
+    const toSortedJSONString = (input: any, indent = 0): string => {
+      // Handle primitives, null and undefined
+      if (input === null) return 'null';
+      if (input === undefined) return 'undefined';
+      if (typeof input !== 'object') {
+        if (typeof input === 'string') return `"${input.replace(/"/g, '\\"')}"`;
+        return String(input);
+      }
+      
+      // Handle arrays
+      if (Array.isArray(input)) {
+        if (input.length === 0) return '[]';
+        let result = '[\n';
+        const spaces = ' '.repeat(indent + 2);
+        
+        input.forEach((item, index) => {
+          result += spaces + toSortedJSONString(item, indent + 2);
+          if (index < input.length - 1) result += ',';
+          result += '\n';
+        });
+        
+        result += ' '.repeat(indent) + ']';
+        return result;
+      }
+      
+      // Handle objects - keys should already be sorted by prepareObject
+      const keys = Object.keys(input);
+      
+      if (keys.length === 0) return '{}';
+      
+      let result = '{\n';
+      const spaces = ' '.repeat(indent + 2);
+      
+      keys.forEach((key, index) => {
+        result += spaces + `"${key}": ` + toSortedJSONString(input[key], indent + 2);
+        if (index < keys.length - 1) result += ',';
+        result += '\n';
+      });
+      
+      result += ' '.repeat(indent) + '}';
+      return result;
+    };
+    
+    try {
+      // Clean the object (removes functions and sorts keys)
+      const preparedObj = prepareObject(obj);
+      
+      // Generate the sorted JSON string
+      return toSortedJSONString(preparedObj, 0);
+    } catch (err) {
+      // Fall back to standard JSON
+      return JSON.stringify(obj, (key, value) => {
+        if (typeof value === 'function') return undefined;
+        return value;
+      }, 2);
+    }
+  };
+
   // Don't render anything if not in debug mode
-  if (!isDebug) return null;
+  if (!isDebug) {
+    return null;
+  }
+  
+  // Create a custom version of userState for display
+  const userStateForDisplay = (() => {
+    // If userInfo doesn't exist, just return the original state
+    if (!userState.userInfo) return userState;
+    
+    // Extract onboardingInfo from userInfo if it exists
+    const onboardingInfo = userState.userInfo.onboardingInfo || null;
+    
+    // Create a clean copy, explicitly excluding any root-level onboardingComplete
+    const { onboardingComplete: _, ...cleanState } = userState as any;
+    
+    return {
+      ...cleanState,
+      // Move onboardingInfo to top level for better visibility
+      onboardingInfo
+    };
+  })();
 
   // Debug panel UI
   return (
     <div className="fixed bottom-4 right-4 z-[9999] bg-black/80 text-white p-4 rounded-lg max-w-[400px] max-h-[80vh] overflow-auto text-xs">
       <h3 className="text-lg font-bold mb-2">Debug Panel</h3>
+      
       <div className="grid grid-cols-1 gap-2">
         <div>
-          <h4 className="font-bold">Audio State</h4>
-          <pre>{JSON.stringify(displayAudioState, null, 2)}</pre>
+          <h4 className="font-bold">UI State</h4>
+          <pre>{stringifySorted({
+            theme: uiState.theme,
+            window: uiState.window,
+            currentRoute: uiState.currentRoute
+          })}</pre>
         </div>
         
         <hr className="border-white/30 my-2" />
+        
         <div>
-          <h4 className="font-bold">Game State</h4>
-          <pre>{JSON.stringify(gameState, null, 2)}</pre>
+          <h4 className="font-bold">User State</h4>
+          <pre>{stringifySorted(userStateForDisplay)}</pre>
         </div>
+        
         <hr className="border-white/30 my-2" />
+        
         <div>
-          <h4 className="font-bold">UI State</h4>
-          <pre>{JSON.stringify(uiState, null, 2)}</pre>
+          <h4 className="font-bold">Audio State</h4>
+          <pre>{stringifySorted(displayAudioState)}</pre>
         </div>
+        
         <hr className="border-white/30 my-2" />
+        
         <div>
-          <h4 className="font-bold">User State</h4>
-          <pre>{JSON.stringify(userState, null, 2)}</pre>
+          <h4 className="font-bold">Game State</h4>
+          <pre>{stringifySorted(gameState)}</pre>
         </div>
+        
         <hr className="border-white/30 my-2" />
+        
         <div>
           <h4 className="font-bold">Vocab State</h4>
-          <pre>{JSON.stringify(vocabState, null, 2)}</pre>
+          <pre>{stringifySorted(vocabState)}</pre>
         </div>
       </div>
     </div>
diff --git a/hooks/useOnboardingInfo.ts b/hooks/useOnboardingInfo.ts
index a75b7ee2a4f4ac0f3bc5dac1f938ed2e2a904f1c..8c30303b97e9ca1b2a31be074a0c175495401cb5 100644
--- a/hooks/useOnboardingInfo.ts
+++ b/hooks/useOnboardingInfo.ts
@@ -22,16 +22,48 @@ function isValidStep(step: number): step is OnboardingStep {
   return step >= 1 && step <= 7;
 }
 
+// Type for tracking request state
+type RequestState = {
+  loading: boolean;
+  error: Error | null;
+  success: boolean;
+};
+
+// Initial request state
+const initialRequestState: RequestState = {
+  loading: false,
+  error: null,
+  success: false,
+};
+
 export function useOnboardingInfo() {
   const [onboardingInfo, setOnboardingInfo] = useState<OnboardingInfo | null>(null);
   const [currentStep, setCurrentStep] = useState<OnboardingStep>(ONBOARDING_STEPS.NAME);
   const router = useRouter();
-  const { setOnboardingComplete, onboardingComplete } = useUser();
+  const { setOnboardingComplete, onboardingComplete, userInfo, refreshUserInfo } = useUser();
+  
+  // Request states for all operations
+  const [fetchState, setFetchState] = useState<RequestState>({...initialRequestState});
+  const [updateState, setUpdateState] = useState<RequestState>({...initialRequestState});
+  const [nameSubmitState, setNameSubmitState] = useState<RequestState>({...initialRequestState});
+  const [collegeSubmitState, setCollegeSubmitState] = useState<RequestState>({...initialRequestState});
+  const [academicsSubmitState, setAcademicsSubmitState] = useState<RequestState>({...initialRequestState});
+  const [goalsSubmitState, setGoalsSubmitState] = useState<RequestState>({...initialRequestState});
+  const [kalypsoCompleteState, setKalypsoCompleteState] = useState<RequestState>({...initialRequestState});
+  const [referralCompleteState, setReferralCompleteState] = useState<RequestState>({...initialRequestState});
+
+  // Reset a request state
+  const resetRequestState = (stateSetter: React.Dispatch<React.SetStateAction<RequestState>>) => {
+    stateSetter({...initialRequestState});
+  };
 
   // Fetch initial onboarding info
   useEffect(() => {
     const fetchOnboardingInfo = async () => {
       try {
+        // Set loading state
+        setFetchState({ loading: true, error: null, success: false });
+        
         // If we already know onboarding is complete from Zustand store, redirect immediately
         if (onboardingComplete) {
           if (isMobileButNotIpad()) {
@@ -39,6 +71,7 @@ export function useOnboardingInfo() {
           } else {
             router.push('/home');
           }
+          setFetchState({ loading: false, error: null, success: true });
           return;
         }
 
@@ -55,6 +88,7 @@ export function useOnboardingInfo() {
           } else {
             router.push('/home');
           }
+          setFetchState({ loading: false, error: null, success: true });
           return;
         }
 
@@ -74,8 +108,17 @@ export function useOnboardingInfo() {
 
         // Set the step once we've determined the correct one
         setCurrentStep(targetStep);
+        
+        // Update request state to success
+        setFetchState({ loading: false, error: null, success: true });
       } catch (error) {
         console.error('Error fetching onboarding info:', error);
+        // Set error state
+        setFetchState({ 
+          loading: false, 
+          error: error instanceof Error ? error : new Error('Unknown error fetching onboarding info'),
+          success: false
+        });
       }
     };
 
@@ -85,6 +128,9 @@ export function useOnboardingInfo() {
   // Update onboarding info in the database
   const updateOnboardingInfo = async (updates: Partial<OnboardingInfo>) => {
     try {
+      // Set loading state
+      setUpdateState({ loading: true, error: null, success: false });
+      
       const response = await fetch('/api/user-info/onboarding', {
         method: 'PUT',
         headers: { 'Content-Type': 'application/json' },
@@ -100,16 +146,28 @@ export function useOnboardingInfo() {
       if (updates.currentStep && isValidStep(updates.currentStep)) {
         setCurrentStep(updates.currentStep);
       }
+      
+      // Set success state
+      setUpdateState({ loading: false, error: null, success: true });
 
       return updatedInfo;
     } catch (error) {
       console.error('[updateOnboardingInfo] Error:', error);
+      // Set error state
+      setUpdateState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error updating onboarding info'),
+        success: false
+      });
       throw error;
     }
   };
 
   const handleNameSubmit = async (firstName: string) => {
     try {
+      // Set loading state
+      setNameSubmitState({ loading: true, error: null, success: false });
+      
       // Force create a new user info record
       const response = await fetch("/api/user-info", {
         method: "POST",
@@ -129,9 +187,18 @@ export function useOnboardingInfo() {
         firstName,
         currentStep: ONBOARDING_STEPS.COLLEGE as OnboardingStep,
       });
+      
+      // Set success state
+      setNameSubmitState({ loading: false, error: null, success: true });
     } catch (error) {
       console.error("Error saving name:", error);
       toast.error("Failed to save your information");
+      // Set error state
+      setNameSubmitState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error saving name'),
+        success: false
+      });
     }
   };
 
@@ -141,13 +208,25 @@ export function useOnboardingInfo() {
     isCanadian: boolean;
   }) => {
     try {
+      // Set loading state
+      setCollegeSubmitState({ loading: true, error: null, success: false });
+      
       await updateOnboardingInfo({
         ...data,
         currentStep: ONBOARDING_STEPS.ACADEMICS as OnboardingStep,
       });
+      
+      // Set success state
+      setCollegeSubmitState({ loading: false, error: null, success: true });
     } catch (error) {
       console.error("Error saving college info:", error);
       toast.error("Failed to save your information");
+      // Set error state
+      setCollegeSubmitState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error saving college info'),
+        success: false
+      });
     }
   };
 
@@ -158,13 +237,25 @@ export function useOnboardingInfo() {
     mcatAttemptNumber: string;
   }) => {
     try {
+      // Set loading state
+      setAcademicsSubmitState({ loading: true, error: null, success: false });
+      
       await updateOnboardingInfo({
         ...data,
         currentStep: ONBOARDING_STEPS.GOALS as OnboardingStep,
       });
+      
+      // Set success state
+      setAcademicsSubmitState({ loading: false, error: null, success: true });
     } catch (error) {
       console.error("Error saving academic info:", error);
       toast.error("Failed to save your information");
+      // Set error state
+      setAcademicsSubmitState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error saving academic info'),
+        success: false
+      });
     }
   };
 
@@ -173,61 +264,173 @@ export function useOnboardingInfo() {
     targetMedSchool: string;
   }) => {
     try {
-      // Update database first
+      // Set loading state
+      setGoalsSubmitState({ loading: true, error: null, success: false });
+      
+      // Update database first - REMOVED setting onboardingComplete here
       await updateOnboardingInfo({
         ...data,
-        onboardingComplete: true
+        currentStep: ONBOARDING_STEPS.KALYPSO_DIALOGUE as OnboardingStep,
       });
 
-      // Update Zustand store state
-      setOnboardingComplete(true);
-
-      // Now redirect
-      if (isMobileButNotIpad()) {
-        router.push('/redirect');
-      } else {
-        router.push('/home');
-      }
+      // Continue to the next step without setting onboardingComplete
+      // Now redirect happens in the component based on current step
+      
+      // Set success state
+      setGoalsSubmitState({ loading: false, error: null, success: true });
     } catch (error) {
       console.error("[handleGoalsSubmit] Error:", error);
       toast.error("Failed to save your information");
+      // Set error state
+      setGoalsSubmitState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error saving goals'),
+        success: false
+      });
     }
   };
 
   const handleKalypsoComplete = async () => {
     try {
+      // Set loading state
+      setKalypsoCompleteState({ loading: true, error: null, success: false });
+      
       await updateOnboardingInfo({
         currentStep: ONBOARDING_STEPS.REFERRAL as OnboardingStep,
       });
+      
+      // Set success state
+      setKalypsoCompleteState({ loading: false, error: null, success: true });
     } catch (error) {
       console.error("Error completing Kalypso dialogue:", error);
       toast.error("Failed to proceed to next step");
+      // Set error state
+      setKalypsoCompleteState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error completing Kalypso dialogue'),
+        success: false
+      });
     }
   };
 
   const handleReferralComplete = async (skipReferral: boolean = false) => {
     try {
+      // Set loading state
+      setReferralCompleteState({ loading: true, error: null, success: false });
+      
+      console.log('[DEBUG][handleReferralComplete] Starting onboarding completion process');
+      
+      // First, validate that we have all required data
+      if (!onboardingInfo) {
+        const error = new Error("Cannot complete onboarding: No onboarding info exists");
+        console.error(error.message);
+        toast.error("Missing profile information. Please try again.");
+        setReferralCompleteState({ 
+          loading: false, 
+          error: error,
+          success: false
+        });
+        return false;
+      }
+      
+      // Validate that target score exists and is valid
+      if (!onboardingInfo.targetScore || onboardingInfo.targetScore <= 0) {
+        const error = new Error("Cannot complete onboarding: Invalid target score");
+        console.error(`${error.message}: ${onboardingInfo.targetScore}`);
+        toast.error("Please set a valid target score before completing onboarding.");
+        setReferralCompleteState({ 
+          loading: false, 
+          error: error,
+          success: false
+        });
+        return false;
+      }
+      
+      // Check other critical fields
+      if (!onboardingInfo.firstName || !onboardingInfo.college) {
+        const error = new Error("Cannot complete onboarding: Missing required personal information");
+        console.error(error.message);
+        toast.error("Please complete all required steps before continuing.");
+        setReferralCompleteState({ 
+          loading: false, 
+          error: error,
+          success: false
+        });
+        return false;
+      }
+      
+      // Now update with complete flag
+      console.log('[DEBUG][handleReferralComplete] Updating database with onboardingComplete: true');
       const updatedInfo = await updateOnboardingInfo({
         currentStep: ONBOARDING_STEPS.UNLOCK as OnboardingStep,
         onboardingComplete: true,
       });
 
-      // Redirect immediately after successful update
-      if (updatedInfo?.onboardingComplete) {
-        if (isMobileButNotIpad()) {
-          router.push('/redirect');
-        } else {
-          router.push('/home');
-        }
+      // Verify update was successful
+      if (!updatedInfo?.onboardingComplete) {
+        const error = new Error("[handleReferralComplete] Update successful but onboardingComplete not set");
+        console.error(error.message);
+        toast.error("There was a problem completing your profile. Please try again.");
+        setReferralCompleteState({ 
+          loading: false, 
+          error: error,
+          success: false
+        });
+        return false;
+      }
+      
+      console.log('[DEBUG][handleReferralComplete] Database update successful, onboardingComplete set to:', updatedInfo.onboardingComplete);
+      
+      // If all was successful, update the local state
+      setOnboardingComplete(true);
+      console.log('[DEBUG][handleReferralComplete] Local state updated with setOnboardingComplete(true)');
+      
+      // IMPROVEMENT: Add a full refreshUserInfo call to ensure complete synchronization
+      console.log('[DEBUG][handleReferralComplete] Performing full refreshUserInfo() for complete synchronization');
+      try {
+        await refreshUserInfo();
+        console.log('[DEBUG][handleReferralComplete] refreshUserInfo() completed successfully');
+      } catch (refreshError) {
+        console.error('[DEBUG][handleReferralComplete] Error during refreshUserInfo():', refreshError);
+        // We continue with the redirect even if refresh fails, as the database update was successful
+      }
+      
+      // Redirect based on device
+      console.log('[DEBUG][handleReferralComplete] Redirecting to:', isMobileButNotIpad() ? '/redirect' : '/home');
+      if (isMobileButNotIpad()) {
+        router.push('/redirect');
       } else {
-        console.error('[handleReferralComplete] Update successful but onboardingComplete not set');
+        router.push('/home');
       }
+      
+      // Set success state
+      setReferralCompleteState({ loading: false, error: null, success: true });
+      return true;
     } catch (error) {
       console.error("[handleReferralComplete] Error:", error);
-      toast.error("Failed to proceed to next step");
+      toast.error("Failed to complete your profile setup");
+      // Set error state
+      setReferralCompleteState({ 
+        loading: false, 
+        error: error instanceof Error ? error : new Error('Unknown error completing onboarding'),
+        success: false
+      });
+      return false;
     }
   };
 
+  // Function to check if any request is currently loading
+  const isLoading = (): boolean => {
+    return fetchState.loading || 
+           updateState.loading || 
+           nameSubmitState.loading || 
+           collegeSubmitState.loading || 
+           academicsSubmitState.loading || 
+           goalsSubmitState.loading || 
+           kalypsoCompleteState.loading || 
+           referralCompleteState.loading;
+  };
+
   return {
     onboardingInfo,
     updateOnboardingInfo,
@@ -238,6 +441,18 @@ export function useOnboardingInfo() {
     handleGoalsSubmit,
     handleKalypsoComplete,
     handleReferralComplete,
-    ONBOARDING_STEPS
+    ONBOARDING_STEPS,
+    // Request states
+    isLoading: isLoading(),
+    fetchState,
+    updateState,
+    nameSubmitState,
+    collegeSubmitState,
+    academicsSubmitState,
+    goalsSubmitState,
+    kalypsoCompleteState,
+    referralCompleteState,
+    // Utility
+    resetRequestState
   };
 } 
\ No newline at end of file
diff --git a/store/index.ts b/store/index.ts
deleted file mode 100644
index 8e8adb1872c497be8b2031834636aa3a762928ef..0000000000000000000000000000000000000000
--- a/store/index.ts
+++ /dev/null
@@ -1,127 +0,0 @@
-// Re-export all slice stores
-export { useAudioStore } from './slices/audioSlice';
-export { useUIStore } from './slices/uiSlice';
-export { useGameStore } from './slices/gameSlice';
-export { useUserStore } from './slices/userSlice';
-export { useVocabStore } from './slices/vocabSlice';
-
-// Re-export all types
-export * from './types';
-export type { ThemeType, WindowSize } from './slices/uiSlice';
-
-// For backward compatibility with existing code
-import { useAudioStore } from './slices/audioSlice';
-import { useUIStore } from './slices/uiSlice';
-import { useGameStore } from './slices/gameSlice';
-import { useUserStore } from './slices/userSlice';
-import { useVocabStore } from './slices/vocabSlice';
-
-// Flag to track global initialization
-let isStoreInitialized = false;
-
-type StoreUpdates = Record<string, any>;
-
-export const useStore = {
-  getState: () => ({
-    ...useAudioStore.getState(),
-    ...useUIStore.getState(),
-    ...useGameStore.getState(),
-    ...useUserStore.getState(),
-    ...useVocabStore.getState(),
-  }),
-  
-  setState: (updates: StoreUpdates) => {
-    // Determine which slice each update belongs to and apply accordingly
-    const audioKeys = new Set(Object.keys(useAudioStore.getState()));
-    const uiKeys = new Set(Object.keys(useUIStore.getState()));
-    const gameKeys = new Set(Object.keys(useGameStore.getState()));
-    const userKeys = new Set(Object.keys(useUserStore.getState()));
-    const vocabKeys = new Set(Object.keys(useVocabStore.getState()));
-    
-    // Extract updates for each slice
-    const audioUpdates: StoreUpdates = {};
-    const uiUpdates: StoreUpdates = {};
-    const gameUpdates: StoreUpdates = {};
-    const userUpdates: StoreUpdates = {};
-    const vocabUpdates: StoreUpdates = {};
-    
-    // Sort updates into appropriate slices
-    Object.entries(updates).forEach(([key, value]) => {
-      if (audioKeys.has(key)) {
-        audioUpdates[key] = value;
-      } else if (uiKeys.has(key)) {
-        uiUpdates[key] = value;
-      } else if (gameKeys.has(key)) {
-        gameUpdates[key] = value;
-      } else if (userKeys.has(key)) {
-        userUpdates[key] = value;
-      } else if (vocabKeys.has(key)) {
-        vocabUpdates[key] = value;
-      }
-    });
-    
-    // Apply updates to each slice
-    if (Object.keys(audioUpdates).length > 0) {
-      useAudioStore.setState(audioUpdates);
-    }
-    if (Object.keys(uiUpdates).length > 0) {
-      useUIStore.setState(uiUpdates);
-    }
-    if (Object.keys(gameUpdates).length > 0) {
-      useGameStore.setState(gameUpdates);
-    }
-    if (Object.keys(userUpdates).length > 0) {
-      useUserStore.setState(userUpdates);
-    }
-    if (Object.keys(vocabUpdates).length > 0) {
-      useVocabStore.setState(vocabUpdates);
-    }
-  },
-  
-  subscribe: (callback: (state: any, prevState: any) => void) => {
-    // Subscribe to all slice stores
-    const unsubAudio = useAudioStore.subscribe(callback);
-    const unsubUI = useUIStore.subscribe(callback);
-    const unsubGame = useGameStore.subscribe(callback);
-    const unsubUser = useUserStore.subscribe(callback);
-    const unsubVocab = useVocabStore.subscribe(callback);
-    
-    // Return a function to unsubscribe from all
-    return () => {
-      unsubAudio();
-      unsubUI();
-      unsubGame();
-      unsubUser();
-      unsubVocab();
-    };
-  }
-};
-
-// Export a function to initialize the store at the app level
-export const initializeGlobalStore = async (options?: { forceOnboarding?: boolean }): Promise<void> => {
-  if (typeof window !== 'undefined' && !isStoreInitialized) {
-    console.debug('[DEBUG][Store] Initializing global store from exported function');
-    try {
-      // Initialize audio context
-      await useAudioStore.getState().initializeAudioContext();
-      
-      // Initialize UI state
-      const savedTheme = localStorage.getItem('theme');
-      if (savedTheme && ['cyberSpace', 'sakuraTrees', 'sunsetCity', 'mykonosBlue'].includes(savedTheme)) {
-        useUIStore.getState().setTheme(savedTheme as any);
-      }
-      
-      // Process debug options
-      if (options?.forceOnboarding) {
-        console.debug('[DEBUG][Store] DEBUG MODE: Forcing onboardingComplete to true for testing');
-        useUserStore.getState().setOnboardingComplete(true);
-      }
-      
-      isStoreInitialized = true;
-      console.debug('[DEBUG][Store] Store initialization complete');
-    } catch (error) {
-      console.error('[DEBUG][Store] Store initialization failed:', error);
-      throw error;
-    }
-  }
-}; 
\ No newline at end of file
diff --git a/store/selectors.ts b/store/selectors.ts
index fbeb875883ff68209558b34ea6f41890f0da7ae5..cc599cbee4507950afc476dfaa08c86930d04aec 100644
--- a/store/selectors.ts
+++ b/store/selectors.ts
@@ -40,7 +40,7 @@ export const useUser = () => {
   const studyPreferences = useUserStore((state) => state.studyPreferences)
   const interfaceSettings = useUserStore((state) => state.interfaceSettings)
   const tutorialProgress = useUserStore((state) => state.tutorialProgress)
-  const onboardingComplete = useUserStore((state) => state.onboardingComplete)
+  const onboardingComplete = useUserStore((state) => state.userInfo?.onboardingInfo?.onboardingComplete ?? false)
   const lastVisitedRoute = useUserStore((state) => state.lastVisitedRoute)
   
   // Profile actions
diff --git a/store/slices/userSlice.ts b/store/slices/userSlice.ts
index 0a53e749246881204b699b72b1519c0c0d207061..1698ea72e5af158bde027a9e4240846f7f063a76 100644
--- a/store/slices/userSlice.ts
+++ b/store/slices/userSlice.ts
@@ -13,6 +13,14 @@ const isWithin14Days = (date: Date): boolean => {
 };
 
 //========================= Types ===============================
+/**
+ * Options for batch updating profile properties
+ */
+interface BatchUpdateOptions {
+  showToast?: boolean;
+  rollbackOnError?: boolean;
+}
+
 interface UserProfile {
   userId?: string;
   firstName?: string;
@@ -33,14 +41,12 @@ interface UserProfile {
     completedRoutes?: string[];
   };
   completedSteps?: string[];
-  onboardingComplete?: boolean;
   lastVisitedRoute?: string;
 }
 
 interface UserState {
   // Version tracking
   version: number;
-  isHydrated: boolean;
   
   // Profile state
   profile: UserProfile | null;
@@ -59,7 +65,6 @@ interface UserState {
     currentStep: number;
     completedRoutes: string[];
   };
-  onboardingComplete: boolean;
   lastVisitedRoute: string;
   
   // User info state
@@ -94,6 +99,9 @@ interface UserActions {
   // Stats actions
   updateCoins: (amount: number) => Promise<void>;
   updateCoinsDisplay: (newAmount: number) => void;
+  
+  // Batch update function
+  batchUpdateProfile: (updates: Partial<UserProfile & { onboardingInfo?: Partial<OnboardingInfo> }>, options?: BatchUpdateOptions) => Promise<UserProfile | null>;
 }
 
 //========================= Store Creation ===============================
@@ -101,7 +109,6 @@ export const useUserStore = create<UserState & UserActions>()(
   devtools((set, get) => ({
     // Version tracking
     version: 1,
-    isHydrated: false,
     
     // Profile state
     profile: null,
@@ -120,7 +127,6 @@ export const useUserStore = create<UserState & UserActions>()(
       currentStep: 0,
       completedRoutes: []
     },
-    onboardingComplete: false,
     lastVisitedRoute: '/',
     
     // User info state
@@ -186,7 +192,6 @@ export const useUserStore = create<UserState & UserActions>()(
           ...(updatedProfileFromServer.studyPreferences && { studyPreferences: updatedProfileFromServer.studyPreferences }),
           ...(updatedProfileFromServer.interfaceSettings && { interfaceSettings: updatedProfileFromServer.interfaceSettings }),
           ...(updatedProfileFromServer.tutorialProgress && { tutorialProgress: updatedProfileFromServer.tutorialProgress }),
-          ...(updatedProfileFromServer.onboardingComplete !== undefined && { onboardingComplete: updatedProfileFromServer.onboardingComplete }),
           ...(updatedProfileFromServer.lastVisitedRoute && { lastVisitedRoute: updatedProfileFromServer.lastVisitedRoute }),
           isProfileComplete: isProfileComplete(updatedProfileFromServer)
         });
@@ -200,17 +205,10 @@ export const useUserStore = create<UserState & UserActions>()(
     },
     
     setCompletedSteps: (steps) => {
-      set({ completedSteps: steps });
-      set({ isProfileComplete: steps.length >= 3 });
+      console.log('[DEBUG][userSlice] setCompletedSteps called with', steps.length, 'steps');
       
-      // Also update the profile object for consistency
-      const profile = get().profile;
-      if (profile) {
-        set({ profile: { ...profile, completedSteps: steps } });
-      }
-      
-      // Persist to backend if possible
-      get().updateProfile({ completedSteps: steps });
+      // Use the new batch update function instead of multiple set calls
+      get().batchUpdateProfile({ completedSteps: steps });
     },
     
     addCompletedStep: (step) => {
@@ -277,16 +275,80 @@ export const useUserStore = create<UserState & UserActions>()(
     },
     
     setOnboardingComplete: (completed) => {
-      set({ onboardingComplete: completed });
+      console.log('[DEBUG][userSlice] setOnboardingComplete called with value:', completed);
       
-      // Also update the profile object for consistency
-      const profile = get().profile;
-      if (profile) {
-        set({ profile: { ...profile, onboardingComplete: completed } });
+      // Get the current userInfo state
+      const { userInfo } = get();
+      
+      if (!userInfo) {
+        console.error('Cannot set onboardingComplete: No user info available');
+        return;
       }
       
-      // Persist to backend if possible
-      get().updateProfile({ onboardingComplete: completed });
+      // Create a typed version of onboardingInfo to ensure all required fields are present
+      const currentOnboardingInfo = userInfo.onboardingInfo || {
+        currentStep: 0,
+        onboardingComplete: false,
+        firstName: null,
+        college: null,
+        isNonTraditional: null,
+        isCanadian: null,
+        gpa: null,
+        currentMcatScore: null,
+        hasNotTakenMCAT: null,
+        mcatAttemptNumber: null,
+        targetMedSchool: null,
+        targetScore: null,
+        referralEmail: null
+      };
+      
+      // Create updated userInfo with the new onboardingComplete value
+      const updatedUserInfo = {
+        ...userInfo,
+        onboardingInfo: {
+          ...currentOnboardingInfo,
+          onboardingComplete: completed
+        }
+      };
+      
+      // Store original state for potential rollback
+      const originalState = {
+        userInfo: userInfo
+      };
+      
+      console.log('[DEBUG][userSlice] Updating local state with onboardingComplete:', completed);
+      
+      // Update only the userInfo property in a single atomic operation
+      set({ userInfo: updatedUserInfo });
+      
+      // Persist to backend with error handling and rollback capability
+      (async () => {
+        try {
+          console.log('[DEBUG][userSlice] Persisting onboardingComplete to backend');
+          const response = await fetch('/api/user-info/profile', {
+            method: 'PATCH',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify({ 
+              onboardingInfo: updatedUserInfo.onboardingInfo 
+            })
+          });
+          
+          if (!response.ok) {
+            throw new Error(`Backend update failed: ${response.status} ${response.statusText}`);
+          }
+          
+          const responseData = await response.json();
+          console.log('[DEBUG][userSlice] Backend update successful:', responseData);
+        } catch (error) {
+          console.error('[DEBUG][userSlice] Error updating onboardingComplete on backend:', error);
+          // Roll back to original state if backend update fails
+          console.log('[DEBUG][userSlice] Rolling back to original state');
+          set({ userInfo: originalState.userInfo });
+          // Show error to user
+          // We'd ideally use a toast here, but to avoid circular dependencies
+          // just log to console for now
+        }
+      })();
     },
     
     setLastVisitedRoute: (route) => {
@@ -304,45 +366,36 @@ export const useUserStore = create<UserState & UserActions>()(
     
     refreshUserInfo: async () => {
       try {
-        // Only set loading if not already loading
-        const currentState = get();
-        if (!currentState.statsLoading && !currentState.profileLoading) {
-          set({ statsLoading: true, profileLoading: true, error: null });
-        }
-
-        // Add loading timeout
-        const loadingTimeout = setTimeout(() => {
-          const state = get();
-          if (state.statsLoading || state.profileLoading) {
-            set({ 
-              statsLoading: false,
-              profileLoading: false,
-              error: 'Loading timeout - please try again'
-            });
-          }
-        }, 10000);
-
+        // Set detailed loading states
+        set({ 
+          profileLoading: true, 
+          statsLoading: true, 
+          error: null 
+        });
+        
+        // Track fetch start time for performance monitoring
+        const fetchStartTime = performance.now();
+        
         // Batch all fetch requests together
         const [userInfoResponse, profileResponse] = await Promise.all([
           fetch('/api/user-info'),
           fetch('/api/user-info/profile')
         ]);
 
-        clearTimeout(loadingTimeout);
+        // Handle failed user info response
+        if (!userInfoResponse.ok) {
+          throw new Error(`Failed to fetch user info: ${userInfoResponse.status} ${userInfoResponse.statusText}`);
+        }
 
-        if (!userInfoResponse.ok) throw new Error('Failed to fetch user info');
         const userInfo = await userInfoResponse.json();
         
         // Check if user is in 14-day free trial period
         const isNewUserTrial = userInfo.createdAt ? isWithin14Days(new Date(userInfo.createdAt)) : false;
 
-        // Prepare single state update with only changed values
+        // Prepare atomic state update with only changed values
         const updates: Partial<UserState> = {
           userInfo,
-          statsLoading: false,
-          profileLoading: false,
           error: null,
-          isHydrated: true,
           version: CURRENT_VERSION
         };
 
@@ -365,33 +418,7 @@ export const useUserStore = create<UserState & UserActions>()(
           updates.isSubscribed = newSubStatus;
         }
 
-        // IMPORTANT: Check onboarding status from userInfo.onboardingInfo
-        if (userInfo.onboardingInfo && typeof userInfo.onboardingInfo === 'object') {
-          // Check if targetScore exists (main branch logic)
-          const targetScore = userInfo.onboardingInfo.targetScore;
-          const isOnboardingComplete = targetScore !== undefined && 
-                                targetScore !== null && 
-                                targetScore > 0;
-          
-          // Set onboardingComplete based on targetScore criteria to match main branch
-          if (isOnboardingComplete !== get().onboardingComplete) {
-            // Apply this update immediately and separately from the batch update
-            set({ onboardingComplete: isOnboardingComplete });
-            
-            // Remove from batch updates to avoid overwriting
-            delete updates.onboardingComplete;
-            
-            // Sync with database if there's a mismatch
-            const dbOnboardingComplete = userInfo.onboardingInfo.onboardingComplete === true;
-            if (dbOnboardingComplete !== isOnboardingComplete) {
-              // Queue an update to sync the database value
-              setTimeout(() => {
-                get().updateProfile({ onboardingComplete: isOnboardingComplete });
-              }, 0);
-            }
-          }
-        }
-
+        // Handle profile data if available
         if (profileResponse.ok) {
           const profileData = await profileResponse.json();
           const currentProfile = get().profile;
@@ -417,19 +444,36 @@ export const useUserStore = create<UserState & UserActions>()(
               isProfileComplete: (profileData.completedSteps || []).length >= 3
             });
           }
+        } else {
+          console.warn(`[UserStore] Profile fetch failed: ${profileResponse.status} ${profileResponse.statusText}`);
         }
-
-        // Apply all updates in a single state update
+        
+        // Check if we're about to set onboardingComplete at root level (bug prevention)
+        if ('onboardingComplete' in updates) {
+          // @ts-ignore - Intentionally modifying object to prevent a bug
+          delete updates.onboardingComplete;
+        }
+        
+        // Complete the loading states
+        updates.statsLoading = false;
+        updates.profileLoading = false;
+        
+        // Finally, apply all updates in a single atomic state update
         set(updates);
-
+        
+        return userInfo;
       } catch (error) {
-        console.error('Error in refreshUserInfo:', error);
+        console.error('[UserStore] Error in refreshUserInfo:', error);
+        
+        // Set detailed error state
         set({ 
           error: error instanceof Error ? error.message : 'Failed to refresh user info',
           statsLoading: false,
-          profileLoading: false,
-          isHydrated: false
+          profileLoading: false
         });
+        
+        // Re-throw to allow handling by callers
+        throw error;
       }
     },
     
@@ -455,6 +499,158 @@ export const useUserStore = create<UserState & UserActions>()(
     
     updateCoinsDisplay: (newAmount) => {
       set({ coins: newAmount });
+    },
+
+    /**
+     * Batch update multiple profile properties in a single operation
+     * @param updates Object containing all properties to update
+     * @param options Optional settings for the update operation
+     */
+    batchUpdateProfile: async (
+      updates: Partial<UserProfile & { onboardingInfo?: Partial<OnboardingInfo> }>, 
+      options: BatchUpdateOptions = { showToast: true, rollbackOnError: true }
+    ): Promise<UserProfile | null> => {
+      console.log('[DEBUG][userSlice] batchUpdateProfile called with updates:', Object.keys(updates));
+      
+      // Get current state for potential rollback
+      const currentState = {
+        profile: get().profile,
+        completedSteps: get().completedSteps,
+        studyPreferences: get().studyPreferences,
+        interfaceSettings: get().interfaceSettings,
+        tutorialProgress: get().tutorialProgress,
+        lastVisitedRoute: get().lastVisitedRoute,
+        userInfo: get().userInfo
+      };
+      
+      try {
+        // First update local state
+        const updatedState: Partial<UserState> = {};
+        
+        // Process profile updates
+        if (updates.profile) {
+          updatedState.profile = updates.profile;
+        }
+        
+        // Process completedSteps updates
+        if (updates.completedSteps) {
+          updatedState.completedSteps = updates.completedSteps;
+          updatedState.isProfileComplete = updates.completedSteps.length >= 3;
+          
+          // Also update in profile if it exists
+          if (currentState.profile && !updates.profile) {
+            updatedState.profile = { 
+              ...currentState.profile, 
+              completedSteps: updates.completedSteps 
+            };
+          }
+        }
+        
+        // Process studyPreferences updates
+        if (updates.studyPreferences) {
+          updatedState.studyPreferences = { 
+            ...currentState.studyPreferences, 
+            ...updates.studyPreferences 
+          };
+          
+          // Also update in profile if it exists
+          if (currentState.profile && !updates.profile) {
+            updatedState.profile = { 
+              ...updatedState.profile || currentState.profile, 
+              studyPreferences: updatedState.studyPreferences 
+            };
+          }
+        }
+        
+        // Process interfaceSettings updates
+        if (updates.interfaceSettings) {
+          updatedState.interfaceSettings = { 
+            ...currentState.interfaceSettings, 
+            ...updates.interfaceSettings 
+          };
+          
+          // Also update in profile if it exists
+          if (currentState.profile && !updates.profile) {
+            updatedState.profile = { 
+              ...updatedState.profile || currentState.profile, 
+              interfaceSettings: updatedState.interfaceSettings 
+            };
+          }
+        }
+        
+        // Process tutorialProgress updates
+        if (updates.tutorialProgress) {
+          updatedState.tutorialProgress = { 
+            ...currentState.tutorialProgress, 
+            ...updates.tutorialProgress 
+          };
+          
+          // Also update in profile if it exists
+          if (currentState.profile && !updates.profile) {
+            updatedState.profile = { 
+              ...updatedState.profile || currentState.profile, 
+              tutorialProgress: updatedState.tutorialProgress 
+            };
+          }
+        }
+        
+        // Process lastVisitedRoute updates
+        if (updates.lastVisitedRoute) {
+          updatedState.lastVisitedRoute = updates.lastVisitedRoute;
+          
+          // Also update in profile if it exists
+          if (currentState.profile && !updates.profile) {
+            updatedState.profile = { 
+              ...updatedState.profile || currentState.profile, 
+              lastVisitedRoute: updates.lastVisitedRoute 
+            };
+          }
+        }
+        
+        // Process onboardingInfo updates
+        if (updates.onboardingInfo && currentState.userInfo) {
+          updatedState.userInfo = {
+            ...currentState.userInfo,
+            onboardingInfo: {
+              ...currentState.userInfo.onboardingInfo || {},
+              ...updates.onboardingInfo
+            }
+          };
+        }
+        
+        console.log('[DEBUG][userSlice] Applying batch updates to local state:', Object.keys(updatedState));
+        
+        // Apply all updates in a single atomic operation
+        set(updatedState);
+        
+        // Then persist to backend
+        console.log('[DEBUG][userSlice] Persisting batch updates to backend');
+        const response = await fetch('/api/user-info/profile', {
+          method: 'PATCH',
+          headers: { 'Content-Type': 'application/json' },
+          body: JSON.stringify(updates)
+        });
+        
+        if (!response.ok) {
+          throw new Error(`Backend update failed: ${response.status} ${response.statusText}`);
+        }
+        
+        const responseData = await response.json();
+        console.log('[DEBUG][userSlice] Backend batch update successful:', responseData);
+        
+        return responseData;
+      } catch (error) {
+        console.error('[DEBUG][userSlice] Error in batchUpdateProfile:', error);
+        
+        // Roll back to original state if specified
+        if (options.rollbackOnError) {
+          console.log('[DEBUG][userSlice] Rolling back to original state');
+          set(currentState);
+        }
+        
+        // Return the error to allow callers to handle it
+        throw error;
+      }
     }
   }))
 );
@@ -655,104 +851,5 @@ const isProfileComplete = (profile: UserProfile | null): boolean => {
   );
 };
 
-// State update utility with optimistic updates and rollback
-const updateState = async (
-  set: (state: Partial<UserState> | ((state: UserState) => Partial<UserState>)) => void,
-  get: () => UserState,
-  updates: Partial<UserState>,
-  options: { sync?: boolean } = {}
-) => {
-  try {
-    // Store previous state for rollback
-    const previousState = get();
-    
-    // Optimistically update local state
-    set((state) => ({
-      ...state,
-      ...updates,
-      error: null
-    }));
-
-    // If sync is requested, update database
-    if (options.sync) {
-      try {
-        const response = await fetch('/api/user-info', {
-          method: 'PATCH',
-          headers: { 'Content-Type': 'application/json' },
-          body: JSON.stringify(updates)
-        });
-
-        if (!response.ok) {
-          throw new Error('Failed to sync with database');
-        }
-
-        // Update local state with server response
-        const serverState = await response.json();
-        set((state) => ({
-          ...state,
-          ...serverState
-        }));
-      } catch (error) {
-        // Rollback on sync failure
-        console.error('Sync failed, rolling back:', error);
-        set(previousState);
-        throw error;
-      }
-    }
-  } catch (error) {
-    set((state) => ({
-      ...state,
-      error: error instanceof Error ? error.message : 'Update failed'
-    }));
-    throw error;
-  }
-};
-
 // Constants for state management
 const CURRENT_VERSION = 1;
-
-const initialState: UserState = {
-  // Version tracking
-  version: CURRENT_VERSION,
-  isHydrated: false,
-  
-  // Profile state
-  profile: null,
-  profileLoading: true,
-  isProfileComplete: false,
-  completedSteps: [],
-  studyPreferences: {
-    dailyGoal: 30,
-    reminderTime: '09:00'
-  },
-  interfaceSettings: {
-    darkMode: false,
-    fontSize: 'medium'
-  },
-  tutorialProgress: {
-    currentStep: 0,
-    completedRoutes: []
-  },
-  onboardingComplete: false,
-  lastVisitedRoute: '/',
-  
-  // User info state
-  userInfo: null,
-  isSubscribed: false,
-  
-  // Stats state
-  coins: 0,
-  statsLoading: false,
-  error: null
-};
-
-// Hydration check utility
-const isStateHydrated = (state: UserState): boolean => {
-  return state.isHydrated && state.version === CURRENT_VERSION;
-};
-
-// State reset utility
-const resetState = (): UserState => ({
-  ...initialState,
-  version: CURRENT_VERSION
-});
