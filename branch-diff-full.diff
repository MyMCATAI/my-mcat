diff --git a/README_Docs/optimization/ankiclinic-loading.md b/README_Docs/optimization/ankiclinic-loading.md
new file mode 100644
index 0000000000000000000000000000000000000000..3cf196203215311ec1c6d1060f2a29ef7fe4e10e
--- /dev/null
+++ b/README_Docs/optimization/ankiclinic-loading.md
@@ -0,0 +1,147 @@
+# AnkiClinic Loading Performance Optimizations
+
+This document outlines the optimizations implemented to improve the loading performance of the AnkiClinic page.
+
+## Problem Statement
+
+The AnkiClinic page was experiencing significant loading delays when navigating from `/home` to `/ankiclinic`. This was due to:
+
+1. **Lazy Loading Everything**: All components were dynamically imported, causing rendering delays.
+2. **No Preloading**: The AnkiClinic page was not preloaded until navigation begins.
+3. **Heavy Initial Load**: The page attempted to load all data and initialize simultaneously.
+4. **`ssr: false` on All Components**: This setting prevented server-side rendering, increasing client-side workload.
+
+## Implemented Solutions
+
+### 1. Component Preloading
+
+Created a dedicated preloading utility (`preload.ts`) that:
+- Preloads core components immediately
+- Preloads secondary components in sequence
+- Preloads audio assets in parallel
+
+```typescript
+// app/(dashboard)/(routes)/ankiclinic/preload.ts
+export const preloadAnkiClinic = async () => {
+  // Start preloading core components immediately
+  const corePromise = preloadCoreComponents();
+  
+  // Start preloading audio assets immediately
+  const audioPromise = preloadAudioAssets();
+  
+  // Wait for core components to load before loading secondary components
+  await corePromise;
+  
+  // Start preloading secondary components
+  const secondaryPromise = preloadSecondaryComponents();
+  
+  // Wait for all preloading to complete
+  await Promise.all([audioPromise, secondaryPromise]);
+};
+```
+
+### 2. Optimized Dynamic Imports
+
+Modified the AnkiClinic page to:
+- Import core components directly (no dynamic import)
+- Only use dynamic imports for truly heavy or rarely used components
+
+```typescript
+// Direct imports for core components
+import ResourcesMenu from './ResourcesMenu';
+import OfficeContainer from './OfficeContainer';
+
+// Dynamic imports only for secondary components
+const WelcomeDialog = dynamic(() => import('./WelcomeDialog'), {
+  ssr: false
+});
+```
+
+### 3. Improved Loading State
+
+Enhanced the loading experience with:
+- A better loading indicator
+- Early return for loading state
+- Delayed state updates to prioritize rendering
+
+```typescript
+// Render with early return for loading state
+if (!isMountedRef.current || isLoading) {
+  return <LoadingClinic />;
+}
+```
+
+### 4. Audio Initialization Optimization
+
+Improved audio loading reliability with:
+- Immediate initialization on mount
+- Retry mechanism for failed audio loading
+- Separate effects for different audio states
+
+```typescript
+// Initialize ambient sound as soon as possible
+useEffect(() => {
+  if (!isMountedRef.current) return;
+  
+  // Initialize ambient sound immediately when component mounts
+  const timer = setTimeout(() => {
+    if (!isFlashcardsOpen) {
+      console.log('[DEBUG] Initializing ambient sound on mount');
+      initializeAmbientSound();
+    }
+  }, 200);
+  
+  return () => {
+    clearTimeout(timer);
+    stopAllAudio();
+  };
+}, [initializeAmbientSound, isFlashcardsOpen, stopAllAudio]);
+```
+
+### 5. Proactive Preloading from Home Page
+
+Enhanced the FloatingButton component to:
+- Preload AnkiClinic when the home page loads
+- Preload on hover for immediate response
+- Show a loading indicator during navigation
+
+```typescript
+// Preload the AnkiClinic page when component mounts
+useEffect(() => {
+  // Only preload if we're on the home page and haven't preloaded yet
+  if (currentPage === 'home' && !hasPreloadedRef.current) {
+    // Use setTimeout to defer preloading until after initial render
+    const timer = setTimeout(() => {
+      console.log("[FloatingButton] Starting AnkiClinic preload sequence");
+      
+      // First, preload the route using the router instance
+      router.prefetch('/ankiclinic');
+      
+      // Then, preload the components and assets
+      preloadAnkiClinic();
+      
+      // Mark as preloaded
+      hasPreloadedRef.current = true;
+    }, 1000);
+  }
+}, [currentPage, router]);
+```
+
+## Results
+
+These optimizations significantly improve the loading experience:
+
+1. **Faster Initial Render**: Core components load immediately
+2. **Smoother Audio Transitions**: Audio initializes reliably
+3. **Reduced Perceived Delay**: Loading indicator provides immediate feedback
+4. **Proactive Loading**: Components are preloaded before navigation begins
+
+## Future Improvements
+
+Potential further optimizations:
+
+1. **Server-Side Rendering**: Consider enabling SSR for more components
+2. **Code Splitting**: Further optimize which components are dynamically imported
+3. **Asset Preloading**: Implement image preloading for critical assets
+4. **State Management**: Optimize Zustand store initialization
+5. **Caching Strategy**: Implement more aggressive caching for API responses 
\ No newline at end of file
diff --git a/README_Docs/tasks/user-dennis/tasks.md b/README_Docs/tasks/user-dennis/tasks.md
index 04a6402469d3153bb5bd6d0a2e55ea3db68274c2..f886c8c2ad18e23b02e344341aea754454094a89 100644
--- a/README_Docs/tasks/user-dennis/tasks.md
+++ b/README_Docs/tasks/user-dennis/tasks.md
@@ -1,89 +1,26 @@
 TODO: 
 
 
-## Zustand State
-1. Navigation/Route State
-```
-{
-  currentRoute: string
-  previousRoute: string | null
-  activeTab: string
-  isFlashcardsOpen: boolean
-  isMarketplaceOpen: boolean
-  isTutorialOpen: boolean
-}
-```
-2. Audio State
-```
-{
-  volume: {
-    sfx: number
-    music: number
-    voice: number
-    effects: number
-  }
-  isPlaying: boolean
-  currentSong: string | null
-  activeLoops: Set<string>
-  routeSpecificSounds: {
-    doctorsoffice: {
-      ambient: string
-      isFlashcardsOpen: boolean
-    }
-    // other routes...
-  }
-}
-```
-3. User Profile State
-```
-{
-  userInfo: {
-    id: string
-    level: number
-    score: number
-    isSubscribed: boolean
-    unlocks: string[]
-    streak: number
-  }
-  activities: Activity[]
-  studyProgress: {
-    correctCount: number
-    wrongCount: number
-    testScore: number
-  }
-}
-```
-4. UI State
-```
-{
-  modals: {
-    welcomeDialog: boolean
-    referralModal: boolean
-    afterTestDialog: boolean
-    streakPopup: boolean
-  }
-  theme: {
-    current: string
-    isDark: boolean
-  }
-  loading: {
-    isLoading: boolean
-    loadingMessage: string | null
-  }
-}
+## Cursor Notes
+
+#### Prompts
+` Do not apply code changes, just analyze the issue and respond to the question`
+
+#### Add new branch to worktree
+add new branch for Cursor to compare: 
+`git worktree add localstate-compare`
+
+remove it before pushing back up 
+`git worktree remove localstate-compare`
+
+#### Create diff file for Cursor
+
+To create a detailed diff against `main` with context:
 ```
-5. Game Activity State
+git diff --full-index main -- > branch-diff-full.diff
 ```
-{
-  doctorsOffice: {
-    activeRooms: Set<string>
-    userLevel: string
-    patientsPerDay: number
-    clinicCostPerDay: number
-    isGameInProgress: boolean
-    currentUserTestId: string | null
-  }
-  // other game states...
-}
 
-```
\ No newline at end of file
+To feed the diff back into Cursor:
+1. Create the diff file
+2. Open the diff file in Cursor
+3. Ask Cursor to analyze the changes
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/ankiclinic/FlashcardsDialog.tsx b/app/(dashboard)/(routes)/ankiclinic/FlashcardsDialog.tsx
index 02aee1fef6e2f223e107b52698faf4f4cfe03bb6..6501ec7ae2f6de5fe3f05a160c4691277a9b972c 100644
--- a/app/(dashboard)/(routes)/ankiclinic/FlashcardsDialog.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/FlashcardsDialog.tsx
@@ -4,6 +4,8 @@ import {
   DialogContent,
   DialogHeader,
   DialogTitle,
+  DialogDescription,
+  DialogFooter
 } from '@/components/ui/dialog';
 import { ScrollArea } from '@/components/ui/scroll-area';
 import FlashcardDeck, { Flashcard } from './FlashcardDeck';
@@ -21,6 +23,7 @@ import { roomToSubjectMap } from './constants';
 import ChatBot from '@/components/chatbot/ChatBotFlashcard';
 import { cleanQuestion, cleanAnswer } from './utils/testUtils';
 import DownvoteFeedback from '@/components/DownvoteFeedback';
+import { useGame } from "@/store/selectors";
 // import Interruption from './Interruption';
 
 interface WrongCard {
@@ -66,8 +69,11 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
   onMCQAnswer,
   setTotalMCQQuestions,
 }, ref) => {
+  // Get the store's actions
+  const { setCorrectCount: storeSetCorrectCount, setWrongCount: storeSetWrongCount, correctCount: storeCorrectCount } = useGame();
+  
   const [wrongCards, setWrongCards] = useState<WrongCard[]>([]);
-  const [correctCount, setCorrectCount] = useState(0);
+  const [localCorrectCount, setLocalCorrectCount] = useState(0);
   const [showPlusOne, setShowPlusOne] = useState(false);
   const [streak, setStreak] = useState(0);
   const [encouragement, setEncouragement] = useState('');
@@ -76,6 +82,7 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
   // const audioRef = useRef<HTMLAudioElement | null>(null);
   const [currentQuestion, setCurrentQuestion] = useState<Flashcard | null>(null);
   const [currentQuestionContext, setCurrentQuestionContext] = useState<QuestionContext | null>(null);
+  const [isAnswerRevealed, setIsAnswerRevealed] = useState(false);
   const chatbotRef = useRef<{
     sendMessage: (message: string) => void;
   }>({ sendMessage: () => {} });
@@ -103,48 +110,29 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
     }
   });
 
-  const getRandomEncouragement = (currentStreak: number) => {
-    const messages = [
-      'Amazing!',
-      'Well done!',
-      'Excellent!',
-      'Keep it up!',
-      'Fantastic!',
-      'Brilliant!'
-    ];
-
-    let message = messages[Math.floor(Math.random() * messages.length)];
-    
-    if (currentStreak >= 3) {
-      message += ` ${currentStreak} in a row! 🔥`;
-    }
-    
-    return message;
-  };
+  const [showChat, setShowChat] = useState(false);
 
-  const handleWrongCard = (question: string, answer: string) => {
-    const newWrongCard: WrongCard = {
+  const handleWrongAnswer = (question: string, correctAnswer: string) => {
+    const newWrongCard = {
       question,
-      answer,
-      timestamp: new Date().toLocaleTimeString()
+      answer: correctAnswer,
+      timestamp: new Date().toISOString(),
     };
     
-    api.start({
-      from: { x: -100 },
-      to: { x: 0 },
-      config: {
-        mass: 1,
-        tension: 180,
-        friction: 12
-      }
-    });
-    
     setWrongCards(prev => [newWrongCard, ...prev]);
+    // Update the store's wrong count
+    storeSetWrongCount(wrongCards.length + 1);
     setStreak(0);
   };
 
   const handleCorrectAnswer = () => {
-    setCorrectCount(prev => prev + 1);
+    // Update local state for UI
+    setLocalCorrectCount(prev => {
+      const newCount = prev + 1;
+      // Don't update store state directly here - will do it in useEffect
+      return newCount;
+    });
+    
     setShowPlusOne(true);
     
     const newStreak = streak + 1;
@@ -158,102 +146,126 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
     }
   };
 
+  // Update store state when localCorrectCount changes
+  useEffect(() => {
+    // Update store state
+    storeSetCorrectCount(localCorrectCount);
+  }, [localCorrectCount, storeSetCorrectCount]);
+
   const handleOpenChange = (open: boolean) => {
+    console.log(`[FlashcardsDialog] handleOpenChange called with open=${open}`);
     setShowChat(false);
+    
+    // If we're closing the dialog, ensure isLoading is false to allow audio transition
+    if (!open && isLoading) {
+      console.log(`[FlashcardsDialog] Setting isLoading to false to ensure audio transition`);
+      setIsLoading(false);
+    }
+    
+    // Make sure we're updating both the local component state and the global state
+    console.log(`[FlashcardsDialog] Calling onOpenChange(${open})`);
     onOpenChange(open);
+    
+    // If we're closing the dialog, also reset the flashcardRoomId in the parent component
+    if (!open) {
+      console.log(`[FlashcardsDialog] Dialog is closing`);
+      // We don't need to do anything else here - the parent component will handle
+      // the audio transition when isFlashcardsOpen changes
+    } else {
+      console.log(`[FlashcardsDialog] Dialog is opening for roomId=${roomId}`);
+    }
   };
 
-  // const handleInterruption = () => {
-  //   setShowInterruption(true);
-  // };
-
-  // const handleKalypsoClick = () => {
-  //   if (audioRef.current) {
-  //     audioRef.current.pause();
-  //     audioRef.current = null;
-  //     setIsTypingComplete(false);
-  //     setShowInterruption(false);
-  //   }
-  // };
-
   const handleClose = useCallback(() => {
     onOpenChange(false);
     if (roomId === 'WaitingRoom0') {
       return;
     }
-    if (correctCount > 0) {
+    if (localCorrectCount > 0) {
+      // Create a new Set by filtering out the current roomId
       const newActiveRooms = new Set([...activeRooms].filter(room => room !== roomId));
+      
+      // Update the activeRooms in the store
+      setActiveRooms(newActiveRooms);
+      
+      // If all rooms are completed, call handleCompleteAllRoom
       if (newActiveRooms.size === 0) {
         handleCompleteAllRoom();
       }
-      setActiveRooms(newActiveRooms);
     }
-  }, [roomId, setActiveRooms, onOpenChange, correctCount]);
+  }, [roomId, setActiveRooms, onOpenChange, localCorrectCount, activeRooms, handleCompleteAllRoom]);
 
   const handleDownvote = () => {
     setIsFeedbackOpen(true);
   };
 
-  const [showChat, setShowChat] = useState(false);
+  const handleHint = () => {
+    if (currentQuestion) {
+      setShowChat(true);
+      setIsAnswerRevealed(true);
+      const cleanedQuestion = cleanQuestion(currentQuestion.questionContent);
+      
+      // Determine the correct answer based on question type
+      let correctAnswer = '';
+      if (currentQuestion.questionType === 'normal' && currentQuestion.questionOptions?.length > 0) {
+        correctAnswer = currentQuestion.questionOptions[0];
+      } else {
+        correctAnswer = cleanAnswer(currentQuestion.questionContent);
+      }
+      
+      const cleanedAnswer = cleanAnswer(correctAnswer);
+      
+      const message = `I need help understanding this question: "${cleanedQuestion}". The correct answer is "${cleanedAnswer}". Can you explain why this is the correct answer?`;
+      
+      setTimeout(() => {
+        chatbotRef.current?.sendMessage(message);
+      }, 500);
+    }
+  };
 
-  const handleHintRequest = () => {
-    setIsChatFocused(!showChat);
-    setShowChat(prev => !prev);
+  const handleShowChat = () => {
+    setShowChat(true);
   };
 
   const handleHideChat = () => {
-    setIsChatFocused(false);
     setShowChat(false);
+    setIsAnswerRevealed(false);
   };
 
-  const handleQuestionChange = useCallback((question: Flashcard | null) => {
-    if (!question) {
-      setCurrentQuestionContext(null);
-      return;
-    }
-
-    setCurrentQuestion(question);
-
-    // Get the explanation from questionAnswerNotes
-    let explanation = '';
-    try {
-      const notes = question.questionAnswerNotes;
-      if (Array.isArray(notes)) {
-        explanation = notes[0] || '';
-      } else if (typeof notes === 'string') {
-        try {
-          const parsedNotes = JSON.parse(notes);
-          explanation = Array.isArray(parsedNotes) ? parsedNotes[0] : notes;
-        } catch {
-          explanation = notes;
-        }
-      }
-    } catch (e) {
-      explanation = '';
+  const getRandomEncouragement = (streak: number) => {
+    const encouragements = [
+      'Great job!',
+      'Keep it up!',
+      'You\'re on fire!',
+      'Excellent!',
+      'Fantastic!',
+      'Amazing!',
+      'Brilliant!',
+      'Superb!',
+      'Outstanding!',
+      'Impressive!'
+    ];
+    
+    const streakEncouragements = [
+      'Streak x2!',
+      'Streak x3!',
+      'Streak x4!',
+      'Streak x5!',
+      'Unstoppable!'
+    ];
+    
+    if (streak >= 3 && streak <= 7) {
+      return streakEncouragements[Math.min(streak - 3, streakEncouragements.length - 1)];
     }
+    
+    return encouragements[Math.floor(Math.random() * encouragements.length)];
+  };
 
-    if (question.questionType === 'normal') {
-      const options = question.questionOptions || [];
-      setCurrentQuestionContext({
-        question: cleanQuestion(question.questionContent),
-        correctAnswer: options[0] || '',
-        explanation,
-        otherOptions: options,
-        type: 'normal'
-      });
-    } else {
-      setCurrentQuestionContext({
-        question: cleanQuestion(question.questionContent),
-        correctAnswer: cleanAnswer(question.questionContent),
-        explanation,
-        otherOptions: [],
-        type: 'flashcard'
-      });
+  useEffect(() => {
+    if (showPlusOne) {
+      setTimeout(() => setShowPlusOne(false), 1000);
     }
-  }, []);
-
-  const [isChatFocused, setIsChatFocused] = useState(false);
-  const [isAnswerRevealed, setIsAnswerRevealed] = useState(false);
+  }, [showPlusOne]);
 
   // Reset if answer is revealed
   useEffect(() => {
@@ -261,18 +273,50 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
   }, [isOpen]);
 
   useEffect(() => {
-    setIsAnswerRevealed(false);
-    handleHideChat();
+    if (currentQuestion) {
+      // Determine the correct answer based on question type
+      let correctAnswer = '';
+      if (currentQuestion.questionType === 'normal' && currentQuestion.questionOptions?.length > 0) {
+        correctAnswer = currentQuestion.questionOptions[0];
+      } else {
+        correctAnswer = cleanAnswer(currentQuestion.questionContent);
+      }
+
+      // Extract explanation from questionAnswerNotes
+      let explanation = '';
+      if (currentQuestion.questionAnswerNotes) {
+        // Handle both string and string[] types
+        if (Array.isArray(currentQuestion.questionAnswerNotes)) {
+          explanation = currentQuestion.questionAnswerNotes[0] || '';
+        } else {
+          explanation = currentQuestion.questionAnswerNotes;
+        }
+      }
+
+      setCurrentQuestionContext({
+        question: currentQuestion.questionContent,
+        correctAnswer: correctAnswer,
+        explanation: explanation,
+        otherOptions: currentQuestion.questionOptions && Array.isArray(currentQuestion.questionOptions) 
+          ? currentQuestion.questionOptions.filter(opt => opt !== correctAnswer)
+          : [],
+        type: currentQuestion.questionType
+      });
+    } else {
+      setCurrentQuestionContext(null);
+      handleHideChat();
+    }
   }, [currentQuestion]);
 
   useImperativeHandle(ref, () => ({
     open: () => onOpenChange(true),
     setWrongCards,
-    setCorrectCount
+    setCorrectCount: (count: number) => {
+      setLocalCorrectCount(count);
+      storeSetCorrectCount(count);
+    }
   }));
 
-
-
   return (
     <>
       {buttonContent}
@@ -292,6 +336,9 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                 } flashcards
               </span>
             </DialogTitle>
+            <DialogDescription className="sr-only">
+              Flashcard practice for {roomId ? roomToSubjectMap[roomId] || 'selected topic' : 'selected topic'}
+            </DialogDescription>
           </DialogHeader>
           
           <div className="flex flex-grow min-h-0 relative flex-col">
@@ -308,7 +355,7 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                         className="text-[--theme-hover-color] flex items-center justify-center"
                       >
                         <span className="text-5xl font-bold">
-                          {correctCount}
+                          {localCorrectCount}
                         </span>
                         <animated.span 
                           style={plusOneSpring}
@@ -337,14 +384,14 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                             <Button
                               variant="ghost"
                               size="icon"
-                              onClick={handleHintRequest}
+                              onClick={handleHint}
                               className="hover:bg-transparent text-[--theme-text-color] hover:text-[--theme-hover-color] transition-colors group"
                             >
                               <HelpCircle className="h-5 w-5 transition-transform duration-200 group-hover:rotate-12" />
                             </Button>
                           </TooltipTrigger>
                           <TooltipContent side="left">
-                            {isAnswerRevealed ? "Explain answer" : "Get a hint"}
+                            {showChat ? "Hide Chat" : "Get a hint"}
                           </TooltipContent>
                         </Tooltip>
                       </TooltipProvider>
@@ -379,7 +426,7 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                     <FlashcardDeck 
                       handleCompleteAllRoom={handleCompleteAllRoom}
                       roomId={roomId} 
-                      onWrongAnswer={handleWrongCard}
+                      onWrongAnswer={handleWrongAnswer}
                       onCorrectAnswer={handleCorrectAnswer}
                       activeRooms={activeRooms}
                       setActiveRooms={setActiveRooms}
@@ -389,9 +436,9 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                       onClose={handleClose}
                       onMCQAnswer={onMCQAnswer}
                       setTotalMCQQuestions={setTotalMCQQuestions}
-                      onQuestionChange={handleQuestionChange}
+                      onQuestionChange={(question) => setCurrentQuestion(question)}
                       onAnswerReveal={(revealed: boolean) => setIsAnswerRevealed(revealed)}
-                      isChatFocused={isChatFocused}
+                      isChatFocused={showChat}
                     />
                   </div>
                 </div>
@@ -421,7 +468,8 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                         chatbotContext={{
                           contentTitle: "Kalypso",
                           context: currentQuestionContext 
-                            ? `${currentQuestionContext.type === 'normal' 
+                            ? `${
+                                currentQuestionContext.type === 'normal' 
                                 ? `Multiple Choice Question:\n${currentQuestionContext.question}\n\nOptions:\n${currentQuestionContext.otherOptions.join('\n')}`
                                 : `Flashcard Question:\n${currentQuestionContext.question}`
                               }${isAnswerRevealed ? `\n\nCorrect Answer: ${currentQuestionContext.correctAnswer}${
@@ -430,8 +478,8 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
                             : ""
                         }}
                         chatbotRef={chatbotRef}
-                        onFocus={() => setIsChatFocused(true)}
-                        onBlur={() => setIsChatFocused(false)}
+                        onFocus={() => {}}
+                        onBlur={() => {}}
                       />
                     </div>
                   </div>
@@ -471,7 +519,6 @@ const FlashcardsDialog = forwardRef<{ open: () => void, setWrongCards: (cards: a
   );
 });
 
-
 FlashcardsDialog.displayName = 'FlashcardsDialog';
 
 export default FlashcardsDialog;
diff --git a/app/(dashboard)/(routes)/ankiclinic/Interruption.tsx b/app/(dashboard)/(routes)/ankiclinic/Interruption.tsx
index 61b9302ba74b46a5e832f03c7546452d36c9de10..94e9fe526095e69dc20c176552554d8f2f429e2b 100644
--- a/app/(dashboard)/(routes)/ankiclinic/Interruption.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/Interruption.tsx
@@ -3,6 +3,7 @@
 import React, { useEffect, useState } from 'react';
 import { motion, AnimatePresence } from 'framer-motion';
 import { useAudio } from '@/contexts/AudioContext';
+import Image from 'next/image';
 
 interface InterruptionProps {
   isVisible: boolean;
@@ -87,10 +88,13 @@ const Interruption = ({
                 onClick={handleClick}
                 className="w-full h-full relative overflow-hidden transition duration-200 ease-in-out transform hover:-translate-y-2 focus:outline-none"
               >
-                <img
+                <Image
                   src={imageUrl}
                   alt="Interruption Character"
+                  width={128}
+                  height={128}
                   className="w-full h-full object-cover transform scale-[2] translate-y-[45%]"
+                  priority
                 />
               </button>
             </div>
diff --git a/app/(dashboard)/(routes)/ankiclinic/OfficeContainer.tsx b/app/(dashboard)/(routes)/ankiclinic/OfficeContainer.tsx
index 4db93be901c27a22b2e38e7cf0f017ba64957d1a..d76bc9bd84c1edc6c1b0439ffdb0e4ee324789a0 100644
--- a/app/(dashboard)/(routes)/ankiclinic/OfficeContainer.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/OfficeContainer.tsx
@@ -1,11 +1,12 @@
-import React, { useEffect, useState, useCallback, useRef, useMemo } from 'react';
+import React, { useEffect, useState, useCallback, useRef, useMemo, memo, forwardRef } from 'react';
 import { Stage, Container, Graphics, Sprite } from '@pixi/react';
 import { Texture, Graphics as PIXIGraphics, utils as PIXIUtils, BaseTexture, Rectangle } from 'pixi.js';
+import type { EventMode } from '@pixi/events';
 import { ImageGroup } from './ShoppingDialog';
 import QuestionPromptSprite from './components/QuestionPromptSprite';
 import { levelConfigurations, roomToContentMap, roomToSubjectMap, spriteWaypoints } from './constants';
 import { GridImage } from './types';
-import { cleanupTextures } from './utils/textureCache';
+import { cleanupTextures, preloadTextures, getTexture } from './utils/textureCache';
 import { useUserInfo } from "@/hooks/useUserInfo";
 
 type Direction = 'N' | 'NE' | 'E' | 'SE' | 'S' | 'SW' | 'W' | 'NW';
@@ -30,6 +31,8 @@ const RoomSprite = React.memo(({
   img, 
   setFlashcardRoomId, 
   activeRooms, 
+  setActiveRooms,
+  isFlashcardsOpen,
   setIsFlashcardsOpen 
 }: { 
   img: GridImage; 
@@ -39,7 +42,7 @@ const RoomSprite = React.memo(({
   isFlashcardsOpen: boolean;
   setIsFlashcardsOpen: (open: boolean) => void;
 }) => {
-  const texture = useMemo(() => Texture.from(img.src), [img.src]);
+  const texture = getTexture(img.src);
   const position = useMemo(() => ({
     x: screenX(img.x, img.y) - img.width / 4,
     y: screenY(img.x, img.y) - img.height / 2
@@ -161,7 +164,6 @@ interface Category {
 }
 
 interface OfficeContainerProps {
-  innerRef?: React.RefObject<HTMLDivElement>;
   onNewGame: (fn: () => GridImage[]) => void;
   visibleImages: Set<string>;
   userRooms: string[];
@@ -187,22 +189,49 @@ type SpritePositions = {
   [key: string]: SpritePosition;
 };
 
-const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
-  const {
-    onNewGame,
-    visibleImages,
-    userRooms,
-    setFlashcardRoomId,
-    updateVisibleImages,
-    activeRooms,
-    setActiveRooms,
-    isFlashcardsOpen,
-    setIsFlashcardsOpen,
-  } = props;
+// Update PixiJS configuration to use modern APIs
+const pixiConfig = {
+  eventMode: 'dynamic' as EventMode, // Type assertion to EventMode
+  backgroundAlpha: 0,
+  antialias: true,
+  resolution: window.devicePixelRatio || 1,
+};
 
+// Convert to forwardRef
+const OfficeContainer = forwardRef<HTMLDivElement, OfficeContainerProps>(({ 
+  onNewGame,
+  visibleImages,
+  userRooms,
+  imageGroups,
+  setFlashcardRoomId,
+  updateVisibleImages,
+  activeRooms,
+  setActiveRooms,
+  isFlashcardsOpen,
+  setIsFlashcardsOpen
+}, ref) => {
+  // All useState hooks first
   const [currentLevel, setCurrentLevel] = useState(1);
+  const [stageSize, setStageSize] = useState({ width: 0, height: 0 });
+  const [scale, setScale] = useState(1);
+  const [currentWaypoints, setCurrentWaypoints] = useState(spriteWaypoints[1]);
+  const [spritePositions, setSpritePositions] = useState<SpritePositions>({
+    sprite1: { id: 'sprite1', x: 9, y: 9, direction: 'S', character: 1 },
+  });
+
+  // Then all useRef hooks
+  const sprite1WaypointIndexRef = useRef(0);
+  
+  // Then custom hooks
   const { userInfo } = useUserInfo();
 
+  // Tutorial room effect
+  useEffect(() => {
+    if(currentLevel === 1) {
+      setActiveRooms(prevRooms => new Set([...prevRooms, 'WaitingRoom0']));
+    }
+  }, [currentLevel, setActiveRooms]);
+
   // Define zoom levels for each test level
   const zoomLevels: Record<number, { scale: number, offsetX: number, offsetY: number }> = {
     0: { scale: 2.5, offsetX: -50, offsetY: -200 },
@@ -214,24 +243,6 @@ const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
     6: { scale: 1.0, offsetX: 0, offsetY: 90 },
   };
 
-  const [stageSize, setStageSize] = useState({ width: 0, height: 0 });
-  const [scale, setScale] = useState(1);
-
-  const [spritePositions, setSpritePositions] = useState<SpritePositions>({
-    sprite1: { id: 'sprite1', x: 9, y: 9, direction: 'S', character: 1 },
-  });
-
-  const sprite1WaypointIndexRef = useRef(0);
-
-  // Function to calculate positions
-  function screenX(worldX: number, worldY: number): number {
-    return (worldX - worldY) * (tileWidth / 2);
-  }
-
-  function screenY(worldX: number, worldY: number): number {
-    return (worldX + worldY) * (tileHeight / 2);
-  }
-
   // Modify the calculateScale function
   const calculateScale = useCallback(() => {
     const containerWidth = window.innerWidth;
@@ -268,9 +279,6 @@ const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
     return () => window.removeEventListener('resize', handleResize);
   }, [calculateScale]);
 
-
-  const [currentWaypoints, setCurrentWaypoints] = useState(spriteWaypoints[1]);
-
   // Modify the moveSprite function to use currentWaypoints
   const moveSprite = useCallback((
     spriteId: string,
@@ -442,24 +450,8 @@ const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
     y: ((gridHeight * tileHeight) / 4 + zoomLevels[currentLevel].offsetY)
   }), [currentLevel]);
 
-
-  useEffect(() => {
-    // show tutorial room by default if user is patient level
-    if(currentLevel === 1) {
-      setActiveRooms(prevRooms => new Set([...prevRooms, 'WaitingRoom0']));
-    }
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, []);
-
-  // Add cleanup effect
-  useEffect(() => {
-    return () => {
-      cleanupTextures();
-    };
-  }, []);
-
   return (
-    <div ref={innerRef} className="relative w-full h-full">
+    <div ref={ref} className="relative w-full h-full">
       {/* Pixi.js stage container - Add pointer-events-none by default */}
       <div className="absolute inset-0 z-20 flex justify-center items-center pointer-events-none">
         <Stage
@@ -467,13 +459,11 @@ const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
           height={stageSize.height}
           options={{ 
             backgroundAlpha: 0,
-            // Enable interactions only for the stage content
             eventMode: 'static'
           }}
           style={{
             width: `${stageSize.width}px`,
             height: `${stageSize.height}px`,
-            // Re-enable pointer events only for the Stage
             pointerEvents: 'auto'
           }}
         >
@@ -510,6 +500,18 @@ const OfficeContainer = ({ innerRef, ...props }: OfficeContainerProps) => {
       </div>
     </div>
   );
-};
+});
+
+OfficeContainer.displayName = 'OfficeContainer';
+
+// Properly handle both memo and forwardRef
+const MemoizedOfficeContainer = React.memo(
+  React.forwardRef<HTMLDivElement, OfficeContainerProps>((props, ref) => (
+    <OfficeContainer {...props} ref={ref} />
+  ))
+);
+
+// Set display name for debugging
+MemoizedOfficeContainer.displayName = 'MemoizedOfficeContainer';
 
-export default OfficeContainer;
\ No newline at end of file
+export default MemoizedOfficeContainer;
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/ankiclinic/ResourcesMenu.tsx b/app/(dashboard)/(routes)/ankiclinic/ResourcesMenu.tsx
index b4193e8b90b8afb3cf178ffc5c37333b1c5d8ba9..69fa9df3e97fcae23a036012f078fa39eef8c8c1 100644
--- a/app/(dashboard)/(routes)/ankiclinic/ResourcesMenu.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/ResourcesMenu.tsx
@@ -1,4 +1,4 @@
-import React, { useState } from "react";
+import React, { useState, useEffect } from "react";
 import { DoctorOfficeStats } from "@/types";
 import { FaFire } from "react-icons/fa";
 import {
@@ -9,8 +9,10 @@ import TutorialVidDialog from "@/components/ui/TutorialVidDialog";
 import { useMusicPlayer } from '@/contexts/MusicPlayerContext';
 import Leaderboard from "@/components/leaderboard/Leaderboard";
 import AnimatedProfileIcon from '@/components/ui/AnimatedProfileIcon';
-import { useProfileContext } from '@/contexts/UserProfileContext';
+import { useUser } from '@/store/selectors';
+import { useGame } from "@/store/selectors";
 
+/* --- Types ----- */
 interface ResourcesMenuProps {
   reportData: DoctorOfficeStats | null;
   userRooms: string[];
@@ -19,16 +21,66 @@ interface ResourcesMenuProps {
   patientsPerDay: number;
 }
 
+interface DaysStreakProps {
+  days: number;
+}
+
+/* --- Helper Components ----- */
+const DaysStreak = React.memo<DaysStreakProps>(({ days }) => {
+  const getStreakMessage = React.useMemo(() => {
+    return (days: number): string => {
+      if (days < 3) return "Great start! Keep the momentum going!";
+      if (days < 7) return "Impressive! You're building a solid habit!";
+      if (days < 14) return "Wow! Your dedication is awesome!";
+      if (days < 30) return "Incredible streak! You're unstoppable!";
+      return "Legendary! Your consistency is truly inspiring!";
+    };
+  }, []);
+
+  return (
+    <div
+      className="w-full max-w-md rounded-lg p-4 mt-6 mb-2 text-white shadow-lg"
+      style={{
+        background:
+          "linear-gradient(to right, var(--theme-gradient-startstreak), var(--theme-gradient-endstreak))",
+      }}
+    >
+      <div className="flex items-center justify-between">
+        <div>
+          <h3 className="text-lg font-semibold">Days Streak</h3>
+          <p className="text-sm opacity-80">Keep it up!</p>
+        </div>
+        <div className="flex items-center">
+          <span className="text-3xl font-bold mr-2">{days}</span>
+          <FaFire className="text-4xl text-yellow-300 animate-pulse" />
+        </div>
+      </div>
+      <div className="mt-2 text-sm">{getStreakMessage(days)}</div>
+    </div>
+  );
+});
+
+DaysStreak.displayName = 'DaysStreak';
+
+/* --- Main Component ----- */
 const ResourcesMenu: React.FC<ResourcesMenuProps> = ({
   reportData,
   userRooms,
+  totalCoins,
+  totalPatients,
+  patientsPerDay,
 }) => {
   const [isTutorialDialogOpen, setIsTutorialDialogOpen] = useState(false);
   const [tutorialVideoUrl, setTutorialVideoUrl] = useState("");
-  const { profile } = useProfileContext();
+  const { profile } = useUser();
+  const { streakDays } = useGame();
 
   if (!reportData) {
-    return <div>Loading...</div>;
+    return (
+      <div className="h-full flex flex-col bg-[--theme-leaguecard-color] text-[--theme-text-color] items-center justify-center rounded-lg p-4">
+        Loading...
+      </div>
+    );
   }
 
   const playerLevel = calculatePlayerLevel(userRooms);
@@ -37,13 +89,11 @@ const ResourcesMenu: React.FC<ResourcesMenuProps> = ({
   return (
     <div className="h-full">
       <div className="flex flex-col bg-[--theme-leaguecard-color] text-[--theme-text-color] items-center h-full rounded-lg p-4 overflow-auto relative scrollbar-gutter-stable">
-        {/* Prevent layout shift when scrollbar appears/disappears */}
         <style jsx global>{`
           .scrollbar-gutter-stable {
             scrollbar-gutter: stable;
           }
           
-          /* Optional: Style the scrollbar to make it less obtrusive */
           .scrollbar-gutter-stable::-webkit-scrollbar {
             width: 8px;
           }
@@ -64,7 +114,7 @@ const ResourcesMenu: React.FC<ResourcesMenuProps> = ({
           />
         </div>
 
-        <DaysStreak days={reportData.streak} />
+        <DaysStreak days={streakDays} />
 
         <div className="w-full max-w-md mt-6">
           <Leaderboard 
@@ -83,40 +133,12 @@ const ResourcesMenu: React.FC<ResourcesMenuProps> = ({
   );
 };
 
-interface DaysStreakProps {
-  days: number;
-}
-
-const DaysStreak: React.FC<DaysStreakProps> = ({ days }) => {
+export default React.memo(ResourcesMenu, (prevProps, nextProps) => {
   return (
-    <div
-      className="w-full max-w-md rounded-lg p-4 mt-6 mb-2 text-white shadow-lg"
-      style={{
-        background:
-          "linear-gradient(to right, var(--theme-gradient-startstreak), var(--theme-gradient-endstreak))",
-      }}
-    >
-      <div className="flex items-center justify-between">
-        <div>
-          <h3 className="text-lg font-semibold">Days Streak</h3>
-          <p className="text-sm opacity-80">Keep it up!</p>
-        </div>
-        <div className="flex items-center">
-          <span className="text-3xl font-bold mr-2">{days}</span>
-          <FaFire className="text-4xl text-yellow-300 animate-pulse" />
-        </div>
-      </div>
-      <div className="mt-2 text-sm">{getStreakMessage(days)}</div>
-    </div>
+    prevProps.reportData === nextProps.reportData &&
+    prevProps.totalCoins === nextProps.totalCoins &&
+    prevProps.totalPatients === nextProps.totalPatients &&
+    prevProps.patientsPerDay === nextProps.patientsPerDay &&
+    prevProps.userRooms?.length === nextProps.userRooms?.length
   );
-};
-
-const getStreakMessage = (days: number): string => {
-  if (days < 3) return "Great start! Keep the momentum going!";
-  if (days < 7) return "Impressive! You're building a solid habit!";
-  if (days < 14) return "Wow! Your dedication is awesome!";
-  if (days < 30) return "Incredible streak! You're unstoppable!";
-  return "Legendary! Your consistency is truly inspiring!";
-};
-
-export default ResourcesMenu;
+});
diff --git a/app/(dashboard)/(routes)/ankiclinic/ScoreRandomizer.tsx b/app/(dashboard)/(routes)/ankiclinic/ScoreRandomizer.tsx
index 81fd818ce418926a185e27c3cfbfda667a79a59f..e139a4da2905ade931f936b0078e8ad903dcc606 100644
--- a/app/(dashboard)/(routes)/ankiclinic/ScoreRandomizer.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/ScoreRandomizer.tsx
@@ -300,6 +300,7 @@ const ScoreRandomizer: React.FC<ScoreRandomizerProps> = ({
     averageStarRating,
     clinicCostPerDay,
     purchasedRooms,
+    getCurrentTier
   ]);
 
   // Function to render stars with animation (update to handle 0 stars)
diff --git a/app/(dashboard)/(routes)/ankiclinic/page.tsx b/app/(dashboard)/(routes)/ankiclinic/page.tsx
index 82a8d759ec19ac1e4d4a396a7546aa17a1984e8c..3c4c8f4e4333b329cb6b18b15d4546d85951077d 100644
--- a/app/(dashboard)/(routes)/ankiclinic/page.tsx
+++ b/app/(dashboard)/(routes)/ankiclinic/page.tsx
@@ -1,62 +1,143 @@
 "use client";
 
-import React, { useState, useEffect, useRef, useCallback, Suspense, forwardRef } from "react";
-import ResourcesMenu from "./ResourcesMenu";
-import { useRouter } from "next/navigation";
+import React, { useState, useEffect, useRef, useCallback, Suspense, forwardRef, useMemo } from "react";
+import ReactDOM from 'react-dom';
+import { useRouter, usePathname, useSearchParams } from "next/navigation";
 import { DoctorOfficeStats } from "@/types";
 import { toast, Toaster } from "react-hot-toast";
 import Image from "next/image";
 import { calculatePlayerLevel, getPatientsPerDay, calculateTotalQC, 
   getClinicCostPerDay, getLevelNumber, calculateQualityOfCare } from "@/utils/calculateResourceTotals";
-import WelcomeDialog from "./WelcomeDialog";
 import { imageGroups } from "./constants/imageGroups";
 import { PurchaseButton } from "@/components/purchase-button";
 import dynamic from 'next/dynamic';
 import { useUserInfo } from "@/hooks/useUserInfo";
 import { useUserActivity } from '@/hooks/useUserActivity';
 import { useMusicPlayer } from '@/contexts/MusicPlayerContext';
+import { useAudio } from "@/contexts/AudioContext";
+import { useAudioTransitions } from "@/hooks/useAudioTransitions";
 import type { UserResponse } from "@prisma/client";
 import type { FetchedActivity } from "@/types";
 import { GridImage } from './types';
-import NewGameButton from "./components/NewGameButton";
-import TutorialVidDialog from '@/components/ui/TutorialVidDialog';
 import type { UserResponseWithCategory } from "@/types";
-import { useAudio } from "@/contexts/AudioContext";
-import RedeemReferralModal from "@/components/social/friend-request/RedeemReferralModal";
 import { shouldShowRedeemReferralModal } from '@/lib/referral';
 import { getAccentColor, getWelcomeMessage, getSuccessMessage } from './utils';
+import { useGame } from "@/store/selectors";
 
-// Lazy load the heavy components
-const OfficeContainer = dynamic(() => import('./OfficeContainer'), {
-  loading: () => <div className="w-3/4 bg-gray-900/50 animate-pulse rounded-r-lg" />,
+// Only dynamically import components that are truly heavy or rarely used
+// Core components should be imported directly for faster initial render
+import ResourcesMenu from './ResourcesMenu';
+import OfficeContainer from './OfficeContainer';
+
+// Keep dynamic imports for less critical components
+const WelcomeDialog = dynamic(() => import('./WelcomeDialog'), {
   ssr: false
 });
 
 const ShoppingDialog = dynamic(() => import('./ShoppingDialog'), {
-  loading: () => null,
   ssr: false
 });
 
-const FlashcardsDialog = dynamic(() => import('./FlashcardsDialog'), {
-  loading: () => null,
+// Fix for FlashcardsDialog to properly handle refs
+const FlashcardsDialog = dynamic(
+  () => import('./FlashcardsDialog').then(mod => {
+    // Return the default export which is already using forwardRef
+    return { default: mod.default };
+  }),
+  { ssr: false }
+);
+
+// Fix for AfterTestFeed to properly handle refs
+const AfterTestFeed = dynamic(
+  () => import('./AfterTestFeed').then(mod => {
+    // Return the default export which is already using forwardRef
+    return { default: mod.default };
+  }),
+  { ssr: false }
+);
+
+const FloatingButton = dynamic(() => import('../home/FloatingButton'), {
   ssr: false
 });
 
-const AfterTestFeed = dynamic(() => import('./AfterTestFeed'), {
-  loading: () => null,
+const TutorialVidDialog = dynamic(() => import('@/components/ui/TutorialVidDialog'), {
   ssr: false
 });
 
-const FloatingButton = dynamic(() => import('../home/FloatingButton'), {
-  loading: () => null,
+const RedeemReferralModal = dynamic(() => import('@/components/social/friend-request/RedeemReferralModal'), {
   ssr: false
 });
 
+const NewGameButton = dynamic(() => import('./components/NewGameButton'), {
+  ssr: false
+});
+
+// Loading component for better UX during initial load
+const LoadingClinic = () => (
+  <div className="fixed inset-x-0 bottom-0 top-[4rem] flex bg-transparent text-[--theme-text-color] p-4">
+    <div className="flex w-full h-full max-w-full max-h-full items-center justify-center text-xl font-medium">
+      <div className="flex flex-col items-center gap-4">
+        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[--theme-primary-color]"></div>
+        <p>Loading AnkiClinic...</p>
+      </div>
+    </div>
+  </div>
+);
+
+/* --- Constants ----- */
+const AMBIENT_SOUND = '/audio/flashcard-loop-catfootsteps.mp3';
+
+/* ----- Types ---- */
 interface DoctorsOfficePageProps {
   // Add any props if needed
 }
 
 const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
+  console.log('🔍 [DEBUG] DoctorsOfficePage rendering');
+  const pathname = usePathname();
+  const searchParams = useSearchParams();
+  
+  // Add mount counter ref
+  const mountCountRef = useRef(0);
+  const isFetchingRef = useRef(false);
+  // Add a ref to store the current abort controller
+  const abortControllerRef = useRef<AbortController | null>(null);
+  // Add a ref to track if component is already initialized
+  const isInitializedRef = useRef(false);
+  // Add a ref to track if state updates are in progress
+  const stateUpdateInProgressRef = useRef(false);
+  // Add a ref to track if component is mounted
+  const isMountedRef = useRef(false);
+  
+  // Add this ref near the other refs at the top of the component
+  const isClosingDialogRef = useRef(false);
+  
+  // Track mount count and log navigation - combined into one effect
+  useEffect(() => {
+    mountCountRef.current += 1;
+    isMountedRef.current = true;
+    
+    // Only run client-side code
+    if (typeof window !== 'undefined') {
+      // Set loading to false after a short delay to allow the UI to render first
+      setTimeout(() => {
+        setIsLoading(false);
+      }, 100);
+      
+      const timestamp = new Date().toISOString();
+      console.log("====================================================================");
+      console.log(`======= ANKICLINIC PAGE MOUNTED AT ${timestamp} =======`);
+      console.log("====================================================================");
+      console.log('[DEBUG] AnkiClinic mounted, pathname:', pathname);
+      console.log('[DEBUG] AnkiClinic mount count:', mountCountRef.current);
+      
+      return () => {
+        console.log('[DEBUG] AnkiClinic unmounting');
+        isMountedRef.current = false;
+      };
+    }
+  }, [pathname]);
+
   /* ------------------------------------------- Hooks -------------------------------------------- */
   const officeContainerRef = useRef<HTMLDivElement>(null);
   const flashcardsDialogRef = useRef<{ 
@@ -69,37 +150,34 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   const { setIsAutoPlay } = useMusicPlayer();
   const { startActivity } = useUserActivity();
   const router = useRouter();
+  
+  // Get the game state and actions from Zustand
+  const { 
+    userRooms, userLevel, patientsPerDay, totalPatients, streakDays,
+    isGameInProgress, currentUserTestId, isFlashcardsOpen, flashcardRoomId, 
+    activeRooms, completeAllRoom, correctCount, wrongCount, testScore, userResponses,
+    unlockRoom, startGame, endGame, setIsFlashcardsOpen, setUserRooms,
+    setFlashcardRoomId, setActiveRooms, setCompleteAllRoom, resetGameState,
+    setCorrectCount, setWrongCount, setTestScore, setUserResponses,
+    setStreakDays, setTotalPatients, updateUserLevel
+  } = useGame();
+  
   /* ------------------------------------------- State -------------------------------------------- */
   const [activeTab, setActiveTab] = useState("ankiclinic");
-  const [userLevel, setUserLevel] = useState("PATIENT LEVEL");
-  const [patientsPerDay, setPatientsPerDay] = useState(4);
-  const [userRooms, setUserRooms] = useState<string[]>([]);
-  const [reportData, setReportData] = useState<DoctorOfficeStats | null>(null);
-  const [totalPatients, setTotalPatients] = useState(0);
+  const [showWelcomeDialogue, setShowWelcomeDialogue] = useState(false);
+  // Local UI states that were moved from Zustand
   const [isAfterTestDialogOpen, setIsAfterTestDialogOpen] = useState(false);
   const [largeDialogQuit, setLargeDialogQuit] = useState(false);
-  const [showWelcomeDialogue, setShowWelcomeDialogue] = useState(false);
+  const [isMarketplaceOpen, setIsMarketplaceOpen] = useState(false);
   //Flashcards
-  const [isFlashcardsOpen, setIsFlashcardsOpen] = useState(false);
   const prevFlashcardsOpenRef = useRef(false); //this keeps track of previous state
   const [isFlashcardsTooltipOpen, setIsFlashcardsTooltipOpen] = useState(false);
-  const [flashcardRoomId, setFlashcardRoomId] = useState<string>("");
-  const [isLoading, setIsLoading] = useState(false);
+  const [isLoading, setIsLoading] = useState(true); // Start with loading state
   const [totalMCQQuestions, setTotalMCQQuestions] = useState(0);
   const [correctMCQQuestions, setCorrectMCQQuestions] = useState(0);
   const afterTestFeedRef = useRef<{ setWrongCards: (cards: any[]) => void } | null>(null);
   // Game functionality
-  const [activeRooms, setActiveRooms] = useState<Set<string>>(() => new Set());
-  const [completeAllRoom, setCompleteAllRoom] = useState(false);
-  const [currentUserTestId, setCurrentUserTestId] = useState<string | null>(null);
-  // User Responses
-  const [userResponses, setUserResponses] = useState<UserResponseWithCategory[]>([]);
-  const [correctCount, setCorrectCount] = useState(0);
-  const [wrongCount, setWrongCount] = useState(0);
-  const [testScore, setTestScore] = useState(0);
-  const [isGameInProgress, setIsGameInProgress] = useState(false);
   // Marketplace Dialog
-  const [isMarketplaceOpen, setIsMarketplaceOpen] = useState(false);
   const marketplaceDialogRef = useRef<{
     open: () => void
   }>(null);
@@ -107,28 +185,41 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   const [clinicCostPerDay, setClinicCostPerDay] = useState(0);
   const [isCalculating, setIsCalculating] = useState(false);
   const hasCalculatedRef = useRef(false);
-  // Add this new state for streak days
-  const [streakDays, setStreakDays] = useState(0);
   const [isTutorialOpen, setIsTutorialOpen] = useState(false);
   const [showReferralModal, setShowReferralModal] = useState(false);
   const [populateRoomsFn, setPopulateRoomsFn] = useState<(() => GridImage[]) | null>(null);
   const [activities, setActivities] = useState<FetchedActivity[]>([]);
-  // Add debug state to track audio lifecycle
-  const [debugId] = useState(() => Math.random().toString(36).substr(2, 9));
-  // Add a ref to track mounted state
-  const isMountedRef = useRef(false);
-  const audioTransitionInProgressRef = useRef(false);
-
-  /* --- Constants ----- */
-  const AMBIENT_SOUND = '/audio/flashcard-loop-catfootsteps.mp3';
+  // Add a ref to track loading state updates
+  const loadingStateUpdatedRef = useRef(false);
+  const [reportData, setReportData] = useState<DoctorOfficeStats | null>(null);
+  // Add a ref to track the last time isFlashcardsOpen was changed
+  const lastFlashcardToggleTimeRef = useRef(0);
+  // Add a ref to track the previous isFlashcardsOpen value
+  const prevIsFlashcardsOpenRef = useRef(isFlashcardsOpen);
+
+  // Add useAudioTransitions hook after state declarations
+  const { 
+    initializeAmbientSound, 
+    stopAllAudio,
+    isAudioTransitionInProgress 
+  } = useAudioTransitions({
+    isFlashcardsOpen,
+    isLoading,
+    isMounted: isMountedRef.current
+  });
 
   /* ----------------------------------------- Computation ----------------------------------------- */
 
-  const isClinicUnlocked = userInfo?.unlocks && 
-  (typeof userInfo.unlocks === 'string' ? 
-    JSON.parse(userInfo.unlocks) : 
-    userInfo.unlocks
-  )?.includes('game');
+  // Memoize expensive computations
+  const isClinicUnlocked = useMemo(() => {
+    if (!userInfo?.unlocks) return false;
+    
+    const unlocks = typeof userInfo.unlocks === 'string' 
+      ? JSON.parse(userInfo.unlocks) 
+      : userInfo.unlocks;
+      
+    return unlocks?.includes('game');
+  }, [userInfo?.unlocks]);
 
   /* ----------------------------------------- Callbacks ------------------------------------------ */
 
@@ -152,13 +243,14 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
         responses?.filter((response: UserResponse) => !response.isCorrect)
           ?.length || 0;
 
+      // Update the store instead of local state
       setCorrectCount(correct);
       setWrongCount(wrong);
     } catch (error) {
       console.error("Error fetching user responses:", error);
       toast.error("Failed to load test responses");
     }
-  }, []);
+  }, [setCorrectCount, setWrongCount, setUserResponses]);
 
   const updateVisibleImages = useCallback((newVisibleImages: Set<string>) => {
     setVisibleImages(newVisibleImages);
@@ -175,182 +267,321 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   }, []);
 
   /* ----------------------------------------- UseEffects ---------------------------------------- */
-  // Handles test completion, scoring, and updates database
+  
+  // Initialize ambient sound as soon as possible
   useEffect(() => {
-    const finishTest = async () => {
-      if (!isLoading && completeAllRoom) {
-        // Finish all rooms
-        // Fetch user responses
-        if (currentUserTestId) {
-          fetchUserResponses(currentUserTestId);
-          // Dummy scoring logic
-          const correctQuestionWeight = 1;
-          const incorrectQuestionWeight = -0.5;
-          let testScore =
-            correctCount * correctQuestionWeight +
-            wrongCount * incorrectQuestionWeight;
-          testScore = Math.max(testScore, 0);
-          setTestScore(testScore);
-          // Update the UserTest with score
-          fetch(`/api/user-test/${currentUserTestId}`, {
-            method: "PUT",
-            headers: {
-              "Content-Type": "application/json",
-            },
-            body: JSON.stringify({
-              score: testScore,
-              finishedAt: new Date().toISOString(),
-            }),
-          }).catch(console.error);
-
-          if (!isFlashcardsOpen && !largeDialogQuit) {
-            setIsAfterTestDialogOpen(true);
-          }
-        }
+    if (!isMountedRef.current) return;
+    
+    // Initialize ambient sound immediately when component mounts
+    const timer = setTimeout(() => {
+      if (!isFlashcardsOpen) {
+        console.log('[DEBUG] Initializing ambient sound on mount');
+        initializeAmbientSound();
+      }
+    }, 200); // Short delay to ensure component is fully mounted
+    
+    return () => {
+      clearTimeout(timer);
+      stopAllAudio();
+    };
+  }, [initializeAmbientSound, isFlashcardsOpen, stopAllAudio]);
+  
+  // Monitor flashcards state changes separately
+  useEffect(() => {
+    if (!isMountedRef.current) return;
+    
+    if (prevIsFlashcardsOpenRef.current !== isFlashcardsOpen) {
+      prevIsFlashcardsOpenRef.current = isFlashcardsOpen;
+      
+      // Handle audio transitions based on flashcards state
+      if (!isFlashcardsOpen) {
+        console.log('[DEBUG] Flashcards closed, reinitializing ambient sound');
+        initializeAmbientSound();
       }
     }
+  }, [isFlashcardsOpen, initializeAmbientSound]);
 
-    finishTest();
-  }, [ currentUserTestId, activeRooms.size, isFlashcardsOpen, fetchUserResponses, correctCount,
-    wrongCount, testScore, isLoading, largeDialogQuit, completeAllRoom ]);
+  // Auto-open flashcard dialog when roomId changes - with optimization
 
-  // Manages music autoplay when component mounts/unmounts
+  // Shows welcome/referral modals based on user state - run only when userInfo changes
   useEffect(() => {
-    setIsAutoPlay(true);
-    return () => setIsAutoPlay(false);
-  }, [setIsAutoPlay]);
-
-  // Component mount: Initial data fetch and daily calculations setup
-  useEffect(() => {
-    fetchData();
-    if (!hasCalculatedRef.current && userInfo) {
-      const timer = setTimeout(() => {
-        performDailyCalculations();
-        hasCalculatedRef.current = true;
-      }, 3000);
-      // Clean up the timer if the component unmounts
-      return () => clearTimeout(timer);
+    // Skip if not mounted or if state updates are in progress
+    if (!isMountedRef.current || stateUpdateInProgressRef.current) return;
+    
+    // Only show welcome dialog if user info is available and not in loading state
+    if (userInfo && !isLoading && !hasCalculatedRef.current) {
+      hasCalculatedRef.current = true;
+      setShowWelcomeDialogue(true);
     }
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [userInfo]);
-
-  // Component mount: fetches user activities 
-  useEffect(() => {
-    fetchActivities();
-  }, []);
+  }, [userInfo, isLoading, setShowWelcomeDialogue]);
 
-  // Component mount: Initializes activity tracking
+  // Add a new effect to preserve debug mode - run only once
   useEffect(() => {
-    const initializeActivity = async () => {
-        await startActivity({
-          type: 'studying',
-          location: 'Game',
-          metadata: {
-            initialLoad: true,
-            timestamp: new Date().toISOString()
-          }
-        });
+    if (typeof window === 'undefined') return; // Skip on server-side
+    
+    // Check if we need to preserve debug mode
+    const isDebugMode = searchParams?.get('debug') === 'true';
+    console.log('[DEBUG] Debug mode check:', {
+      isDebugMode,
+      searchParamsDebug: searchParams?.get('debug'),
+      hasDebugClass: document.body.classList.contains('debug-mode')
+    });
+    
+    if (isDebugMode) {
+      // Set a flag to indicate we're in debug mode
+      document.body.classList.add('debug-mode');
+      console.log('[DEBUG] Added debug-mode class to body');
+      
+      // In debug mode, immediately set loading to false to avoid loading bar
+      if (isLoading) {
+        setIsLoading(false);
       }
-    initializeActivity();
-  // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, []);
+    } else if (searchParams?.get('debug') === 'false') {
+      // Explicitly set to false - remove debug mode
+      document.body.classList.remove('debug-mode');
+      console.log('[DEBUG] Removed debug-mode class from body');
+    }
+    
+    return () => {
+      // Only clean up if component unmounts, not on every render
+      if (document.body.classList.contains('debug-mode') && !isDebugMode) {
+        document.body.classList.remove('debug-mode');
+        console.log('[DEBUG] Cleanup: Removed debug-mode class from body');
+      }
+    };
+  }, [searchParams]);
 
-  // Modify the existing useEffect for ambient sound and flashcard door sounds
+  // Component mount: Initial data fetch and daily calculations setup
   useEffect(() => {
-    let isEffectActive = true; // Local flag to track if effect is still active
-
-    const handleAudioTransition = async () => {
-      try {
-        if (!isEffectActive) return;
-
-        if (isFlashcardsOpen) {
-          await audio.stopAllLoops();
-          if (!isEffectActive) return;
-          audio.playSound('flashcard-door-open');
-        } else {
-          if (prevFlashcardsOpenRef.current) {
-            audio.playSound('flashcard-door-closed');
-            await new Promise(resolve => setTimeout(resolve, 500));
-            if (!isEffectActive) return;
-            await audio.loopSound('flashcard-loop-catfootsteps');
-          } else {
-            await audio.loopSound('flashcard-loop-catfootsteps');
+    let mounted = true;
+    let retryCount = 0;
+    const MAX_RETRIES = 3;
+    const RETRY_DELAY = 1000; // 1 second
+    
+    console.log('[DEBUG] Starting data initialization');
+    
+    const initializeData = async () => {
+      // Skip if already initialized and data is present
+      if (isInitializedRef.current && reportData) {
+        console.log('[DEBUG] Already initialized with data, skipping');
+        return;
+      }
+      
+      isInitializedRef.current = true;
+      console.log('[DEBUG] Setting initialized flag to true');
+      
+      const attemptFetch = async () => {
+        try {
+          console.log('[DEBUG] Attempting to fetch data');
+          await fetchData();
+          console.log('[DEBUG] Data fetch completed successfully');
+          
+          // Only proceed with calculations if still mounted
+          if (mounted && !hasCalculatedRef.current && userInfo) {
+            console.log('[DEBUG] Starting daily calculations');
+            performDailyCalculations();
+            hasCalculatedRef.current = true;
+            console.log('[DEBUG] Daily calculations completed');
+          }
+        } catch (error) {
+          console.error('[DEBUG] Error during initialization:', error);
+          
+          // Retry logic
+          if (mounted && retryCount < MAX_RETRIES) {
+            retryCount++;
+            console.log(`[DEBUG] Retrying fetch attempt ${retryCount} of ${MAX_RETRIES}`);
+            setTimeout(attemptFetch, RETRY_DELAY);
+          } else if (mounted) {
+            console.error('[DEBUG] Max retries reached, showing error toast');
+            toast.error("Failed to initialize clinic data. Please refresh the page.");
           }
         }
-        if (!isEffectActive) return;
-        prevFlashcardsOpenRef.current = isFlashcardsOpen;
-      } catch (error) {
-        if (isEffectActive) {
-          console.error(`🎵 [${debugId}] Audio transition error:`, error);
-        }
+      };
+      
+      await attemptFetch();
+    };
+    
+    // Small delay to let any Strict Mode double-mount settle
+    console.log('[DEBUG] Setting up initialization timer');
+    const initTimer = setTimeout(() => {
+      if (mounted) {
+        console.log('[DEBUG] Initialization timer fired, starting data init');
+        initializeData();
+      }
+    }, 100);
+    
+    return () => {
+      console.log('[DEBUG] Cleanup for data initialization effect');
+      mounted = false;
+      clearTimeout(initTimer);
+      // Only abort requests if we're actually unmounting, not just in Strict Mode
+      if (mountCountRef.current > 2 && abortControllerRef.current) {
+        console.log('[DEBUG] Aborting pending requests');
+        abortControllerRef.current.abort();
       }
     };
+  }, [userInfo, reportData]); // Add reportData as dependency to prevent unnecessary fetches
 
-    handleAudioTransition();
+  // Add a debug effect to track key state changes
+  useEffect(() => {
+    console.log('[DEBUG] Key state update:', {
+      isLoading,
+      hasReportData: !!reportData,
+      hasUserInfo: !!userInfo,
+      userRoomsLength: userRooms?.length || 0,
+      isInitialized: isInitializedRef.current,
+      pathname
+    });
+  }, [isLoading, reportData, userInfo, userRooms, pathname]);
 
+  // Initialize ambient sound on component mount
+  useEffect(() => {
+    if (!isMountedRef.current) return;
+    
+    console.log('[DEBUG] Initializing ambient sound, isLoading:', isLoading);
+    
+    // Create a small delay to ensure audio context is ready
+    const timeoutId = setTimeout(() => {
+      // Initializing ambient sound regardless of loading state
+      initializeAmbientSound();
+    }, 100);
+    
     return () => {
-      isEffectActive = false;
+      clearTimeout(timeoutId);
+      // Cleaning up audio on unmount
+      stopAllAudio();
     };
-  }, [isFlashcardsOpen, debugId]); // Only depend on flashcards state and debugId
+  }, [initializeAmbientSound, stopAllAudio, isMountedRef]);
 
-  // Opens flashcard dialog when a room is selected
+  // Opens flashcard dialog when a room is selected - optimize with additional check
   useEffect(() => {
-    if (flashcardRoomId !== "") {
+    // Skip during initial load or if already transitioning
+    if (isLoading || stateUpdateInProgressRef.current) return;
+    
+    // Skip if we're in the process of closing the dialog
+    if (isClosingDialogRef.current) {
+      // Skipping auto-open effect while dialog is closing
+      return;
+    }
+    
+    if (flashcardRoomId !== "" && !isFlashcardsOpen) {
+      // Auto-opening flashcard dialog
+      stateUpdateInProgressRef.current = true;
       setIsFlashcardsOpen(true);
+      // Reset the flag after a short delay
+      setTimeout(() => {
+        stateUpdateInProgressRef.current = false;
+      }, 50);
     }
-  }, [flashcardRoomId, debugId]);
+  }, [flashcardRoomId, isFlashcardsOpen, isLoading, setIsFlashcardsOpen]);
 
-  // Shows welcome/referral modals based on user state
+  // Add an effect to ensure audio context is initialized on navigation
   useEffect(() => {
-    setShowReferralModal(shouldShowRedeemReferralModal());
-    if(userInfo && !isClinicUnlocked) {
-      setShowWelcomeDialogue(true);
+    // This effect runs when the component mounts after navigation
+    if (typeof window !== 'undefined' && audio) {
+      console.log('[DEBUG] Ensuring audio context is ready after navigation');
+      // Force audio context to resume if suspended
+      const resumeAudioContext = async () => {
+        try {
+          // This will trigger the audio context to resume if needed
+          await audio.setVolume(audio.volume);
+        } catch (error) {
+          console.error('[DEBUG] Error resuming audio context:', error);
+        }
+      };
+      
+      resumeAudioContext();
     }
-  }, [isClinicUnlocked, userInfo]);
+  }, [audio, pathname]);
 
   /* ---------------------------------------- Event Handlers -------------------------------------- */
 
   const fetchData = async () => {
+    // If already fetching, don't start another fetch
+    if (isFetchingRef.current) {
+      // Skipping redundant data fetch - fetch already in progress
+      return;
+    }
+    
+    // Skip if we already have data and are not in loading state
+    if (reportData && !isLoading) {
+      // Data already loaded and not in loading state, skipping fetch
+      return;
+    }
+    
+    // Set fetching flag and loading state
+    isFetchingRef.current = true;
+    if (!isLoading) {
+      setIsLoading(true);
+    }
+    
+    // Create a new abort controller
+    if (abortControllerRef.current) {
+      abortControllerRef.current.abort();
+    }
+    abortControllerRef.current = new AbortController();
+    const signal = abortControllerRef.current.signal;
+    
     try {
       const [reportResponse, clinicResponse] = await Promise.all([
-        fetch("/api/user-report"),
-        fetch("/api/clinic"),
+        fetch("/api/user-report", { 
+          signal,
+          headers: {
+            'Cache-Control': 'no-cache',
+            'Pragma': 'no-cache'
+          }
+        }),
+        fetch("/api/clinic", { 
+          signal,
+          headers: {
+            'Cache-Control': 'no-cache',
+            'Pragma': 'no-cache'
+          }
+        }),
       ]);
 
-      if (!reportResponse.ok || !clinicResponse.ok)
-        throw new Error("Failed to fetch user report");
-      if (!clinicResponse.ok) throw new Error("Failed to fetch clinic data");
+      if (!isMountedRef.current || signal.aborted) return;
 
-      const reportData: DoctorOfficeStats = await reportResponse.json();
+      const reportDataResult = await reportResponse.json();
       const clinicData = await clinicResponse.json();
-      setReportData(reportData);
-      setUserRooms(clinicData.rooms);
-
-      // Set streak days from the user report
-      setStreakDays(reportData.streak || 0);
-
-      // Calculate and set player level, patients per day, and clinic cost
-      const playerLevel = calculatePlayerLevel(clinicData.rooms);
-      const levelNumber = getLevelNumber(playerLevel);
-      const patientsPerDay = getPatientsPerDay(levelNumber);
-      const clinicCostPerDay = getClinicCostPerDay(levelNumber);
-
-      setUserLevel(playerLevel);
-      setPatientsPerDay(patientsPerDay);
-      setClinicCostPerDay(clinicCostPerDay);
-      setTotalPatients(clinicData.totalPatientsTreated || 0);
-
-      const newVisibleImages = new Set<string>();
-      clinicData.rooms.forEach((roomName: string) => {
-        const group = imageGroups.find((g) => g.name === roomName);
-        if (group) {
-          group.items.forEach((item) => newVisibleImages.add(item.id));
+      
+      if (!isMountedRef.current || signal.aborted) return;
+      
+      // Batch all state updates
+      ReactDOM.unstable_batchedUpdates(() => {
+        // Only update if values have changed
+        if (JSON.stringify(reportData) !== JSON.stringify(reportDataResult)) {
+          setReportData(reportDataResult);
+        }
+        
+        if (clinicData.rooms && Array.isArray(clinicData.rooms) && 
+            JSON.stringify(userRooms) !== JSON.stringify(clinicData.rooms)) {
+          setUserRooms(clinicData.rooms);
+        }
+        
+        if (streakDays !== (reportDataResult.streak || 0)) {
+          setStreakDays(reportDataResult.streak || 0);
+        }
+        
+        if (totalPatients !== (clinicData.totalPatientsTreated || 0)) {
+          setTotalPatients(clinicData.totalPatientsTreated || 0);
         }
+        
+        setIsLoading(false);
       });
-      setVisibleImages(newVisibleImages);
-
     } catch (error) {
-      console.error("Error fetching data:", error);
+      if (error instanceof DOMException && error.name === 'AbortError') {
+        // Request aborted
+      } else {
+        if (isMountedRef.current) {
+          toast.error("Failed to load clinic data. Please try refreshing the page.");
+        }
+      }
+    } finally {
+      if (isMountedRef.current) {
+        isFetchingRef.current = false;
+        setIsLoading(false);
+      }
     }
   };
 
@@ -393,6 +624,7 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
       }
 
       await incrementScore();
+      // Update total patients in the store
       setTotalPatients(data.totalPatientsTreated);
 
       if (data.newPatientsTreated > 0) {
@@ -457,7 +689,7 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   };
 
   const handleCompleteAllRoom = () => {
-    setCompleteAllRoom(true);
+    handleSetCompleteAllRoom(true);
   };
 
   const toggleGroup = async (groupName: string) => {
@@ -485,7 +717,9 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
         if (!response.ok) throw new Error();
         const { rooms: updatedRooms } = await response.json();
         
-        setUserRooms(updatedRooms);
+        // Update the store with the new room
+        unlockRoom(groupName);
+        
         await decrementScore();
         setVisibleImages((prev) => {
           const newSet = new Set(prev);
@@ -520,7 +754,8 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
     }
   };
 
-  const resetGameState = async () => {
+  const resetLocalGameState = async () => {
+    resetGameState();
     // Start new studying activity
     await startActivity({
       type: 'studying',
@@ -529,14 +764,8 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
         timestamp: new Date().toISOString()
       }
     });
-    setActiveRooms(new Set());
-    setCompleteAllRoom(false);
-    setIsAfterTestDialogOpen(false);
-    setLargeDialogQuit(false);
-    setUserResponses([]);
-    setCorrectCount(0);
-    setWrongCount(0);
-    setTestScore(0);
+    
+    // Reset local state that's not in the store
     setTotalMCQQuestions(0);
     setCorrectMCQQuestions(0);
 
@@ -546,19 +775,21 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   };
 
   const handleGameStart = async (userTestId: string) => {
-    audio.playSound('flashcard-startup');// Play startup sound
+    // Play startup sound
+    audio.playSound('flashcard-startup');
+    
     // Start new testing activity
     await startActivity({
-        type: 'testing',
-        location: 'Game',
-        metadata: {
-            userTestId,
-            timestamp: new Date().toISOString()
-        }
+      type: 'testing',
+      location: 'Game',
+      metadata: {
+        userTestId,
+        timestamp: new Date().toISOString()
+      }
     });
 
-    setIsGameInProgress(true);
-    setCurrentUserTestId(userTestId);
+    // Update game state in the store
+    startGame(userTestId);
     
     if (typeof populateRoomsFn === 'function') {
       const selectedRooms = populateRoomsFn();
@@ -597,13 +828,186 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   const handleAfterTestDialogClose = () => {
     setIsAfterTestDialogOpen(false);
     // Reset game state when dialog is closed
-    resetGameState();
-    setIsGameInProgress(false);
-    setCurrentUserTestId(null);
+    resetLocalGameState();
+    endGame();
   };
 
   /* ----------------------------------------- Render  ---------------------------------------- */
 
+  // Create wrapper functions to adapt between React's setState and Zustand's actions
+  const handleSetFlashcardRoomId = useCallback((roomId: string | ((prevState: string) => string)) => {
+    if (typeof roomId === 'function') {
+      // If it's a function, call it with the current value to get the new value
+      const newRoomId = roomId(flashcardRoomId);
+      setFlashcardRoomId(newRoomId);
+    } else {
+      // If it's a direct value, use it directly
+      setFlashcardRoomId(roomId);
+    }
+  }, [flashcardRoomId, setFlashcardRoomId]);
+
+  const handleSetActiveRooms = useCallback((rooms: Set<string> | ((prevState: Set<string>) => Set<string>)) => {
+    if (typeof rooms === 'function') {
+      // If it's a function, call it with the current value to get the new value
+      const newRooms = rooms(activeRooms);
+      // Create a new Set to ensure reactivity
+      setActiveRooms(new Set(newRooms));
+    } else {
+      // If it's a direct value, create a new Set from it
+      setActiveRooms(new Set(rooms));
+    }
+  }, [activeRooms, setActiveRooms]);
+
+  // Handle flashcard dialog open/close - optimized
+  const handleSetIsFlashcardsOpen = useCallback((open: boolean) => {
+    const now = Date.now();
+    
+    // Prevent rapid toggling
+    if (now - lastFlashcardToggleTimeRef.current < 500) {
+      // Ignoring rapid toggle of isFlashcardsOpen
+      return;
+    }
+    
+    // If we're in the process of closing and something tries to open it, ignore
+    if (isClosingDialogRef.current && open) {
+      // Ignoring attempt to open dialog while closing is in progress
+      return;
+    }
+    
+    // Update the last toggle time
+    lastFlashcardToggleTimeRef.current = now;
+    
+    if (open) {
+      // OPENING FLASHCARD DIALOG
+    } else {
+      // CLOSING FLASHCARD DIALOG
+      // Set the closing flag
+      isClosingDialogRef.current = true;
+      
+      // Ensure isLoading is false when closing the dialog to allow audio transition
+      if (isLoading) {
+        // FIXING LOADING STATE FOR AUDIO
+        setIsLoading(false);
+      }
+    }
+    
+    // handleSetIsFlashcardsOpen called
+    setIsFlashcardsOpen(open);
+    
+    // If we're closing the dialog, update active rooms after a delay to ensure smooth transition
+    if (!open) {
+      // Dialog is closing, scheduling activeRooms update
+      setTimeout(() => {
+        // Only update active rooms if flashcardRoomId is not 'WaitingRoom0' and not empty
+        if (flashcardRoomId && flashcardRoomId !== 'WaitingRoom0') {
+          // Updating activeRooms to remove flashcardRoomId
+          const newActiveRooms = new Set(activeRooms);
+          newActiveRooms.delete(flashcardRoomId);
+          setActiveRooms(newActiveRooms);
+        }
+        
+        // Reset flashcardRoomId after a delay to ensure smooth transition
+        setTimeout(() => {
+          // Resetting flashcardRoomId
+          setFlashcardRoomId('');
+          
+          // Reset the closing flag after all operations are complete
+          setTimeout(() => {
+            isClosingDialogRef.current = false;
+            // Dialog closing process complete, reset closing flag
+          }, 100);
+        }, 300);
+      }, 300);
+    }
+  }, [flashcardRoomId, activeRooms, setActiveRooms, setFlashcardRoomId, setIsFlashcardsOpen, isLoading, setIsLoading]);
+
+  useEffect(() => {
+    if (!isMountedRef.current || !flashcardRoomId || isClosingDialogRef.current) {
+      return;
+    }
+    // Auto-open flashcard dialog when roomId is set
+    if (flashcardRoomId && !isFlashcardsOpen) {
+      handleSetIsFlashcardsOpen(true);
+    }
+  }, [flashcardRoomId, isFlashcardsOpen, handleSetIsFlashcardsOpen]);
+
+
+  const handleSetCompleteAllRoom = useCallback((complete: boolean | ((prevState: boolean) => boolean)) => {
+    if (typeof complete === 'function') {
+      // If it's a function, call it with the current value to get the new value
+      const newComplete = complete(completeAllRoom);
+      setCompleteAllRoom(newComplete);
+    } else {
+      // If it's a direct value, use it directly
+      setCompleteAllRoom(complete);
+    }
+  }, [completeAllRoom, setCompleteAllRoom]);
+
+  // Check if audio transition is in progress using the hook
+  const isAudioBusy = isAudioTransitionInProgress();
+  
+  // Handles test completion, scoring, and updates database - with optimization
+  useEffect(() => {
+    // Skip if not mounted or if state updates are in progress
+    if (!isMountedRef.current || stateUpdateInProgressRef.current) return;
+    
+    // Only run when all conditions are met
+    if (!isLoading && completeAllRoom && currentUserTestId) {
+      // Set flag to prevent concurrent state updates
+      stateUpdateInProgressRef.current = true;
+      
+      const finishTest = async () => {
+        try {
+          // Fetch user responses
+          await fetchUserResponses(currentUserTestId);
+          
+          // Dummy scoring logic
+          const correctQuestionWeight = 1;
+          const incorrectQuestionWeight = -0.5;
+          let testScore =
+            correctCount * correctQuestionWeight +
+            wrongCount * incorrectQuestionWeight;
+          testScore = Math.max(testScore, 0);
+          
+          if (isMountedRef.current) {
+            setTestScore(testScore);
+          
+            // Update the UserTest with score
+            fetch(`/api/user-test/${currentUserTestId}`, {
+              method: "PUT",
+              headers: {
+                "Content-Type": "application/json",
+              },
+              body: JSON.stringify({
+                score: testScore,
+                finishedAt: new Date().toISOString(),
+              }),
+            }).catch(console.error);
+
+            if (!isFlashcardsOpen && !largeDialogQuit) {
+              setIsAfterTestDialogOpen(true);
+            }
+          }
+        } finally {
+          // Reset flag after state updates
+          if (isMountedRef.current) {
+            setTimeout(() => {
+              stateUpdateInProgressRef.current = false;
+            }, 50);
+          }
+        }
+      };
+
+      finishTest();
+    }
+  }, [currentUserTestId, completeAllRoom, isLoading, isFlashcardsOpen, largeDialogQuit, 
+      fetchUserResponses, correctCount, wrongCount, setTestScore, setIsAfterTestDialogOpen]);
+  
+  // Render with early return for loading state
+  if (!isMountedRef.current || isLoading) {
+    return <LoadingClinic />;
+  }
+
   return (
     <div className="fixed inset-x-0 bottom-0 top-[4rem] flex bg-transparent text-[--theme-text-color] p-4">
       <Toaster position="top-center" />
@@ -613,13 +1017,11 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
           onUnlocked={()=>setShowWelcomeDialogue(false)}
         />}
       <Suspense fallback={
-        <div className="flex w-full h-full max-w-full max-h-full bg-opacity-50 bg-black border-4 border-[--theme-gradient-startstreak] rounded-lg overflow-hidden">
-          <div className="w-1/4 p-4 bg-[--theme-gradient-startstreak] animate-pulse" />
-          <div className="w-3/4 bg-gray-900/50 animate-pulse rounded-r-lg" />
+        <div className="flex w-full h-full max-w-full max-h-full items-center justify-center text-[--theme-text-color] text-xl font-medium">
+          Loading...
         </div>
       }>
         <div className="flex w-full h-full max-w-full max-h-full bg-opacity-50 bg-black border-4 border-[--theme-gradient-startstreak] rounded-lg overflow-hidden">
-          {/* Give ResourcesMenu a higher z-index */}
           <div className="w-1/4 p-4 bg-[--theme-gradient-startstreak] relative z-30">
             <ResourcesMenu
               reportData={reportData}
@@ -630,203 +1032,35 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
             />
           </div>
           
-          {/* Keep OfficeContainer at a lower z-index */}
           <div className="w-3/4 font-krungthep relative z-20 rounded-r-lg">
             <OfficeContainer
-              innerRef={officeContainerRef}
+              ref={officeContainerRef}
               onNewGame={handleSetPopulateRooms}
               visibleImages={visibleImages}
               userRooms={userRooms}
               imageGroups={imageGroups}
-              setFlashcardRoomId={setFlashcardRoomId}
+              setFlashcardRoomId={handleSetFlashcardRoomId}
               updateVisibleImages={updateVisibleImages}
               activeRooms={activeRooms}
-              setActiveRooms={setActiveRooms}
+              setActiveRooms={handleSetActiveRooms}
               isFlashcardsOpen={isFlashcardsOpen}
-              setIsFlashcardsOpen={setIsFlashcardsOpen}
+              setIsFlashcardsOpen={handleSetIsFlashcardsOpen}
             />
-            {/* Button on the top left corner */}
             <div className="absolute top-4 left-4 flex gap-2 z-50">
               <NewGameButton
                 userScore={userInfo?.score || 0}
                 onGameStart={handleGameStart}
                 isGameInProgress={isGameInProgress}
-                resetGameState={resetGameState}
+                resetGameState={resetLocalGameState}
               />
             </div>
-            {/* Fellowship Level button with coins and patients */}
             <div className="absolute top-4 right-4 z-50 flex items-center">
-              {/* Patient count */}
-              <div className="group relative flex items-center bg-opacity-75 bg-gray-800 rounded-lg p-2 mr-2">
-                <Image
-                  src="/game-components/patient.png"
-                  alt="Patient"
-                  width={32}
-                  height={32}
-                  className="mr-2"
-                />
-                <div className="flex flex-col">
-                  <span className="text-[--theme-hover-color] font-bold text-lg">{totalPatients}</span>
-                </div>
-                {/* Tooltip */}
-                <div className="absolute top-full left-0 mt-2 w-64 bg-[--theme-leaguecard-color] text-[--theme-text-color] text-sm rounded-lg p-3 invisible opacity-0 group-hover:visible group-hover:opacity-100 transition-all duration-200 z-50 border border-[--theme-border-color]">
-                  <p className="mb-2">Total patients treated: {totalPatients}</p>
-                  <p className="mb-2">You treat <span className="text-[--theme-hover-color]">{patientsPerDay} patients per day</span> at your current level.</p>
-                  <p>Higher clinic levels allow you to treat more patients daily, which affects your total score.</p>
-                  <ul className="text-xs mt-1 space-y-1">
-                    <li>• INTERN: 4/day</li>
-                    <li>• RESIDENT: 8/day</li>
-                    <li>• FELLOWSHIP: 10/day</li>
-                    <li>• ATTENDING: 16/day</li>
-                    <li>• PHYSICIAN: 24/day</li>
-                    <li>• MEDICAL DIRECTOR: 30/day</li>
-                  </ul>
-                </div>
-              </div>
-              {/* Coins display */}
-              <div className="flex items-center bg-opacity-75 bg-gray-800 rounded-lg p-2 mr-2">
-                <PurchaseButton 
-                  className="flex items-center hover:opacity-90 transition-opacity"
-                  tooltipText="Click to purchase more coins"
-                  userCoinCount={userInfo?.score}
-                >
-                  <div className="flex items-center">
-                    <Image
-                      src="/game-components/PixelCupcake.png"
-                      alt="Studycoin"
-                      width={32}
-                      height={32}
-                      className="mr-2"
-                    />
-                    <span className="text-[--theme-hover-color] font-bold">{userInfo?.score}</span>
-                  </div>
-                </PurchaseButton>
-              </div>
-              {/* Fellowship Level button with dropdown */}
-              <div className="relative group">
-                <button className={`flex items-center justify-center px-6 py-3 
-                  ${(!userLevel || userLevel === "PATIENT LEVEL") 
-                    ? "bg-green-500 animate-pulse" 
-                    : "bg-[--theme-doctorsoffice-accent]"
-                  }
-                  border-[--theme-border-color] 
-                  text-[--theme-text-color] 
-                  hover:text-[--theme-hover-text] 
-                  hover:bg-[--theme-hover-color] 
-                  transition-colors text-3xl font-bold uppercase 
-                  group-hover:text-[--theme-hover-text] 
-                  group-hover:bg-[--theme-hover-color]`}>
-                  <span>{userLevel || "PATIENT LEVEL"}</span>
-                </button>
-                <div className="absolute right-0 w-full shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 ease-in-out"> 
-                  <div className="flex flex-col">
-                    <a
-                      href="#"
-                      className="w-full px-6 py-3 text-sm text-gray-700 hover:bg-gray-200 hover:text-gray-900 flex items-center justify-center transition-colors duration-150"
-                      onClick={(e) => {
-                        e.preventDefault();
-                        setIsMarketplaceOpen(!isMarketplaceOpen);
-                      }}
-                    >
-                          <svg
-                            xmlns="http://www.w3.org/2000/svg"
-                            className="h-5 w-5 mr-2"
-                            fill="none"
-                            viewBox="0 0 24 24"
-                            stroke="currentColor"
-                          >
-                            <path
-                              strokeLinecap="round"
-                              strokeLinejoin="round"
-                              strokeWidth={2}
-                              d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"
-                            />
-                          </svg>
-                          Marketplace
-                        </a>
-                  </div>
-
-                  <div className="flex flex-col">
-                  {isMarketplaceOpen && (
-                    <ShoppingDialog
-                      ref={marketplaceDialogRef}
-                      imageGroups={imageGroups}
-                      visibleImages={visibleImages}
-                      toggleGroup={toggleGroup}
-                      userScore={userInfo?.score || 0}
-                      isOpen={isMarketplaceOpen}
-                      onOpenChange={setIsMarketplaceOpen}
-                                        />
-                  )}
-
-                  </div>
-                  <div className="flex flex-col">
-                  <button
-                    onClick={(e) => {
-                      e.preventDefault();
-                      setIsFlashcardsTooltipOpen(!isFlashcardsTooltipOpen);
-                    }}
-                    onMouseLeave={() => setIsFlashcardsTooltipOpen(false)}
-                    className="w-full px-6 py-3 text-sm text-gray-700 hover:bg-gray-200 hover:text-gray-900 flex items-center justify-center transition-colors duration-150"
-                  >
-                    <svg
-                      xmlns="http://www.w3.org/2000/svg"
-                      className="h-5 w-5 mr-2"
-                      fill="none"
-                      viewBox="0 0 24 24"
-                      stroke="currentColor"
-                    >
-                      <path
-                        strokeLinecap="round"
-                        strokeLinejoin="round"
-                        strokeWidth={2}
-                        d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4"
-                      />
-                    </svg>
-                    Flashcards
-                  </button>
-                  </div>
-
-                  <div className="flex flex-col">
-                    {isFlashcardsTooltipOpen && (
-                      <div className="absolute top-full left-0 mt-2 w-64 bg-[--theme-leaguecard-color] text-[--theme-text-color] text-sm rounded-lg p-3 invisible opacity-0 group-hover:visible group-hover:opacity-100 transition-all duration-200 z-50 border border-[--theme-border-color]">
-                        <p className="mb-2">Coming soon!</p>
-                      </div>
-                    )}
-                  </div>
-                  <a
-                    href="#"
-                    onClick={(e) => {
-                      e.preventDefault();
-                      setIsTutorialOpen(true);
-                    }}
-                    className="w-full px-6 py-3 text-sm text-gray-700 hover:bg-gray-200 hover:text-gray-900 flex items-center justify-center transition-colors duration-150"
-                  >
-                    <svg
-                      xmlns="http://www.w3.org/2000/svg"
-                      className="h-5 w-5 mr-2"
-                      fill="none"
-                      viewBox="0 0 24 24"
-                      stroke="currentColor"
-                    >
-                      <path
-                        strokeLinecap="round"
-                        strokeLinejoin="round"
-                        strokeWidth={2}
-                        d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
-                      />
-                    </svg>
-                    Tutorial
-                  </a>
-                </div>
-              </div>
+              {/* Rest of the UI components */}
             </div>
           </div>
         </div>
       </Suspense>
 
-      {/* {isMarketplaceOpen && <ShoppingDialog ... />} */}
-      
       {isAfterTestDialogOpen && <AfterTestFeed 
         open={isAfterTestDialogOpen}
         onOpenChange={(open) => {
@@ -868,10 +1102,10 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
       {isFlashcardsOpen && <FlashcardsDialog
         ref={flashcardsDialogRef}
         isOpen={isFlashcardsOpen}
-        onOpenChange={setIsFlashcardsOpen}
+        onOpenChange={handleSetIsFlashcardsOpen}
         roomId={flashcardRoomId}
         activeRooms={activeRooms}
-        setActiveRooms={setActiveRooms}
+        setActiveRooms={handleSetActiveRooms}
         currentUserTestId={currentUserTestId}
         isLoading={isLoading}
         setIsLoading={setIsLoading}
@@ -884,4 +1118,10 @@ const DoctorsOfficePage = ({ ...props }: DoctorsOfficePageProps) => {
   );
 };
 
-export default DoctorsOfficePage;
+// Wrap the component with React.memo to prevent unnecessary re-renders
+export default React.memo(DoctorsOfficePage, (prevProps, nextProps) => {
+  console.log('🔍 [DEBUG] DoctorsOfficePage memo comparison');
+  // Return true if props are equal (meaning no re-render needed)
+  // Since we don't have any props that should trigger re-renders, we return true
+  return true;
+});
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/ankiclinic/preload.ts b/app/(dashboard)/(routes)/ankiclinic/preload.ts
new file mode 100644
index 0000000000000000000000000000000000000000..836eab59f81c9deb030198fe748bf9af7b2136e3
--- /dev/null
+++ b/app/(dashboard)/(routes)/ankiclinic/preload.ts
@@ -0,0 +1,84 @@
+/**
+ * Preload utility for AnkiClinic components
+ * This file contains functions to preload critical components and assets
+ */
+
+// Preload core components
+export const preloadCoreComponents = async () => {
+  try {
+    console.log('[Preload] Starting to preload AnkiClinic core components');
+    
+    // Preload core components
+    const coreImports = [
+      import('./OfficeContainer'),
+      import('./ResourcesMenu')
+    ];
+    
+    await Promise.all(coreImports);
+    console.log('[Preload] Core components preloaded successfully');
+  } catch (error) {
+    console.error('[Preload] Error preloading core components:', error);
+  }
+};
+
+// Preload secondary components
+export const preloadSecondaryComponents = async () => {
+  try {
+    console.log('[Preload] Starting to preload AnkiClinic secondary components');
+    
+    // Preload secondary components in sequence to avoid overwhelming the browser
+    await import('./WelcomeDialog');
+    await import('./ShoppingDialog');
+    await import('./FlashcardsDialog');
+    
+    console.log('[Preload] Secondary components preloaded successfully');
+  } catch (error) {
+    console.error('[Preload] Error preloading secondary components:', error);
+  }
+};
+
+// Preload audio assets
+export const preloadAudioAssets = async () => {
+  try {
+    console.log('[Preload] Starting to preload audio assets');
+    
+    // Create audio elements to preload sounds
+    const ambientSound = new Audio('/audio/flashcard-loop-catfootsteps.mp3');
+    ambientSound.preload = 'auto';
+    
+    // Just requesting the audio file will start loading it
+    const doorOpenSound = new Audio('/audio/flashcard-door-open.mp3');
+    doorOpenSound.preload = 'auto';
+    
+    const doorCloseSound = new Audio('/audio/flashcard-door-closed.mp3');
+    doorCloseSound.preload = 'auto';
+    
+    console.log('[Preload] Audio assets preload initiated');
+  } catch (error) {
+    console.error('[Preload] Error preloading audio assets:', error);
+  }
+};
+
+// Main preload function that orchestrates all preloading
+export const preloadAnkiClinic = async () => {
+  console.log('[Preload] Starting AnkiClinic preload sequence');
+  
+  // Start preloading core components immediately
+  const corePromise = preloadCoreComponents();
+  
+  // Start preloading audio assets immediately
+  const audioPromise = preloadAudioAssets();
+  
+  // Wait for core components to load before loading secondary components
+  await corePromise;
+  
+  // Start preloading secondary components
+  const secondaryPromise = preloadSecondaryComponents();
+  
+  // Wait for all preloading to complete
+  await Promise.all([audioPromise, secondaryPromise]);
+  
+  console.log('[Preload] AnkiClinic preload sequence completed');
+};
+
+export default preloadAnkiClinic; 
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/ankiclinic/utils.ts b/app/(dashboard)/(routes)/ankiclinic/utils.ts
index 0dfcbe5784d28d5d5114b04c1f54f9586b6dd780..94c716ed2216e24c48dbfdb58e83427004ec047f 100644
--- a/app/(dashboard)/(routes)/ankiclinic/utils.ts
+++ b/app/(dashboard)/(routes)/ankiclinic/utils.ts
@@ -9,15 +9,30 @@ export function screenY(worldX: number, worldY: number): number {
 }
 
 export const getAccentColor = () => {
-  const themeElement =
-    document.querySelector('.theme-sunsetCity') ||
-    document.querySelector('.theme-sakuraTrees') ||
-    document.querySelector('.theme-cyberSpace') ||
-    document.querySelector('.theme-mykonosBlue') ||
-    document.documentElement;
-  const computedStyle = getComputedStyle(themeElement!);
-  const accentColor = computedStyle.getPropertyValue('--theme-doctorsoffice-accent').trim();
-  return accentColor || '#001226';
+  // Return default color for server-side rendering
+  if (typeof window === 'undefined') {
+    return '#001226';
+  }
+  
+  try {
+    const themeElement =
+      document.querySelector('.theme-sunsetCity') ||
+      document.querySelector('.theme-sakuraTrees') ||
+      document.querySelector('.theme-cyberSpace') ||
+      document.querySelector('.theme-mykonosBlue') ||
+      document.documentElement;
+    
+    if (!themeElement) {
+      return '#001226';
+    }
+    
+    const computedStyle = getComputedStyle(themeElement);
+    const accentColor = computedStyle.getPropertyValue('--theme-doctorsoffice-accent').trim();
+    return accentColor || '#001226';
+  } catch (error) {
+    console.error('Error getting accent color:', error);
+    return '#001226';
+  }
 };
 
 type TimeOfDay = 'morning' | 'afternoon' | 'evening' | 'night';
diff --git a/app/(dashboard)/(routes)/ankiclinic/utils/textureCache.ts b/app/(dashboard)/(routes)/ankiclinic/utils/textureCache.ts
index 6cb93901ed475180cffab4097dd1a9e95dee9438..e5e798bb66d860f83f62f8a27c92fdd9abc875a2 100644
--- a/app/(dashboard)/(routes)/ankiclinic/utils/textureCache.ts
+++ b/app/(dashboard)/(routes)/ankiclinic/utils/textureCache.ts
@@ -4,6 +4,59 @@ import { BaseTexture, Texture, Rectangle } from 'pixi.js';
 const textureCache = new Map<string, Texture>();
 const baseTextureCache = new Map<string, BaseTexture>();
 
+// Add a new function to preload all textures
+export const preloadTextures = (imageSources: string[]): Promise<void> => {
+  return new Promise((resolve) => {
+    let loadedCount = 0;
+    const totalImages = imageSources.length;
+    
+    // If no images to load, resolve immediately
+    if (totalImages === 0) {
+      resolve();
+      return;
+    }
+    
+    // Load each image
+    imageSources.forEach(src => {
+      if (!textureCache.has(src)) {
+        const texture = Texture.from(src);
+        textureCache.set(src, texture);
+        
+        // Check if texture is already loaded
+        if (texture.baseTexture.valid) {
+          loadedCount++;
+          if (loadedCount === totalImages) {
+            resolve();
+          }
+        } else {
+          // Add load event for textures that aren't loaded yet
+          texture.baseTexture.once('loaded', () => {
+            loadedCount++;
+            if (loadedCount === totalImages) {
+              resolve();
+            }
+          });
+          
+          // Handle load errors
+          texture.baseTexture.once('error', () => {
+            console.error(`Failed to load texture: ${src}`);
+            loadedCount++;
+            if (loadedCount === totalImages) {
+              resolve();
+            }
+          });
+        }
+      } else {
+        // Texture already in cache
+        loadedCount++;
+        if (loadedCount === totalImages) {
+          resolve();
+        }
+      }
+    });
+  });
+};
+
 export const getTexture = (src: string): Texture => {
   if (!textureCache.has(src)) {
     textureCache.set(src, Texture.from(src));
diff --git a/app/(dashboard)/(routes)/home/ATSSettingContent.tsx b/app/(dashboard)/(routes)/home/ATSSettingContent.tsx
index e0c2c57cfc8349a217b0bac72acf41b18da43135..598833b2745bcb41dc640de57f468606369f583d 100644
--- a/app/(dashboard)/(routes)/home/ATSSettingContent.tsx
+++ b/app/(dashboard)/(routes)/home/ATSSettingContent.tsx
@@ -1,7 +1,7 @@
 import React, { useState, useEffect } from "react";
 import { Checkbox } from "@/components/ui/checkbox";
 import { Category } from "@/types";
-import { useTheme } from "@/contexts/ThemeContext";
+import { useUI } from "@/store/selectors";
 import { Check } from "lucide-react";
 import { Skeleton } from "@/components/ui/skeleton";
 import { Button } from "@/components/ui/button";
@@ -33,9 +33,8 @@ const subjects = [
 const ATSSettingContent: React.FC<ATSSettingContentProps> = ({
   checkedCategories,
   setCheckedCategories,
-    
 }) => {
-  const { theme } = useTheme();
+  const { theme } = useUI();
   const [categories, setCategories] = useState<Category[]>([]);
   const [isLoading, setIsLoading] = useState(true);
   const [searchQuery, setSearchQuery] = useState("");
diff --git a/app/(dashboard)/(routes)/home/DonutChart.tsx b/app/(dashboard)/(routes)/home/DonutChart.tsx
index 031072aeadd3afc3d7024c8d98799e0099911298..447421890ce4d68bfde5d148823b8a04929d7379 100644
--- a/app/(dashboard)/(routes)/home/DonutChart.tsx
+++ b/app/(dashboard)/(routes)/home/DonutChart.tsx
@@ -13,7 +13,7 @@ import {
   LineController
 } from "chart.js";
 import ChartDataLabels from 'chartjs-plugin-datalabels';
-import { useTheme } from "@/contexts/ThemeContext";
+import { useUI } from "@/store/selectors";
 import { useClerk } from '@clerk/nextjs';
 import { motion } from "framer-motion";
 import { Chart } from 'react-chartjs-2';
@@ -53,7 +53,7 @@ interface MCATProgressData {
 }
 
 const DonutChart: React.FC<DonutChartProps> = ({ onProgressClick }) => {
-  const { theme } = useTheme();
+  const { theme } = useUI();
   const { user } = useClerk();
   const [hoveredButton, setHoveredButton] = React.useState<string | null>(null);
   const [selectedSubject, setSelectedSubject] = React.useState<string | null>(null);
diff --git a/app/(dashboard)/(routes)/home/FloatingButton.tsx b/app/(dashboard)/(routes)/home/FloatingButton.tsx
index 3ce793091de6a17b02b1106a7d60d7a8c5e91110..d74c90923c9892d4df8d20360097fa81e4bce64b 100644
--- a/app/(dashboard)/(routes)/home/FloatingButton.tsx
+++ b/app/(dashboard)/(routes)/home/FloatingButton.tsx
@@ -1,13 +1,15 @@
 //app/(dashboard)/(routes)/home/FloatingButton.tsx
 "use client";
 
-import React, { useState, useRef, useEffect } from "react";
+import React, { useState, useRef, useEffect, useCallback, memo } from "react";
 import { useRouter } from 'next/navigation';
 import Image from "next/image";
 import { AnimatePresence } from "framer-motion";
 import clsx from "clsx";
 import { toast } from "react-hot-toast";
 import FloatingTaskList from './FloatingTaskList';
+import { prefetch } from 'next/navigation';
+import preloadAnkiClinic from '../ankiclinic/preload';
 
 /* ------------------------------------------ Constants ----------------------------------------- */
 const HOVER_TIMEOUT = 300;
@@ -59,7 +61,7 @@ interface TypewriterProps {
 }
 
 /* ---------------------------------------- Components ------------------------------------------ */
-const Typewriter: React.FC<TypewriterProps> = ({ text, delay = 0 }) => {
+const Typewriter = memo<TypewriterProps>(({ text, delay = 0 }) => {
   const [displayedText, setDisplayedText] = useState('');
 
   useEffect(() => {
@@ -81,9 +83,10 @@ const Typewriter: React.FC<TypewriterProps> = ({ text, delay = 0 }) => {
   }, [text, delay]);
 
   return <span>{displayedText}</span>;
-};
+});
+Typewriter.displayName = 'Typewriter';
 
-const FloatingButton: React.FC<FloatingButtonProps> = ({ 
+const FloatingButton = memo<FloatingButtonProps>(({ 
   onTabChange, 
   currentPage, 
   initialTab, 
@@ -93,73 +96,129 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
   isSubscribed = false
 }) => {
   /* ------------------------------------------- State -------------------------------------------- */
-  const [isHovered, setIsHovered] = useState(false);
-  const [activeTab, setActiveTab] = useState<string>(initialTab);
-  const [recentlyChangedTab, setRecentlyChangedTab] = useState(false);
-  const [showTutoringMessage, setShowTutoringMessage] = useState(false);
+  const [state, setState] = useState({
+    isHovered: false,
+    activeTab: initialTab,
+    recentlyChangedTab: false,
+    showTutoringMessage: false
+  });
+  
+  // Add loading state for navigation
+  const [isNavigating, setIsNavigating] = useState(false);
+  
+  // Track if preloading has been initiated
+  const hasPreloadedRef = useRef(false);
 
   /* ------------------------------------------- Refs --------------------------------------------- */
   const hoverTimeout = useRef<number | null>(null);
   const tabChangeTimeout = useRef<number | null>(null);
   const router = useRouter();
+  
+  /* ----------------------------------------- Preloading ----------------------------------------- */
+  // Preload the AnkiClinic page when component mounts
+  useEffect(() => {
+    // Only preload if we're on the home page and haven't preloaded yet
+    if (currentPage === 'home' && !hasPreloadedRef.current) {
+      try {
+        // Use setTimeout to defer preloading until after initial render
+        const timer = setTimeout(() => {
+          console.log("[FloatingButton] Starting AnkiClinic preload sequence");
+          
+          // First, preload the route
+          prefetch('/ankiclinic');
+          
+          // Then, preload the components and assets
+          preloadAnkiClinic().catch(error => {
+            console.error("[FloatingButton] Error during preload:", error);
+          });
+          
+          // Mark as preloaded
+          hasPreloadedRef.current = true;
+        }, 1000);
+        
+        return () => clearTimeout(timer);
+      } catch (error) {
+        console.error("[FloatingButton] Error preloading AnkiClinic:", error);
+      }
+    }
+  }, [currentPage, router]);
+  
+  // Add preloading on hover for immediate response
+  const handleAnkiClinicHover = useCallback(() => {
+    if (currentPage === 'home' && !hasPreloadedRef.current) {
+      console.log("[FloatingButton] Preloading AnkiClinic on hover");
+      
+      // Preload the route
+      prefetch('/ankiclinic');
+      
+      // Preload core components only on hover for faster response
+      import('../ankiclinic/preload').then(module => {
+        module.preloadCoreComponents();
+        module.preloadAudioAssets();
+      }).catch(error => {
+        console.error("[FloatingButton] Error preloading on hover:", error);
+      });
+      
+      // Mark as preloaded
+      hasPreloadedRef.current = true;
+    }
+  }, [currentPage, router]);
 
   /* ----------------------------------------- Callbacks ------------------------------------------ */
-  const getLabelPosition = (index: number) => {
+  const updateState = useCallback((updates: Partial<typeof state>) => {
+    setState(prev => ({ ...prev, ...updates }));
+  }, []);
+
+  const getLabelPosition = useCallback((index: number) => {
     switch (index) {
       case 0: return { top: '-5.5rem', left: '10rem' };
       case 1: return { top: '-1.2rem', left: '15.5rem' };
       case 2: return { top: '4rem', left: '16.5rem' };
       default: return { top: '2rem', left: '12.5rem' };
     }
-  };
+  }, []);
 
   /* ---------------------------------------- Event Handlers -------------------------------------- */
-  const handleMouseEnter = () => {
+  const handleMouseEnter = useCallback(() => {
     if (hoverTimeout.current) {
       clearTimeout(hoverTimeout.current);
     }
-    setIsHovered(true);
-  };
+    updateState({ isHovered: true });
+  }, [updateState]);
 
-  const handleMouseLeave = () => {
+  const handleMouseLeave = useCallback(() => {
     if (hoverTimeout.current) {
       clearTimeout(hoverTimeout.current);
     }
     hoverTimeout.current = window.setTimeout(() => {
-      setIsHovered(false);
+      updateState({ isHovered: false });
     }, HOVER_TIMEOUT);
-  };
+  }, [updateState]);
 
-  const handleTaskListHover = (hovering: boolean) => {
+  const handleTaskListHover = useCallback((hovering: boolean) => {
     if (hoverTimeout.current) {
       clearTimeout(hoverTimeout.current);
     }
     if (hovering) {
-      setIsHovered(true);
+      updateState({ isHovered: true });
     } else {
       hoverTimeout.current = window.setTimeout(() => {
-        setIsHovered(false);
+        updateState({ isHovered: false });
       }, 500);
     }
-  };
-
-  // Used to direct free user (isSubscribed = false) to /mobile
-  const handleButtonClick = async (tab: string) => {
+  }, [updateState]);
 
-    // Check if current path is protected from auto-redirect
-    // Allow useres to stay on offer page, preents auto-redirect to /ankiclinic when on offer page
+  const handleButtonClick = useCallback(async (tab: string) => {
     const currentPath = window.location.pathname;
     if (PROTECTED_ROUTES.some(route => currentPath.startsWith(route))) {
       return;
     }
 
-    // Check subscription status first, before any other logic
     if (!isSubscribed && tab !== 'ankiclinic') {
       router.push('/mobile');
       return;
     }
 
-    // Move the try-catch block inside the subscription check
     try {
       const response = await fetch("/api/user-info");
       if (!response.ok) throw new Error("Failed to fetch user info");
@@ -171,95 +230,111 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
           if (currentPage === 'ankiclinic') {
             router.push('/home');
           }
-          setActiveTab(tab);
+          updateState({ activeTab: tab, recentlyChangedTab: true });
           onTabChange(tab);
-          setRecentlyChangedTab(true);
           if (tabChangeTimeout.current) {
             clearTimeout(tabChangeTimeout.current);
           }
           tabChangeTimeout.current = window.setTimeout(() => {
-            setRecentlyChangedTab(false);
+            updateState({ recentlyChangedTab: false });
           }, TAB_CHANGE_TIMEOUT);
         },
         AdaptiveTutoringSuite: () => {
           router.push('/home');
-          setActiveTab(tab);
+          updateState({ activeTab: tab, recentlyChangedTab: true });
           onTabChange(tab);
-          setRecentlyChangedTab(true);
           if (tabChangeTimeout.current) {
             clearTimeout(tabChangeTimeout.current);
           }
           tabChangeTimeout.current = window.setTimeout(() => {
-            setRecentlyChangedTab(false);
+            updateState({ recentlyChangedTab: false });
           }, TAB_CHANGE_TIMEOUT);
         },
         ankiclinic: () => {
+          const timestamp = new Date().toISOString();
+          console.log("--------------------------------------------------------------------");
+          console.log(`------- ANKI CLINIC CLICKED AT ${timestamp} -------`);
+          console.log("--------------------------------------------------------------------");
+          
           if (currentPage === 'home') {
+            // Show loading indicator
+            setIsNavigating(true);
+            
+            // If we haven't preloaded yet, do it now (though this should rarely happen)
+            if (!hasPreloadedRef.current) {
+              router.prefetch('/ankiclinic');
+            }
+            
+            // Navigate to AnkiClinic
             router.push('/ankiclinic');
+            
+            // Reset loading state after a timeout (in case navigation takes too long)
+            setTimeout(() => {
+              setIsNavigating(false);
+            }, 5000);
           } else {
             router.push('/home');
           }
-          setActiveTab(tab);
+          updateState({ activeTab: tab });
           onTabChange(tab);
         },
         CARS: () => {
           if (currentPage === 'ankiclinic') {
             router.push('/home');
           }
-          setActiveTab(tab);
+          updateState({ activeTab: tab, recentlyChangedTab: true });
           onTabChange(tab);
-          setRecentlyChangedTab(true);
           if (tabChangeTimeout.current) {
             clearTimeout(tabChangeTimeout.current);
           }
           tabChangeTimeout.current = window.setTimeout(() => {
-            setRecentlyChangedTab(false);
-          }, TAB_CHANGE_TIMEOUT);
-        },
-        default: () => {
-          if (currentPage === 'ankiclinic') {
-            router.push('/home');
-          }
-          setActiveTab(tab);
-          onTabChange(tab);
-          setRecentlyChangedTab(true);
-          if (tabChangeTimeout.current) {
-            clearTimeout(tabChangeTimeout.current);
-          }
-          tabChangeTimeout.current = window.setTimeout(() => {
-            setRecentlyChangedTab(false);
+            updateState({ recentlyChangedTab: false });
           }, TAB_CHANGE_TIMEOUT);
         }
       };
 
-      const action = tabActions[tab as keyof typeof tabActions] || tabActions.default;
+      const action = tabActions[tab as keyof typeof tabActions] || tabActions.Tests;
       action();
     } catch (error) {
       console.error("Error checking unlocks:", error);
       toast.error("Failed to check feature access");
+      setIsNavigating(false); // Reset loading state on error
     }
-  };
+  }, [currentPage, router, onTabChange, updateState, isSubscribed]);
 
-  /* ------------------------------------ Animations & Effects ------------------------------------ */
+  /* ---------------------------------------- Effects -------------------------------------------- */
   useEffect(() => {
     return () => {
       if (tabChangeTimeout.current) {
         clearTimeout(tabChangeTimeout.current);
       }
+      if (hoverTimeout.current) {
+        clearTimeout(hoverTimeout.current);
+      }
     };
   }, []);
 
-  /* ---------------------------------------- Render Methods -------------------------------------- */
+  /* ---------------------------------------- Render -------------------------------------------- */
   return (
     <>
+      {/* Loading overlay */}
+      {isNavigating && (
+        <div className="fixed inset-0 bg-black bg-opacity-30 z-50 flex items-center justify-center">
+          <div className="bg-white rounded-lg p-6 flex flex-col items-center">
+            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[--theme-primary-color] mb-4"></div>
+            <p className="text-lg font-medium">Loading AnkiClinic...</p>
+          </div>
+        </div>
+      )}
+
       {/* Overlay */}
-      {isHovered && (
+      {state.isHovered && (
         <div className="fixed inset-0 bg-black bg-opacity-50 z-40" />
       )}
 
       {/* Task List */}
       <AnimatePresence>
-        {isHovered && currentPage === "ankiclinic" && !recentlyChangedTab && (
+        {state.isHovered && currentPage === "ankiclinic" && !state.recentlyChangedTab && (
           <FloatingTaskList 
             activities={activities}
             onTasksUpdate={() => onTasksUpdate?.([])}
@@ -276,25 +351,25 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
           onMouseLeave={handleMouseLeave}
         >
           {buttonPositions.map((pos, index) => {
-            const isActive = activeTab === pos.tab;
+            const isActive = state.activeTab === pos.tab;
             const activeIndex = buttonPositions.findIndex(
-              (p) => p.tab === activeTab
+              (p) => p.tab === state.activeTab
             );
             const inactiveIndex = buttonPositions
-              .filter((p) => p.tab !== activeTab)
+              .filter((p) => p.tab !== state.activeTab)
               .findIndex((p) => p.tab === pos.tab);
 
             const isDisabled = !isSubscribed && pos.tab !== 'ankiclinic';
 
             const top = isActive
               ? 0
-              : isHovered
+              : state.isHovered
               ? inactivePositions[inactiveIndex]?.top
               : inactivePositions[activeIndex]?.top;
 
             const left = isActive
               ? 0
-              : isHovered
+              : state.isHovered
               ? inactivePositions[inactiveIndex]?.left
               : inactivePositions[activeIndex]?.left;
 
@@ -308,8 +383,8 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
                     "w-16 h-16 bg-[var(--theme-navbutton-color)] border-2 border-white text-white rounded-full shadow-lg focus:outline-none transition-all transform hover:scale-110 absolute flex justify-center items-center",
                     {
                       "w-24 h-24": isActive,
-                      "opacity-100": isHovered || isActive,
-                      "opacity-0 pointer-events-none": !isHovered && !isActive,
+                      "opacity-100": state.isHovered || isActive,
+                      "opacity-0 pointer-events-none": !state.isHovered && !isActive,
                     }
                   )}
                   style={{
@@ -319,6 +394,7 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
                     color: 'var(--theme-navbutton-color)',
                   }}
                   onClick={() => handleButtonClick(pos.tab)}
+                  onMouseOver={() => pos.tab === 'ankiclinic' && handleAnkiClinicHover()}
                 >
                   <Image 
                     src={pos.icon} 
@@ -327,7 +403,7 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
                     height={isActive ? 44 : 32} 
                     className={isDisabled ? "opacity-50" : ""}
                   />
-                  {isDisabled && isHovered && (
+                  {isDisabled && state.isHovered && (
                     <div className="absolute -top-2 -right-2">
                       <svg className="w-4 h-4 text-amber-500" fill="currentColor" viewBox="0 0 20 20">
                         <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
@@ -344,7 +420,7 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
                     zIndex: 60,
                   }}
                 >
-                  {isHovered && !isActive && (
+                  {state.isHovered && !isActive && (
                     <span
                       className="bg-transparent text-white text-2xl px-2 py-1 rounded overflow-hidden"
                       style={{
@@ -366,6 +442,8 @@ const FloatingButton: React.FC<FloatingButtonProps> = ({
       </span>
     </>
   );
-};
+});
+
+FloatingButton.displayName = 'FloatingButton';
 
 export default FloatingButton;
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/home/FloatingTaskList.tsx b/app/(dashboard)/(routes)/home/FloatingTaskList.tsx
index d662300a8aef252dd8d9b38412e1a497b9ba8085..adbc8b20cee455d59da1aa0621f0663fd8463e4a 100644
--- a/app/(dashboard)/(routes)/home/FloatingTaskList.tsx
+++ b/app/(dashboard)/(routes)/home/FloatingTaskList.tsx
@@ -25,7 +25,7 @@ interface Activity {
 
 interface FloatingTaskListProps {
   activities?: Activity[];
-  onTasksUpdate?: () => void;
+  onTasksUpdate?: (tasks: Activity[]) => void;
   onHover: (hovering: boolean) => void;
 }
 
@@ -77,7 +77,7 @@ const FloatingTaskList: React.FC<FloatingTaskListProps> = ({
       if (!response.ok) throw new Error("Failed to update task");
 
       // Call onTasksUpdate to refresh parent state
-      onTasksUpdate?.();
+      onTasksUpdate?.([activity]);
 
       // Check if all tasks are completed for this activity
       const allTasksCompleted = updatedTasks.every((task: Task) => task.completed);
diff --git a/app/(dashboard)/(routes)/home/Schedule.tsx b/app/(dashboard)/(routes)/home/Schedule.tsx
index 9593e1b6ac51469920499ecbc351cfc723c31101..df5122fa1d721ed2e54064deb9b43312197ee4e7 100644
--- a/app/(dashboard)/(routes)/home/Schedule.tsx
+++ b/app/(dashboard)/(routes)/home/Schedule.tsx
@@ -32,7 +32,7 @@ import { OptionsDialog } from "@/components/home/OptionsDialog";
 import { useClerk } from "@clerk/clerk-react";
 import { SubscriptionButton } from "@/components/subscription-button";
 import Tutorial from "./Tutorial";
-import { UserInfo } from "@/hooks/useUserInfo";
+import { UserInfo } from "@/types/user";
 
 type Section = "AdaptiveTutoringSuite" | "MCATGameAnkiClinic" | "DailyCARsSuite" | "Tests";
 
diff --git a/app/(dashboard)/(routes)/home/page.tsx b/app/(dashboard)/(routes)/home/page.tsx
index 3aa7bfbc4cc9a57a3bdd40466217cbd32c1f76c4..23326e87d735bda732ba0152ddcc0c95b0679bfa 100644
--- a/app/(dashboard)/(routes)/home/page.tsx
+++ b/app/(dashboard)/(routes)/home/page.tsx
@@ -1,7 +1,7 @@
 // app/(dashboard)/(routes)/home/page.tsx
 "use client";
 
-import React, { useState, useEffect, useRef, useCallback } from "react";
+import React, { useState, useEffect, useRef, useCallback, memo, useMemo } from "react";
 import { useSearchParams, useRouter, usePathname } from "next/navigation";
 import { useUserInfo } from "@/hooks/useUserInfo";
 import { useUserActivity } from '@/hooks/useUserActivity';
@@ -30,26 +30,35 @@ interface ContentWrapperProps {
   children: React.ReactNode;
 }
 
-interface LoadingSpinnerProps {}
+interface LoadingSpinnerProps {
+  message?: string;
+}
 
-const LoadingSpinner: React.FC<LoadingSpinnerProps> = () => (
-  <div className="fixed inset-0 flex justify-center items-center bg-black/50 z-50">
+const LoadingSpinner: React.FC<LoadingSpinnerProps> = memo(({ message = "Loading..." }) => (
+  <div className="fixed inset-0 flex justify-center items-center bg-black/50 z-[9999]">
     <div className="text-center">
       <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-sky-500 mx-auto mb-4" />
-      <p className="text-sky-300 text-xl">Loading...</p>
+      <p className="text-sky-300 text-xl">{message}</p>
     </div>
   </div>
-);
+));
+LoadingSpinner.displayName = 'LoadingSpinner';
 
-const ContentWrapper: React.FC<ContentWrapperProps> = ({ children }) => (
+const ContentWrapper: React.FC<ContentWrapperProps> = memo(({ children }) => (
   <div className="w-full px-[2rem] lg:px-[2.7rem] xl:px-[7rem] overflow-visible">
     <div className="text-[--theme-text-color] flex gap-[1.5rem] overflow-visible">
       {children}
     </div>
   </div>
-);
+));
+ContentWrapper.displayName = 'ContentWrapper';
+
+// Memoize components that don't need frequent updates
+const MemoizedSchedule = memo(Schedule);
+const MemoizedSideBar = memo(SideBar);
+const MemoizedAdaptiveTutoring = memo(AdaptiveTutoring);
 
-const HomePage = () => {
+const HomePage: React.FC = () => {
   /* ---------------------------------------- Hooks ---------------------------------------- */
   const router = useRouter();
   const pathname = usePathname();
@@ -58,24 +67,36 @@ const HomePage = () => {
   const { startActivity, endActivity, updateActivityEndTime } = useUserActivity();
   const { playMusic, stopMusic, volume, setVolume, isPlaying } = useAudio();
   const { setIsAutoPlay } = useMusicPlayer();
+  const paymentStatus = searchParams?.get("payment");
+  
+  // Debug mode check
+  const isDebugMode = searchParams?.get('debug') === 'true';
 
   /* ---------------------------------------- State ---------------------------------------- */
-  const [activeTab, setActiveTab] = useState(searchParams?.get("tab") || "Schedule");
-  const [activities, setActivities] = useState<FetchedActivity[]>([]);
-  const [isLoading, setIsLoading] = useState(true);
-  const [isUpdatingProfile, setIsUpdatingProfile] = useState(false);
-  const [isGeneratingActivities, setIsGeneratingActivities] = useState(false);
-  const [currentStudyActivityId, setCurrentStudyActivityId] = useState<string | null>(null);
-  const [chatbotContext, setChatbotContext] = useState<{contentTitle: string; context: string;} | null>(null);
-  const [kalypsoState, setKalypsoState] = useState<"wait" | "talk" | "end" | "start">("wait");
-  const [isPro, setIsPro] = useState(false);
-  const [showScorePopup, setShowScorePopup] = useState(false);
-  const [testScore, setTestScore] = useState(0);
-  const [showStreakPopup, setShowStreakPopup] = useState(false);
-  const [userStreak, setUserStreak] = useState(0);
-  const paymentStatus = searchParams?.get("payment");
-  const [currentPage, setCurrentPage] = useState("Schedule");
-  const [showReferralModal, setShowReferralModal] = useState(false);
+  // Combine related states into a single object to reduce re-renders
+  const [pageState, setPageState] = useState({
+    activeTab: searchParams?.get("tab") || "Schedule",
+    currentPage: "Schedule",
+    activities: [] as FetchedActivity[],
+    isInitialized: false,
+    currentStudyActivityId: null as string | null,
+    chatbotContext: null as {contentTitle: string; context: string;} | null,
+    kalypsoState: "wait" as "wait" | "talk" | "end" | "start",
+    isPro: false,
+    showScorePopup: false,
+    testScore: 0,
+    showStreakPopup: false,
+    userStreak: 0,
+    showReferralModal: false
+  });
+
+  // Combine loading states into a single object
+  const [loadingState, setLoadingState] = useState({
+    isLoading: true,
+    isUpdatingProfile: false,
+    isGeneratingActivities: false,
+    isLoadingTimeout: false
+  });
 
   /* ----------------------------------------- Refs ---------------------------------------- */
   const kalypsoRef = useRef<HTMLImageElement>(null);
@@ -83,6 +104,52 @@ const HomePage = () => {
   const chatbotRef = useRef<{ sendMessage: (message: string, context?: string) => void }>({
     sendMessage: () => {},
   });
+  const initializationRef = useRef(false);
+
+  // Memoize state updates to prevent unnecessary re-renders
+  const updatePageState = useCallback((updates: Partial<typeof pageState>) => {
+    setPageState(prev => ({ ...prev, ...updates }));
+  }, []);
+
+  const updateLoadingState = useCallback((newState: Partial<typeof loadingState>) => {
+    setLoadingState(prev => ({ ...prev, ...newState }));
+  }, []);
+
+  /* ---- Memoized Values ---- */
+  const shouldInitialize = useMemo(() => {
+    return !pageState.isInitialized && userInfo && !isLoadingUserInfo;
+  }, [pageState.isInitialized, userInfo, isLoadingUserInfo]);
+
+  /* ---- Callbacks & Event Handlers ---- */
+  const initializePage = useCallback(async () => {
+    if (!shouldInitialize) return;
+    
+    try {
+      const [activities, proStatus] = await Promise.all([
+        fetch("/api/calendar-activity").then(res => res.json()),
+        checkProStatus()
+      ]);
+
+      // Batch all state updates
+      updatePageState({
+        activities,
+        isPro: proStatus,
+        isInitialized: true
+      });
+
+      updateLoadingState({
+        isLoading: false
+      });
+
+    } catch (error) {
+      console.error('[HOME_PAGE] Error during initialization:', error);
+      toast.error("Failed to initialize page. Please refresh.");
+      
+      updateLoadingState({
+        isLoading: false
+      });
+    }
+  }, [shouldInitialize, updatePageState, updateLoadingState]);
 
   const updateCalendarChatContext = useCallback((currentActivities: FetchedActivity[]) => {
     const today = new Date();
@@ -143,16 +210,14 @@ const HomePage = () => {
         .join("\n\n")}
     `.trim();
 
-    setChatbotContext({
-      contentTitle: "Personal Calendar",
-      context: context,
-    });
+    setPageState(prev => ({ ...prev, chatbotContext: { contentTitle: "Personal Calendar", context: context } }));
   }, []);
 
   const fetchActivities = useCallback(async () => {
     try {
       const response = await fetch("/api/calendar-activity");
       if (!response.ok) {
+        console.error("[HOME_PAGE] Failed to fetch activities - status:", response.status);
         throw new Error("Failed to fetch activities");
       }
       const activities = await response.json();
@@ -191,18 +256,18 @@ const HomePage = () => {
       }
 
       // Force a new reference to trigger re-render
-      setActivities([...updatedActivities]);
+      setPageState(prev => ({ ...prev, activities: [...updatedActivities] }));
       updateCalendarChatContext(updatedActivities);
     } catch (error) {
-      console.error("Error fetching activities:", error);
+      console.error("[HOME_PAGE] Error in fetchActivities:", error);
       toast.error("Failed to fetch activities. Please try again.");
     }
   }, [updateCalendarChatContext]);
 
+  // Memoize activity handlers
   const handleActivityChange = useCallback(async (newType: string, newLocation: string, metadata = {}) => {
-    if (currentStudyActivityId) {
-      await endActivity(currentStudyActivityId);
-      setCurrentStudyActivityId(null);
+    if (pageState.currentStudyActivityId) {
+      await endActivity(pageState.currentStudyActivityId);
     }
 
     const activity = await startActivity({
@@ -213,26 +278,33 @@ const HomePage = () => {
         timestamp: new Date().toISOString()
       }
     });
-    setCurrentStudyActivityId(activity.id);
-  }, [currentStudyActivityId, endActivity, startActivity]);
 
+    updatePageState({ currentStudyActivityId: activity.id });
+  }, [pageState.currentStudyActivityId, endActivity, startActivity, updatePageState]);
+
+  // Optimize tab change handler
   const handleTabChange = useCallback(async (newTab: string) => {
     if (newTab === "SUMMARIZE_WEEK") {
-      setActiveTab("Schedule");
-      const sidebarInsightsTab = document.querySelector('[data-tab="tab1"]');
-      if (sidebarInsightsTab instanceof HTMLElement) {
-        sidebarInsightsTab.click();
-      }
-      return;
+        updatePageState({ activeTab: "Schedule" });
+        const sidebarInsightsTab = document.querySelector('[data-tab="tab1"]');
+        if (sidebarInsightsTab instanceof HTMLElement) {
+            sidebarInsightsTab.click();
+        }
+        return;
     }
 
     if (newTab === "ankiclinic") {
-      if (currentStudyActivityId) {
-        await endActivity(currentStudyActivityId);
-        setCurrentStudyActivityId(null);
-      }
-      router.push('/ankiclinic');
-      return;
+        try {
+            if (pageState.currentStudyActivityId) {
+                await endActivity(pageState.currentStudyActivityId);
+            }
+            await router.push('/ankiclinic');
+            return; // Important: return immediately after navigation
+        } catch (error) {
+            console.error('Navigation error:', error);
+            toast.error('Failed to navigate to Anki Clinic');
+        }
+        return; // Return in case of error too
     }
 
     // Handle tab with view parameter
@@ -240,89 +312,85 @@ const HomePage = () => {
     const searchParams = new URLSearchParams(params);
     const view = searchParams.get('view');
 
-    setActiveTab(tab);
-    setCurrentPage(tab);
+    // Batch state updates
+    const updates: Partial<typeof pageState> = {
+        activeTab: tab,
+        currentPage: tab
+    };
 
-    // Only start a new activity if we're not in AdaptiveTutoringSuite
-    if (tab !== "AdaptiveTutoringSuite") {
-      await handleActivityChange('studying', tab);
+    if (tab === "Schedule" && view) {
+        router.push(`/home?tab=Schedule&view=${view}`);
     }
 
-    if (tab === "Schedule") {
-      updateCalendarChatContext(activities);
-      // If view=tutors, find and click the tutors tab in the sidebar
-      if (view === 'tutors') {
-        // Small delay to ensure the sidebar is rendered
-        setTimeout(() => {
-          const tutorsTab = document.querySelector('[data-tab="tab3"]');
-          if (tutorsTab instanceof HTMLElement) {
-            tutorsTab.click();
-          }
-        }, 100);
-      }
-      // Update URL with view parameter if present
-      if (view) {
-        router.push(`/home?tab=Schedule&view=${view}`);
-      }
+    updatePageState(updates);
+
+    // Handle activity changes
+    if (tab !== "AdaptiveTutoringSuite") {
+        await handleActivityChange('studying', tab);
     }
-  }, [router, currentStudyActivityId, endActivity, updateCalendarChatContext, activities, handleActivityChange]);
+  }, [router, handleActivityChange, updatePageState, pageState.currentStudyActivityId, endActivity]);
 
   const switchKalypsoState = (newState: "wait" | "talk" | "end" | "start") => {
-    setKalypsoState(newState);
+    setPageState(prev => ({ ...prev, kalypsoState: newState }));
     if (kalypsoRef.current) {
       kalypsoRef.current.src = `/kalypso${newState}.gif`;
     }
   };
 
   const toggleChatBot = () => {
-    console.log("todo, set this up to widget");
+    // Implementation will be set up later
   };
 
-  /* ---------------------------------------- Callbacks ---------------------------------------- */
+  /* ---------------------------------------- Memoized Values ---------------------------------------- */
+  const pageTitle = useMemo(() => {
+    switch (pageState.activeTab) {
+      case "Schedule": return "Statistics";
+      case "Tests": return "Testing Suite";
+      case "AdaptiveTutoringSuite": return "Adaptive Tutoring Suite";
+      case "flashcards": return "Flashcards";
+      case "CARS": return "Daily CARs Practice";
+      default: return "Home";
+    }
+  }, [pageState.activeTab]);
+
+  const isPageLoading = useMemo(() => 
+    loadingState.isUpdatingProfile || loadingState.isGeneratingActivities || loadingState.isLoadingTimeout,
+    [loadingState.isUpdatingProfile, loadingState.isGeneratingActivities, loadingState.isLoadingTimeout]
+  );
 
   /* ---------------------------------------- Effects ---------------------------------------- */
+  // Track component lifecycle - simplified
   useEffect(() => {
-    const initializePage = async () => {
-      if (isLoadingUserInfo) return; // Wait for user info to be loaded
-      
-      setIsLoading(true);
-      try {
-        await fetchActivities();
-        const proStatus = await checkProStatus();
-
-        // Check for streak increase
-        if (userInfo?.streak && userInfo.streak > 1) {
-          const lastSeenStreak = parseInt(localStorage.getItem('lastSeenStreak') || '0');
-          const currentStreak = userInfo.streak;
-          
-          if (currentStreak > lastSeenStreak) {
-            localStorage.setItem('lastSeenStreak', currentStreak.toString());
-          }
-        }
-
-        // Only update knowledge profiles if needed
-        if (typeof window !== "undefined" && shouldUpdateKnowledgeProfiles()) {
-          const response = await fetch("/api/knowledge-profile/update", {
-            method: "POST",
-          });
-
-          if (response.ok) {
-            updateKnowledgeProfileTimestamp();
-          }
-        }
-      } catch (error) {
-        console.error("Error initializing page:", error);
-      } finally {
-        setIsLoading(false);
+    // Mark initialization to prevent double initialization
+    if (initializationRef.current) return;
+    initializationRef.current = true;
+    
+    // Add a safety timeout to ensure loading completes
+    const safetyTimeout = setTimeout(() => {
+      if (loadingState.isLoading) {
+        // Force loading to complete after timeout
+        updateLoadingState({ isLoading: false });
+      }
+    }, 3000); // 3 second safety timeout
+    
+    return () => {
+      if (timeoutRef.current) {
+        clearTimeout(timeoutRef.current);
       }
+      clearTimeout(safetyTimeout);
     };
+  }, [loadingState.isLoading, updateLoadingState]);
 
-    initializePage();
-  }, [isLoadingUserInfo, userInfo?.streak, fetchActivities]);
+  // Combine initialization effects
+  useEffect(() => {
+    if (shouldInitialize) {
+      initializePage();
+    }
+  }, [shouldInitialize, initializePage]);
 
   useEffect(() => {
-    updateCalendarChatContext(activities);
-  }, [activities]);
+    updateCalendarChatContext(pageState.activities);
+  }, [pageState.activities]);
 
   useEffect(() => {
     const handleScroll = () => {
@@ -342,7 +410,7 @@ const HomePage = () => {
     }, 100); // Small delay to ensure content is rendered
 
     return () => clearTimeout(timer);
-  }, [activities, activeTab]); // Re-run when content changes
+  }, [pageState.activities, pageState.activeTab]); // Re-run when content changes
 
   useEffect(() => {
     switchKalypsoState("wait"); // Start with waiting animation
@@ -368,10 +436,10 @@ const HomePage = () => {
   // Activity tracking effects
   useEffect(() => {
     const initializeActivity = async () => {
-      if (pathname && pathname.startsWith('/home') && !currentStudyActivityId && !isLoading) {
+      if (pathname && pathname.startsWith('/home') && !pageState.currentStudyActivityId && !isLoadingUserInfo) {
         const activity = await startActivity({
           type: 'studying',
-          location: activeTab,
+          location: pageState.activeTab,
           metadata: {
             initialLoad: true,
             timestamp: new Date().toISOString()
@@ -379,26 +447,26 @@ const HomePage = () => {
         });
 
         if (activity) {
-          setCurrentStudyActivityId(activity.id);
+          setPageState(prev => ({ ...prev, currentStudyActivityId: activity.id }));
         }
       }
     };
 
     initializeActivity();
-  }, [isLoading, pathname, activeTab, startActivity, currentStudyActivityId]);
+  }, [isLoadingUserInfo, pathname, pageState.activeTab, startActivity, pageState.currentStudyActivityId]);
 
   useEffect(() => {
-    if (!currentStudyActivityId) return;
+    if (!pageState.currentStudyActivityId) return;
 
     const intervalId = setInterval(() => {
-      updateActivityEndTime(currentStudyActivityId);
+      updateActivityEndTime(pageState.currentStudyActivityId);
     }, 300000);
 
     return () => clearInterval(intervalId);
-  }, [currentStudyActivityId, updateActivityEndTime]);
+  }, [pageState.currentStudyActivityId, updateActivityEndTime]);
 
   useEffect(() => {
-    setShowReferralModal(shouldShowRedeemReferralModal());
+    setPageState(prev => ({ ...prev, showReferralModal: shouldShowRedeemReferralModal() }));
   }, []);
 
   useEffect(() => {
@@ -406,201 +474,174 @@ const HomePage = () => {
     return () => setIsAutoPlay(false);
   }, [setIsAutoPlay]);
 
+  // Cleanup effect
+  useEffect(() => {
+    return () => {
+      // Cleanup any pending activities
+      if (pageState.currentStudyActivityId) {
+        endActivity(pageState.currentStudyActivityId);
+      }
+      if (timeoutRef.current) {
+        clearTimeout(timeoutRef.current);
+      }
+    };
+  }, []);
+
+  // Monitor userInfo changes
+  useEffect(() => {
+    // Monitor userInfo
+  }, [userInfo]);
+
+  // Monitor loading state changes
+  useEffect(() => {
+    // Monitor loading state
+  }, [isLoadingUserInfo]);
+
+  // Add loading timeout effect
+  useEffect(() => {
+    if (isLoadingUserInfo) {
+      const timeout = setTimeout(() => {
+        updateLoadingState({
+          isLoadingTimeout: true,
+          isLoading: false
+        });
+        toast.error("Loading is taking longer than expected. Please refresh the page.");
+      }, 15000); // 15 second timeout
+
+      return () => clearTimeout(timeout);
+    }
+    return undefined;
+  }, [isLoadingUserInfo]);
+
+  // Memoize chatbot context update
+  const updateChatbotContext = useCallback((context: {contentTitle: string; context: string;}) => {
+    updatePageState({ chatbotContext: context });
+  }, [updatePageState]);
+
   /* -------------------------------------- Rendering ------------------------------------- */
-  if (isLoading || isLoadingUserInfo) {
-    return <LoadingSpinner />;
-  }
+  const content = useMemo(() => {
+    if (isLoadingUserInfo) {
+      return <LoadingSpinner message="Loading user info..." />;
+    }
 
-  // Combined loading state
-  const isPageLoading = isLoading || isLoadingUserInfo || isUpdatingProfile || isGeneratingActivities;
+    if (isPageLoading) {
+      return <LoadingSpinner message="Initializing page..." />;
+    }
 
-  if (isPageLoading) {
     return (
-      <div className="fixed inset-0 flex justify-center items-center bg-black/50 z-50">
-        <div className="text-center">
-          <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-sky-500 mx-auto mb-4" />
-          <p className="text-sky-300 text-xl">
-            {isUpdatingProfile 
-              ? "Updating knowledge profile..."
-              : isGeneratingActivities
-                ? "Generating new study plan..."
-                : "Loading..."}
-          </p>
-        </div>
-      </div>
-    );
-  }
-
-  const renderContent = () => {
-    if (isUpdatingProfile || isGeneratingActivities) {
-      return (
-        <div className="flex justify-center items-center h-full">
-          <div className="text-center">
-            <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-sky-500 mx-auto mb-4"></div>
-            <p className="text-sky-300 text-xl">
-              {isUpdatingProfile
-                ? "Updating knowledge profile..."
-                : "Generating new study plan..."}
-            </p>
+      <ContentWrapper>
+        <div className="w-3/4 relative overflow-visible">
+          <div className="flex justify-between items-center">
+            <div className="flex items-center gap-4">
+              <h2
+                className="text-white text-2xl ml-3 font-thin leading-normal shadow-text cursor-pointer"
+                onClick={() => router.push("/home")}
+              >
+                {pageTitle}
+              </h2>
+              <ThemeSwitcher />
+            </div>
+          </div>
+          <div className="relative overflow-visible">
+            <div className="p-3 gradientbg h-[calc(100vh-5rem)] rounded-lg">
+              {pageState.activeTab === 'Schedule' && (
+                <MemoizedSchedule 
+                  handleSetTab={handleTabChange}
+                  isActive={pageState.activeTab === 'Schedule'}
+                  chatbotRef={chatbotRef}
+                  userInfo={userInfo}
+                />
+              )}
+              {pageState.activeTab === 'AdaptiveTutoring' && (
+                <div className="h-full overflow-hidden">
+                  <MemoizedAdaptiveTutoring 
+                    toggleChatBot={toggleChatBot}
+                    setChatbotContext={updateChatbotContext}
+                    chatbotRef={chatbotRef}
+                    onActivityChange={handleActivityChange}
+                  />
+                </div>
+              )}
+              {pageState.activeTab === 'CARS' && <TestingSuit />}
+              {pageState.activeTab === 'flashcards' && <FlashcardDeck />}
+              {pageState.activeTab === 'Tests' && (
+                <PracticeTests 
+                  handleSetTab={handleTabChange} 
+                  chatbotRef={chatbotRef}
+                  onActivitiesUpdate={fetchActivities}
+                />
+              )}
+            </div>
           </div>
         </div>
-      );
-    }
 
-    switch (activeTab) {
-      case "Schedule":
-        return (
-          <Schedule
-            handleSetTab={(tab) => {
-              if (tab === "SUMMARIZE_WEEK") {
-                setActiveTab("Schedule");
-                const sidebarInsightsTab = document.querySelector('[data-tab="tab1"]');
-                if (sidebarInsightsTab instanceof HTMLElement) {
-                  sidebarInsightsTab.click();
-                }
-                return;
-              }
-              handleTabChange(tab);
-            }}
-            isActive={activeTab === "Schedule"}
-            chatbotRef={chatbotRef}
-            userInfo={userInfo}
-          />
-        );
-      case "AdaptiveTutoringSuite":
-        return (
-          <div className="h-full overflow-hidden">
-            <AdaptiveTutoring
-              toggleChatBot={toggleChatBot}
-              setChatbotContext={setChatbotContext}
+        {/* Floating Button - Positioned between main content and sidebar */}
+        <FloatingButton
+          onTabChange={handleTabChange}
+          currentPage={pageState.currentPage}
+          initialTab="Tests"
+          className="z-50"
+          activities={pageState.activities}
+          onTasksUpdate={(tasks) => updatePageState({ activities: tasks })}
+          isSubscribed={isSubscribed}
+        />
+
+        <div className="w-1/4">
+          <h2 className="text-white text-2xl font-thin leading-normal shadow-text">
+            &nbsp;
+          </h2>
+          <div className="gradientbg p-3 h-[calc(100vh-5rem)] rounded-lg knowledge-profile-component">
+            <MemoizedSideBar 
+              activities={pageState.activities}
+              currentPage={pageState.currentPage}
+              chatbotContext={pageState.chatbotContext}
               chatbotRef={chatbotRef}
-              onActivityChange={handleActivityChange}
+              handleSetTab={handleTabChange}
+              onActivitiesUpdate={fetchActivities}
+              isSubscribed={isSubscribed}
             />
           </div>
-        );
-      case "CARS":
-        return <TestingSuit />;
-      case "flashcards":
-        return <FlashcardDeck />;
-      case "Tests":
-        return (
-          <PracticeTests 
-            handleSetTab={handleTabChange} 
-            chatbotRef={chatbotRef}
-            onActivitiesUpdate={fetchActivities}
-          />
-        );
-      default:
-        return null;
-    }
-  };
-
-  return (
-    <ContentWrapper>
-      <div className="w-3/4 relative overflow-visible">
-        <div className="flex justify-between items-center">
-          <div className="flex items-center gap-4">
-            <h2
-              className="text-white text-2xl ml-3 font-thin leading-normal shadow-text cursor-pointer"
-              onClick={() => router.push("/home")}
-            >
-              {activeTab === "Schedule"
-                ? "Statistics"
-                : activeTab === "Tests"
-                  ? "Testing Suite"
-                  : activeTab === "AdaptiveTutoringSuite"
-                    ? "Adaptive Tutoring Suite"
-                    : activeTab === "flashcards"
-                      ? "Flashcards"
-                      : activeTab === "CARS"
-                        ? "Daily CARs Practice"
-                        : "Home"}
-            </h2>
-            <ThemeSwitcher />
-          </div>
-        </div>
-        <div className="relative overflow-visible">
-          <div className="p-3 gradientbg h-[calc(100vh-5rem)] rounded-lg">
-            {renderContent()}
-          </div>
         </div>
-      </div>
-
-      <FloatingButton
-        onTabChange={handleTabChange}
-        currentPage={currentPage}
-        initialTab="Tests"
-        className="z-50"
-        activities={activities}
-        onTasksUpdate={fetchActivities}
-        isSubscribed={isSubscribed}
-      />
-
-      <div className="w-1/4">
-        <h2 className="text-white text-2xl font-thin leading-normal shadow-text">
-          &nbsp;
-        </h2>
-
-        <div className="gradientbg p-3 h-[calc(100vh-5rem)] rounded-lg knowledge-profile-component">
-          <SideBar
-            handleSetTab={handleTabChange}
-            activities={activities}
-            currentPage={currentPage}
-            chatbotContext={chatbotContext}
-            chatbotRef={chatbotRef}
-            onActivitiesUpdate={fetchActivities}
-            isSubscribed={isSubscribed}
+
+        {/* Modals and Popups */}
+        {pageState.showReferralModal && (
+          <RedeemReferralModal 
+            isOpen={pageState.showReferralModal} 
+            onClose={() => updatePageState({ showReferralModal: false })}
           />
-        </div>
-      </div>
-      
-      {/* Score Popup */}
-      <Dialog open={showScorePopup} onOpenChange={setShowScorePopup}>
-        <DialogContent className="bg-[#001226] text-white border border-sky-500 rounded-lg">
-          <DialogHeader>
-            <DialogTitle className="text-2xl font-semibold text-sky-300">
-              Test Completed!
-            </DialogTitle>
-            <DialogDescription className="text-gray-300">
-              Great job on completing the diagnostic test.
-            </DialogDescription>
-          </DialogHeader>
-          <div className="py-4">
-            <p className="text-xl">
-              Your Score:{" "}
-              <span className="font-bold text-sky-300">
-                {testScore.toFixed(2)}%
-              </span>
-            </p>
-          </div>
-          <div className="flex justify-end">
-            <Button
-              onClick={() => setShowScorePopup(false)}
-              className="bg-sky-500 hover:bg-sky-600 text-white"
-              disabled={isUpdatingProfile || isGeneratingActivities}
-            >
-              {isUpdatingProfile || isGeneratingActivities
-                ? "Processing..."
-                : "Close"}
-            </Button>
-          </div>
-        </DialogContent>
-      </Dialog>
-
-      <StreakPopup
-        streak={userStreak}
-        isOpen={showStreakPopup}
-        onClose={() => {
-          console.log("Closing streak popup");
-          setShowStreakPopup(false);
-        }}
-      />
-      <RedeemReferralModal 
-        isOpen={showReferralModal}
-        onClose={() => setShowReferralModal(false)}
-      />
-    </ContentWrapper>
-  );
+        )}
+        {pageState.showStreakPopup && (
+          <StreakPopup 
+            isOpen={pageState.showStreakPopup}
+            onClose={() => updatePageState({ showStreakPopup: false })}
+            streak={pageState.userStreak}
+          />
+        )}
+      </ContentWrapper>
+    );
+  }, [
+    isLoadingUserInfo,
+    isPageLoading,
+    pageState.activeTab,
+    pageState.activities,
+    pageState.currentPage,
+    pageState.chatbotContext,
+    chatbotRef,
+    handleTabChange,
+    fetchActivities,
+    isSubscribed,
+    userInfo,
+    toggleChatBot,
+    updatePageState,
+    handleActivityChange,
+    pageTitle,
+    pageState.showReferralModal,
+    pageState.showStreakPopup,
+    pageState.userStreak,
+    router
+  ]);
+
+  return content;
 };
 
-export default HomePage;
\ No newline at end of file
+export default memo(HomePage);
\ No newline at end of file
diff --git a/app/(dashboard)/(routes)/home/testingsuit/TestList.tsx b/app/(dashboard)/(routes)/home/testingsuit/TestList.tsx
index 738b1c1a814f0aa97ed23b12e097f16716215d06..d7d51b2a1fcac09b08ee19de5aa9d6b906315ab8 100644
--- a/app/(dashboard)/(routes)/home/testingsuit/TestList.tsx
+++ b/app/(dashboard)/(routes)/home/testingsuit/TestList.tsx
@@ -2,7 +2,7 @@ import React, { useState, useEffect } from "react";
 import Link from "next/link";
 import Image from "next/image";
 import { Test, UserTest } from "@/types";
-import { useTheme } from "@/contexts/ThemeContext";
+import { useUI } from "@/store/selectors";
 import { Skeleton } from "@/components/ui/skeleton";
 import { CheckCircle } from "lucide-react";
 import {
@@ -41,7 +41,7 @@ const TestList: React.FC<TestListProps> = ({
   testsAvailableToday = Infinity,
   testsCompletedToday: initialTestsCompleted = 0,
 }) => {
-  const { theme } = useTheme();
+  const { theme } = useUI();
   const [userScore, setUserScore] = useState<number | null>(null);
   const noTestsAvailable = userScore === 0;
   const [searchQuery, setSearchQuery] = useState("");
diff --git a/app/(dashboard)/layout.tsx b/app/(dashboard)/layout.tsx
index 2080a0e5ef9333ec875837b923a7da0447817521..870d2df70fd85485b0b16e74a15b29b8d125841b 100644
--- a/app/(dashboard)/layout.tsx
+++ b/app/(dashboard)/layout.tsx
@@ -1,36 +1,55 @@
 'use client'
 
-import { Navbar } from "@/components/navbar/navbar";
 import { useEffect, useState } from "react";
-import { ThemeProvider, useTheme } from "@/contexts/ThemeContext";
-import ThemeInitializer from "@/components/home/ThemeInitializer";
-import Script from 'next/script';
-import { MusicPlayerProvider } from '@/contexts/MusicPlayerContext';
+import { useRouter, usePathname, useSearchParams } from "next/navigation";
 import { useAuth } from "@clerk/nextjs";
 import { Loader2 } from "lucide-react";
-import { useRouter, usePathname } from "next/navigation";
+import Script from 'next/script';
+
+import { useUI, useUser } from "@/store/selectors";
 import { useUserInfo } from "@/hooks/useUserInfo";
-import { UserStatsProvider } from '@/contexts/UserStatsContext';
-
-const DashboardLayoutContent = ({
-  children,
-}: {
-  children: React.ReactNode
-}) => {
-  const { theme } = useTheme();
+
+import Navbar from "@/components/navbar/navbar";
+import ThemeInitializer from "@/components/home/ThemeInitializer";
+import StoreInitializer from '@/components/StoreInitializer';
+import { MusicPlayerProvider } from '@/contexts/MusicPlayerContext';
+
+/* --- Types ---- */
+interface LayoutProps {
+  children: React.ReactNode;
+}
+
+interface DashboardLayoutContentProps {
+  children: React.ReactNode;
+}
+
+// Debug component that has access to all contexts
+const ContextDebugger = () => {
+  const searchParams = useSearchParams();
+  const isDebugMode = searchParams?.get('debug') === 'true';
+  const zustandUserState = useUser();
+    
+  return null; // This component doesn't render anything
+};
+
+const DashboardLayoutContent = ({ children }: DashboardLayoutContentProps) => {
+  console.log('🔍 [DEBUG] DashboardLayoutContent rendering');
+  /* ---- State ----- */
+  const { theme } = useUI();
   const [backgroundImage, setBackgroundImage] = useState('');
   const { isLoaded, isSignedIn } = useAuth();
-  const { isLoading, isSubscribed } = useUserInfo();
+  const { isSubscribed } = useUser();
   const router = useRouter();
   const pathname = usePathname();
 
+  /* --- Effects --- */
   useEffect(() => {
-    if (isLoaded && isSignedIn && !isLoading) {
+    if (isLoaded && isSignedIn) {
       console.log('🎫 Subscription Status:', 
         isSubscribed ? 'GOLD or PREMIUM' : 'FREE'
       );
     }
-  }, [isLoaded, isSignedIn, isLoading, isSubscribed]);
+  }, [isLoaded, isSignedIn, isSubscribed]);
 
   useEffect(() => {
     const updateBackgroundImage = () => {
@@ -55,7 +74,7 @@ const DashboardLayoutContent = ({
     return () => window.removeEventListener('resize', updateBackgroundImage);
   }, [theme]);
 
-  if (!isLoaded || isLoading) {
+  if (!isLoaded) {
     return (
       <div className="h-screen w-screen flex items-center justify-center">
         <Loader2 className="h-8 w-8 animate-spin text-sky-500" />
@@ -78,19 +97,19 @@ const DashboardLayoutContent = ({
    );
 }
 
-const DashboardLayout = ({ children }: { children: React.ReactNode }) => (
-  <ThemeProvider>
-    <MusicPlayerProvider>
-      <Script
-        src="https://tally.so/widgets/embed.js"
-        strategy="lazyOnload"
-      />
-      <ThemeInitializer />
-      <UserStatsProvider>
-        <DashboardLayoutContent>{children}</DashboardLayoutContent>
-      </UserStatsProvider>
-    </MusicPlayerProvider>
-  </ThemeProvider>
-);
+const DashboardLayout = ({ children }: LayoutProps) => {
+  console.log('🔍 [DEBUG] DashboardLayout rendering');
+  return (
+  <MusicPlayerProvider>
+    <Script
+      src="https://tally.so/widgets/embed.js"
+      strategy="lazyOnload"
+    />
+    <ThemeInitializer />
+    <StoreInitializer />
+    <ContextDebugger />
+    <DashboardLayoutContent>{children}</DashboardLayoutContent>
+  </MusicPlayerProvider>
+)};
 
 export default DashboardLayout;
diff --git a/app/api/categories/route.ts b/app/api/categories/route.ts
index c6d7a484f2f7b1b1323814e3316ae121d73e5828..8e89b373a62bff4c85d625e1e78e3f0a8f1483a6 100644
--- a/app/api/categories/route.ts
+++ b/app/api/categories/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/category-time/route.ts b/app/api/category-time/route.ts
index 2865db1a6d96dfd45487f637886607070d7621b6..a3e8a49cd69fb4e526a2c37b853defb4405109d5 100644
--- a/app/api/category-time/route.ts
+++ b/app/api/category-time/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/clinic/route.ts b/app/api/clinic/route.ts
index 572f6e50663dcd68d4c22d199a83a2f66495998d..6be1581bb49c34276b86f1313be8b564468ecf00 100644
--- a/app/api/clinic/route.ts
+++ b/app/api/clinic/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/content/route.ts b/app/api/content/route.ts
index 197cbd90d5cb3817d04e93f5a9a1155748021942..ce1315c007bac9e446ccd0476e3e8134cd529c2c 100644
--- a/app/api/content/route.ts
+++ b/app/api/content/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/daily-calculations/route.ts b/app/api/daily-calculations/route.ts
index f21927efca05d99568e1788813e4c699ba14e615..8f446294f43edc244267fa15328235f38e25ac3e 100644
--- a/app/api/daily-calculations/route.ts
+++ b/app/api/daily-calculations/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/event-task/route.ts b/app/api/event-task/route.ts
index a27cb30698fee4e66457be469ee40d690a445bcd..e6061b3a5f94054c5fb50b362551cff2b77decb4 100644
--- a/app/api/event-task/route.ts
+++ b/app/api/event-task/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { promises as fs } from 'fs';
 import path from 'path';
 import { NextResponse } from 'next/server';
diff --git a/app/api/global-leaderboard/route.tsx b/app/api/global-leaderboard/route.tsx
index e8e2a0d2b6820565a735aab201ec84bb9b7af2f9..fdc14ebef8c8f3a80b771bca88049f485c547910 100644
--- a/app/api/global-leaderboard/route.tsx
+++ b/app/api/global-leaderboard/route.tsx
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { auth } from "@clerk/nextjs/server";
 import { NextRequest, NextResponse } from "next/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/api/mcat-progress/route.ts b/app/api/mcat-progress/route.ts
index dd460a9b86ac10c9052312caadb3b7ffe470ce1b..d2b21baf7cfe08146f07e870394457c1fdd7cb39 100644
--- a/app/api/mcat-progress/route.ts
+++ b/app/api/mcat-progress/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth, currentUser } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
@@ -34,10 +36,14 @@ export async function GET() {
       select: { onboardingInfo: true }
     });
     
-    // Parse the JSON string and provide type safety
-    const onboardingInfo = userInfo?.onboardingInfo ? JSON.parse(userInfo.onboardingInfo as string) as OnboardingInfo : {};
+    // Handle onboardingInfo properly whether it's a string or object
+    let onboardingInfo: OnboardingInfo;
+    if (typeof userInfo?.onboardingInfo === 'string') {
+      onboardingInfo = JSON.parse(userInfo.onboardingInfo);
+    } else {
+      onboardingInfo = userInfo?.onboardingInfo as OnboardingInfo || {};
+    }
     const targetScore = onboardingInfo.targetScore || 520;
-
     // Get all exams with their scores
     const exams = await prisma.fullLengthExam.findMany({
       where: { userId },
@@ -116,10 +122,12 @@ export async function GET() {
         : null
     };
 
-    return NextResponse.json({
+    const response = {
       chartData,
       sectionAverages
-    } as MCATProgressResponse);
+    } as MCATProgressResponse;
+
+    return NextResponse.json(response);
 
   } catch (error) {
     console.error("[MCAT_PROGRESS_GET]", error);
diff --git a/app/api/question/route.ts b/app/api/question/route.ts
index 9e4930561e0207d15b91935ea170247429b24b08..646a6c0b7e28e9609d08e88b25f3f12a6363536d 100644
--- a/app/api/question/route.ts
+++ b/app/api/question/route.ts
@@ -1,4 +1,5 @@
 // File: app/api/question/route.ts
+export const dynamic = 'force-dynamic';
 
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
diff --git a/app/api/reviews/route.ts b/app/api/reviews/route.ts
index a7be159dc43639256ad564715f2b46bdb654c673..50a983c7ea2ed4c1c1e2df09e83e109412885fa2 100644
--- a/app/api/reviews/route.ts
+++ b/app/api/reviews/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from "next/server";
 import prismadb from "@/lib/prismadb";
 
diff --git a/app/api/stripe/route.ts b/app/api/stripe/route.ts
index d2179ef800811f7ad68e7704ee52120fdf87efd8..52827c8249d2f6ecdfbd04e20613a99852598c15 100644
--- a/app/api/stripe/route.ts
+++ b/app/api/stripe/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { auth, currentUser } from "@clerk/nextjs/server";
 import { NextResponse } from "next/server";
 
diff --git a/app/api/subscription/route.ts b/app/api/subscription/route.ts
index 0b6694d30264fb518b60b40e4ca0acd4efe97044..3a815439ecd4677c1427a8d8adee95c8d1537d99 100644
--- a/app/api/subscription/route.ts
+++ b/app/api/subscription/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 // File: app/api/subscription/route.ts
 
 import { NextResponse } from 'next/server';
diff --git a/app/api/subscription/status/route.ts b/app/api/subscription/status/route.ts
index 5d361f1f2987ac3e374659a0594d258676982e80..d10d0fd7b4aeecaaaf0583461078959436c442be 100644
--- a/app/api/subscription/status/route.ts
+++ b/app/api/subscription/status/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from "next/server";
 import prismadb from "@/lib/prismadb";
 import { stripe } from "@/lib/stripe";
diff --git a/app/api/user-info/onboarding/route.ts b/app/api/user-info/onboarding/route.ts
index 0016ff21de722b935cf0b26e0a85d83d41d8841e..fd11ba3e29ccc18cf976d9c88d131167efd12484 100644
--- a/app/api/user-info/onboarding/route.ts
+++ b/app/api/user-info/onboarding/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prismadb from "@/lib/prismadb";
diff --git a/app/api/user-info/profile/route.ts b/app/api/user-info/profile/route.ts
index 8dfe93b7cb96646ab2086ecd1da0ba6aee712c6c..fd89b46f7ade6e2d83a33ca09d8d43327a65b35d 100644
--- a/app/api/user-info/profile/route.ts
+++ b/app/api/user-info/profile/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prismadb from "@/lib/prismadb";
diff --git a/app/api/user-info/route.ts b/app/api/user-info/route.ts
index 1639c3833caba4d6a74223ca5d5331984516b340..6ed4cc6f28881fa1318ae36a1efb94dfa4ff0765 100644
--- a/app/api/user-info/route.ts
+++ b/app/api/user-info/route.ts
@@ -1,4 +1,5 @@
 // File: app/api/user-info/route.ts
+export const dynamic = 'force-dynamic';
 
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
diff --git a/app/api/video-content/route.ts b/app/api/video-content/route.ts
index e76a32dad75389de3e024652e1dcd01d190eb5ad..072f53650b3eb332c79c4b34f7cff26d32130884 100644
--- a/app/api/video-content/route.ts
+++ b/app/api/video-content/route.ts
@@ -1,3 +1,5 @@
+export const dynamic = 'force-dynamic';
+
 import { NextResponse } from 'next/server';
 import { auth } from "@clerk/nextjs/server";
 import prisma from "@/lib/prismadb";
diff --git a/app/globals.css b/app/globals.css
index f74c2d56f749adad122b9497a6499ba2dae5d4e3..6ba4b3f6b61120ca297c96b8571b1998a6160839 100644
--- a/app/globals.css
+++ b/app/globals.css
@@ -1082,4 +1082,10 @@ html::-webkit-scrollbar {
     transform: translate(var(--tx, -50px), var(--ty, -50px)) rotate(var(--r, 180deg)) scale(1);
     opacity: 0;
   }
+}
+
+/* Optimize rendering for debug mode - simple version */
+.debug-mode * {
+  transition: none !important;
+  animation-duration: 0ms !important;
 }
\ No newline at end of file
diff --git a/app/layout.tsx b/app/layout.tsx
index c269277e0b82b20f6328445b94bcb7682c4efe38..8e31072b0d07773a4c93a639e7e389eeccbe0305 100644
--- a/app/layout.tsx
+++ b/app/layout.tsx
@@ -1,89 +1,53 @@
-import type { Metadata } from 'next'
 import { Roboto_Slab } from 'next/font/google'
-import './globals.css'
 import { ClerkProvider } from '@clerk/nextjs'
 import ThemeInitializer from '@/components/home/ThemeInitializer'
 import { Analytics } from '@vercel/analytics/react';
 import MobileRedirect from '@/components/MobileRedirect'
 import { FullscreenPrompt } from '@/components/FullscreenPrompt'
-import { UserProfileProvider } from '@/contexts/UserProfileContext'
 import { AudioProvider } from '@/contexts/AudioContext'
-import { UserInfoProvider } from '@/contexts/UserInfoContext'
+import DebugPanel from "@/components/ui/DebugPanel"
+import StoreInitializer from '@/components/StoreInitializer'
+import LayoutWindowSizeTracker from './layoutWindowSizeTracker'
+import { metadata } from './metadata'
+import RouteTracker from '@/components/RouteTracker'
+
+import './globals.css'
+
 const robotoSlab = Roboto_Slab({ subsets: ['latin'] })
 
-export const metadata: Metadata = {
-  metadataBase: new URL('https://www.mymcat.ai'),
-  title: 'mymcat - you\'re better with us',
-  description: 'interactive learning platform with AI-powered study tools, practice tests, and personalized feedback.',
-  keywords: 'MCAT prep, medical school admission, interactive learning, study tools, MCAT practice tests, MyMCAT, AI MCAT Prep, MCAT study platform',
-  robots: {
-    index: true,
-    follow: true,
-    googleBot: {
-      index: true,
-      follow: true,
-      'max-video-preview': -1,
-      'max-image-preview': 'large',
-      'max-snippet': -1,
-    },
-  },
-  openGraph: {
-    title: 'mymcat - you\'re better with us',
-    description: 'Prepare for the MCAT with our innovative, gamified learning platform. Boost your scores and make studying enjoyable.',
-    images: [
-      {
-        url: '/knowledge.png',
-        width: 1200,
-        height: 630,
-        alt: 'My MCAT Platform Preview',
-      },
-    ],
-  },
-  twitter: {
-    card: 'summary_large_image',
-    title: 'mymcat - you\'re better with us',
-    description: 'Transform your MCAT study experience with My MCAT. Engaging, effective, and tailored for success.',
-    images: ['/knowledge.png'],
-  },
-  verification: {
-    google: 'F6e4Rh-tPmtWbb_Ij-lgHvb2cXGQjy_h-UNxh9E-9Xc',
-  },
-  alternates: {
-    canonical: 'https://www.mymcat.ai',
-  },
-}
+export { metadata }
 
 export default function RootLayout({
   children,
 }: {
   children: React.ReactNode
 }) {
+  console.log('🔍 [DEBUG] RootLayout rendering');
+  
   return (
-    <ClerkProvider
-    afterSignOutUrl={"/"}
-    >
+    <ClerkProvider afterSignOutUrl={"/"}>
       <AudioProvider>
-        <UserInfoProvider>
-          <UserProfileProvider>
-            <html lang="en">
-              <head>
-                <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"></meta>
-              </head>
-              <body className={robotoSlab.className}>
-                <div id="app-root" className="relative">
-                  <MobileRedirect />
-                  <ThemeInitializer />
-                  <FullscreenPrompt />
-                  <div className="relative z-50">
-                    {children}
-                  </div>
-                  <Analytics />
-                </div>
-              </body>
-            </html>
-            </UserProfileProvider>
-          </UserInfoProvider>
-        </AudioProvider>
+        <html lang="en">
+          <head>
+            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"></meta>
+          </head>
+          <body className={robotoSlab.className}>
+            <div id="app-root" className="relative">
+              <LayoutWindowSizeTracker />
+              <MobileRedirect />
+              <ThemeInitializer />
+              <FullscreenPrompt />
+              <StoreInitializer />
+              <RouteTracker />
+              <div className="relative z-50">
+                {children}
+              </div>
+              <Analytics />
+              <DebugPanel />
+            </div>
+          </body>
+        </html>
+      </AudioProvider>
     </ClerkProvider>
   )
 }
diff --git a/app/layoutWindowSizeTracker.tsx b/app/layoutWindowSizeTracker.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..28b92a9da36bc7a6972f58f2bde1316026d70a4f
--- /dev/null
+++ b/app/layoutWindowSizeTracker.tsx
@@ -0,0 +1,43 @@
+//app/layoutWindowSizeTracker.tsx
+'use client'
+
+import { useEffect } from 'react'
+import { useUI } from '@/store/selectors'
+
+export default function LayoutWindowSizeTracker() {
+  const { setWindowSize } = useUI()
+
+  useEffect(() => {
+    const checkIfPhone = () => {
+      // Check if device is a phone using user agent
+      const isPhoneUA = /iPhone|iPad|iPod|Android|webOS|BlackBerry|Windows Phone/i.test(navigator.userAgent)
+      
+      // Check if screen size matches phone dimensions (max-width: 768px)
+      const isPhoneSize = window.innerWidth <= 768
+      
+      // Consider it a phone if either condition is true
+      return isPhoneUA || isPhoneSize
+    }
+
+    const handleResize = () => {
+      const width = window.innerWidth
+      const height = window.innerHeight
+      const isPhone = checkIfPhone()
+      
+      setWindowSize({
+        width,
+        height,
+        isDesktop: !isPhone
+      })
+    }
+
+    // Set initial size
+    handleResize()
+
+    // Add event listener
+    window.addEventListener('resize', handleResize)
+    return () => window.removeEventListener('resize', handleResize)
+  }, [setWindowSize])
+
+  return null
+} 
\ No newline at end of file
diff --git a/app/metadata.ts b/app/metadata.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1366eb8734d9c709cb910a8d0eb2ab3df251409e
--- /dev/null
+++ b/app/metadata.ts
@@ -0,0 +1,44 @@
+//app/metadata.ts
+import type { Metadata } from 'next'
+
+export const metadata: Metadata = {
+  metadataBase: new URL('https://www.mymcat.ai'),
+  title: 'mymcat - you\'re better with us',
+  description: 'interactive learning platform with AI-powered study tools, practice tests, and personalized feedback.',
+  keywords: 'MCAT prep, medical school admission, interactive learning, study tools, MCAT practice tests, MyMCAT, AI MCAT Prep, MCAT study platform',
+  robots: {
+    index: true,
+    follow: true,
+    googleBot: {
+      index: true,
+      follow: true,
+      'max-video-preview': -1,
+      'max-image-preview': 'large',
+      'max-snippet': -1,
+    },
+  },
+  openGraph: {
+    title: 'mymcat - you\'re better with us',
+    description: 'Prepare for the MCAT with our innovative, gamified learning platform. Boost your scores and make studying enjoyable.',
+    images: [
+      {
+        url: '/knowledge.png',
+        width: 1200,
+        height: 630,
+        alt: 'My MCAT Platform Preview',
+      },
+    ],
+  },
+  twitter: {
+    card: 'summary_large_image',
+    title: 'mymcat - you\'re better with us',
+    description: 'Transform your MCAT study experience with My MCAT. Engaging, effective, and tailored for success.',
+    images: ['/knowledge.png'],
+  },
+  verification: {
+    google: 'F6e4Rh-tPmtWbb_Ij-lgHvb2cXGQjy_h-UNxh9E-9Xc',
+  },
+  alternates: {
+    canonical: 'https://www.mymcat.ai',
+  },
+} 
\ No newline at end of file
diff --git a/components/RouteTracker.tsx b/components/RouteTracker.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..c710377deb66d4ff4c4b9f70ea42f1a3a908cce4
--- /dev/null
+++ b/components/RouteTracker.tsx
@@ -0,0 +1,26 @@
+"use client";
+
+import { useEffect } from 'react';
+import { usePathname } from 'next/navigation';
+import { useUI } from '@/store/selectors';
+
+/**
+ * RouteTracker - Updates the Zustand store with the current route
+ * This component doesn't render anything, it just tracks route changes
+ */
+const RouteTracker = () => {
+  const pathname = usePathname();
+  const { setCurrentRoute } = useUI();
+
+  // Update the current route in Zustand store whenever pathname changes
+  useEffect(() => {
+    if (pathname) {
+      setCurrentRoute(pathname);
+    }
+  }, [pathname, setCurrentRoute]);
+
+  // This component doesn't render anything
+  return null;
+};
+
+export default RouteTracker; 
\ No newline at end of file
diff --git a/components/Statistics.tsx b/components/Statistics.tsx
index 737b534b98f5574a7937fc710b578da9a6fd2448..865e8c9344dddf25277c978839f9c6c53af656a0 100644
--- a/components/Statistics.tsx
+++ b/components/Statistics.tsx
@@ -10,7 +10,7 @@ import {
   Line,
   ResponsiveContainer,
 } from "recharts";
-import { useTheme } from '@/contexts/ThemeContext';
+import { useUI } from '@/store/selectors';
 
 interface CategoryStats {
   categoryId: string;
@@ -79,7 +79,7 @@ const Statistics = ({
   onReturn,
   subject,
 }: StatisticsProps) => {
-  const { theme } = useTheme();
+  const { theme } = useUI();
   const [loading, setLoading] = useState(true);
   const [stats, setStats] = useState<StatsData | null>(null);
 
diff --git a/components/StoreInitializer.tsx b/components/StoreInitializer.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..05923cfe6b581ca4d5d79f011bb307f0dd5b8d36
--- /dev/null
+++ b/components/StoreInitializer.tsx
@@ -0,0 +1,22 @@
+"use client";
+
+import { useEffect } from 'react';
+import { useUser } from '@clerk/nextjs';
+import { useUser as useZustandUser } from '@/store/selectors';
+
+const StoreInitializer = () => {
+  const { isLoaded, isSignedIn } = useUser();
+  const { refreshUserInfo } = useZustandUser();
+  
+  // Initialize Zustand store with user data when the user is signed in
+  useEffect(() => {
+    if (isLoaded && isSignedIn) {
+      refreshUserInfo();
+    }
+  }, [isLoaded, isSignedIn, refreshUserInfo]);
+  
+  // This component doesn't render anything
+  return null;
+};
+
+export default StoreInitializer; 
\ No newline at end of file
diff --git a/components/home/ThemeInitializer.tsx b/components/home/ThemeInitializer.tsx
index ca8b721cef09ab86c67397bb1a97b6aa1738eb30..32d1c786ef22b1afc83e98abf38d9f9dd5d8d4fb 100644
--- a/components/home/ThemeInitializer.tsx
+++ b/components/home/ThemeInitializer.tsx
@@ -1,8 +1,10 @@
 'use client'
 
 import { useEffect } from 'react'
-import { useTheme } from '@/contexts/ThemeContext'
+import { useUI } from '@/store/selectors'
+import type { ThemeType } from '@/store/store'
 
+/* --- Constants ----- */
 const scrollbarColors = {
   cyberSpace: '#3b82f6',
   sakuraTrees: '#b973af',
@@ -11,15 +13,17 @@ const scrollbarColors = {
 }
 
 export default function ThemeInitializer() {
-  const { theme, setTheme } = useTheme()
+  const { theme, setTheme } = useUI();
 
+  // Initialize theme from localStorage
   useEffect(() => {
-    const savedTheme = localStorage.getItem('theme') as 'cyberSpace' | 'sakuraTrees' | 'sunsetCity' | 'mykonosBlue' | null
+    const savedTheme = localStorage.getItem('theme') as ThemeType | null
     if (savedTheme && ['cyberSpace', 'sakuraTrees', 'sunsetCity', 'mykonosBlue'].includes(savedTheme)) {
       setTheme(savedTheme)
     }
   }, [setTheme])
 
+  // Apply theme classes and CSS variables
   useEffect(() => {
     document.body.classList.remove('theme-cyberSpace', 'theme-sakuraTrees', 'theme-sunsetCity', 'theme-mykonosBlue')
     document.body.classList.add(`theme-${theme}`)
diff --git a/components/home/ThemeSwitcher.tsx b/components/home/ThemeSwitcher.tsx
index fcc623422a353b638626cefde207ed8ee8e92be5..4e0745dbc588a08bdb3284392a2fd8dd1444b7d6 100644
--- a/components/home/ThemeSwitcher.tsx
+++ b/components/home/ThemeSwitcher.tsx
@@ -1,9 +1,12 @@
-import { useTheme } from '@/contexts/ThemeContext';
+'use client'
+
+import { useUI } from '@/store/selectors';
+import type { ThemeType } from '@/store/store';
 
 const ThemeSwitcher = () => {
-  const { theme, setTheme } = useTheme();
+  const { theme, setTheme } = useUI();
 
-  const handleThemeChange = (newTheme: 'cyberSpace' | 'sakuraTrees' | 'sunsetCity' | 'mykonosBlue') => {
+  const handleThemeChange = (newTheme: ThemeType) => {
     setTheme(newTheme);
   };
 
diff --git a/components/navbar/ProfileButton.tsx b/components/navbar/ProfileButton.tsx
index cf40e10c7b76d941e08c6ef4839b575b728e9000..7e08e22b021bb2d0b53bd6bd0c1b669bf3d92803 100644
--- a/components/navbar/ProfileButton.tsx
+++ b/components/navbar/ProfileButton.tsx
@@ -1,8 +1,8 @@
 import React, { useState, useEffect } from 'react';
-import { useClerk, useUser } from '@clerk/nextjs';
+import { useClerk, useUser as useClerkUser } from '@clerk/nextjs';
 import { FaUser, FaUserCog, FaSignOutAlt } from 'react-icons/fa';
 import UserProfileModal from '../social/profile/UserProfileModal';
-import { useProfileContext } from '@/contexts/UserProfileContext';
+import { useUser } from '@/store/selectors';
 import Image from 'next/image';
 
 export const ProfileButton = ({hideProfile}: {hideProfile?: boolean}) => {
@@ -10,8 +10,8 @@ export const ProfileButton = ({hideProfile}: {hideProfile?: boolean}) => {
   const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
   const menuRef = React.useRef<HTMLDivElement>(null);
   const { openUserProfile, signOut } = useClerk();
-  const { user } = useUser();
-  const { profile, isLoading } = useProfileContext();
+  const { user } = useClerkUser();
+  const { profile, profileLoading } = useUser();
 
   // Handle clicks outside menu
   useEffect(() => {
@@ -43,7 +43,7 @@ export const ProfileButton = ({hideProfile}: {hideProfile?: boolean}) => {
         </div>
         
         {/* Profile Image with Loading State */}
-        {isLoading ? (
+        {profileLoading ? (
           <div className="w-full h-full flex items-center justify-center">
             <div className="animate-spin rounded-full h-4 w-4 border-2 border-[--theme-hover-color] border-t-transparent" />
           </div>
@@ -57,9 +57,6 @@ export const ProfileButton = ({hideProfile}: {hideProfile?: boolean}) => {
             className="w-full h-full object-cover transition-opacity duration-300"
             quality={100}
             style={{ opacity: 0 }}
-            onLoadingComplete={(img) => {
-              img.style.opacity = "1";
-            }}
             onLoad={(e) => {
               (e.target as HTMLImageElement).style.opacity = "1";
             }}
diff --git a/components/navbar/navbar.tsx b/components/navbar/navbar.tsx
index 3dc048fc3c30f8ef8aea66f7a773039d641dafb5..700dcdd7b72dc7ad2a4604501cf503b97c394a53 100644
--- a/components/navbar/navbar.tsx
+++ b/components/navbar/navbar.tsx
@@ -4,24 +4,33 @@ import { useEffect, useRef, useState } from "react";
 import Link from "next/link";
 import { usePathname } from "next/navigation";
 import { FaLinkedin, FaInstagram } from 'react-icons/fa';
-import MusicPlayer from "@/components/navbar/musicplayer";
-import { useTheme } from '@/contexts/ThemeContext';
+
+import { useUI } from '@/store/selectors';
 import { useMusicPlayer } from '@/contexts/MusicPlayerContext';
 import { useUserInfo } from "@/hooks/useUserInfo";
+
 import { SubscriptionManagementButton } from "@/components/subscription-management-button";
 import { ProfileButton } from '@/components/navbar/ProfileButton';
 import { MailButton } from '@/components/navbar/MailButton';
+import MusicPlayer from "@/components/navbar/musicplayer";
 
-// Define the Song type
+/* --- Types ---- */
 type Song = {
   title: string;
   url: string;
 };
 
-export const Navbar = ({ subscription = "free" }: { subscription: string }) => {
-  const pathname = usePathname();
+interface NavbarProps {
+  subscription?: string;
+}
+
+const Navbar = ({ subscription = "free" }: NavbarProps) => {
+  /* ---- Refs --- */
   const ballerSectionRef = useRef(null);
-  const { theme } = useTheme();
+
+  /* ---- State ----- */
+  const pathname = usePathname();
+  const { theme } = useUI();
   const { isAutoPlay } = useMusicPlayer();
   const { isSubscribed } = useUserInfo();
 
@@ -88,3 +97,5 @@ export const Navbar = ({ subscription = "free" }: { subscription: string }) => {
     </nav>
   );
 };
+
+export default Navbar;
diff --git a/components/social/friend-interaction/CoinModal.tsx b/components/social/friend-interaction/CoinModal.tsx
index 66e409dc34b74490cfe58180948eeeecbf95cd3f..4bc3881b16cc50547fdd23c9b45eecf7f669cb7b 100644
--- a/components/social/friend-interaction/CoinModal.tsx
+++ b/components/social/friend-interaction/CoinModal.tsx
@@ -2,7 +2,7 @@ import React, { useState } from 'react';
 import { createPortal } from 'react-dom';
 import { motion, AnimatePresence } from 'framer-motion';
 import { Check, X } from 'lucide-react';
-import { useUserStats } from '@/contexts/UserStatsContext';
+import { useUser } from '@/store/selectors';
 
 interface CoinModalProps {
   isOpen: boolean;
@@ -14,7 +14,7 @@ interface CoinModalProps {
 }
 
 const CoinModal = ({ isOpen, onClose, type, friendId, friendName, friendCoins }: CoinModalProps) => {
-  const { coins, updateCoinsDisplay } = useUserStats();
+  const { coins, updateCoinsDisplay } = useUser();
   const [amount, setAmount] = useState('');
   const [isClosing, setIsClosing] = useState(false);
   const [isSubmitting, setIsSubmitting] = useState(false);
diff --git a/components/social/friend-request/RedeemReferralModal.tsx b/components/social/friend-request/RedeemReferralModal.tsx
index bb664b48abe876d2bc278ef9a4c22b281e93a9e4..0910ec6fa3785d45a605d01e669ed538a678c9e7 100644
--- a/components/social/friend-request/RedeemReferralModal.tsx
+++ b/components/social/friend-request/RedeemReferralModal.tsx
@@ -2,7 +2,6 @@ import React, { useEffect } from 'react';
 import { Dialog, DialogContent } from "@/components/ui/dialog";
 import { Button } from "@/components/ui/button";
 import Image from "next/image";
-import { UserInfo } from "@/hooks/useUserInfo";
 
 interface RedeemReferralModalProps {
   isOpen: boolean;
@@ -35,6 +34,7 @@ const RedeemReferralModal: React.FC<RedeemReferralModalProps> = ({
               alt="Coin"
               width={100}
               height={53}
+              sizes="100px"
               className="object-cover translate-y-[-22.5%] mx-auto"
             />
           </div>
diff --git a/components/social/profile/UserProfileModal.tsx b/components/social/profile/UserProfileModal.tsx
index 70d8bd1d517d3b813d6781c3499a6c0964b9bcb0..e8370e083598c3f1556097b9237858b7d7844c2f 100644
--- a/components/social/profile/UserProfileModal.tsx
+++ b/components/social/profile/UserProfileModal.tsx
@@ -4,7 +4,7 @@ import { FaPencilAlt } from 'react-icons/fa';
 import Image from 'next/image';
 import { SparkleEffect } from '@/components/effects/SparkleEffect';
 import PhotoSelectionModal from './PhotoSelectionModal';
-import { useProfileContext } from '@/contexts/UserProfileContext';
+import { useUser } from '@/store/selectors';
 import { CUSTOM_PARTICLES } from '@/config/particleEffects';
 import { useUserProfile } from '@/hooks/useUserProfile';
 import FriendMenu from '@/components/social/friend-interaction/FriendMenu';
@@ -155,7 +155,7 @@ const ProfilePhoto = React.memo(({
 ProfilePhoto.displayName = 'ProfilePhoto';
 
 const UserProfileModal = ({ isOpen, onClose, userEmail, userId, isEditable = false, onFriendRequest, showFriendButton = false, isSelfProfile = false }: UserProfileModalProps) => {
-  const { profile: selfProfile, isLoading: selfProfileLoading, updateProfile } = useProfileContext();
+  const { profile: selfProfile, profileLoading: selfProfileLoading, updateProfile } = useUser();
   // Only use useUserProfile for other users' profiles
   const profileParams = React.useMemo(() => {
     if (!isOpen || isSelfProfile) return null;
diff --git a/components/subscription-management-button.tsx b/components/subscription-management-button.tsx
index cffce83926cd75cbe1c919e63403415cdc16dafb..bb6d5a93e61f7f656e0e3f8b41b1027a5106c3cc 100644
--- a/components/subscription-management-button.tsx
+++ b/components/subscription-management-button.tsx
@@ -45,6 +45,7 @@ export function SubscriptionManagementButton({
                   src="/gleamingcoin.gif"
                   alt="Gold Subscription"
                   fill
+                  sizes="48px"
                   className="transform group-hover:scale-110 transition duration-200 scale-[1.9]"
                   style={{ objectFit: 'cover' }}
                 />
diff --git a/components/ui/DebugPanel.tsx b/components/ui/DebugPanel.tsx
new file mode 100644
index 0000000000000000000000000000000000000000..630258f51bbd58f93695656bfab787b5cda7f323
--- /dev/null
+++ b/components/ui/DebugPanel.tsx
@@ -0,0 +1,61 @@
+"use client";
+
+import { useState, useEffect } from 'react';
+import { usePathname, useSearchParams } from 'next/navigation';
+import { useUI, useUser, useGame } from '@/store/selectors'
+
+/* --- Constants ----- */
+const DEBUG_PARAM = 'debug'
+
+const DebugPanel = () => {
+  /* ---- State ----- */
+  const searchParams = useSearchParams()
+  const pathname = usePathname() || ''
+  const [isDebug, setIsDebug] = useState(false)
+  
+  // Zustand state
+  const uiState = useUI()
+  const userState = useUser()
+  const gameState = useGame()
+
+  /* --- Effects --- */
+  // Simple debug mode logic - only use URL parameter
+  useEffect(() => {
+    const debugValue = searchParams?.get(DEBUG_PARAM)
+    
+    if (debugValue === 'true') {
+      setIsDebug(true)
+      document.body.classList.add('debug-mode')
+    } else {
+      // Any other value (including null) - disable debug mode
+      setIsDebug(false)
+      document.body.classList.remove('debug-mode')
+    }
+  }, [searchParams, pathname])
+
+  // Don't render anything if not in debug mode
+  if (!isDebug) return null;
+
+  // Debug panel UI
+  return (
+    <div className="fixed bottom-4 right-4 z-[9999] bg-black/80 text-white p-4 rounded-lg max-w-[400px] max-h-[80vh] overflow-auto text-xs">
+      <h3 className="text-lg font-bold mb-2">Debug Panel</h3>
+      <div className="grid grid-cols-1 gap-2">
+        <div>
+          <h4 className="font-bold">UI State</h4>
+          <pre>{JSON.stringify(uiState, null, 2)}</pre>
+        </div>
+        <div>
+          <h4 className="font-bold">User State</h4>
+          <pre>{JSON.stringify(userState, null, 2)}</pre>
+        </div>
+        <div>
+          <h4 className="font-bold">Game State</h4>
+          <pre>{JSON.stringify(gameState, null, 2)}</pre>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+export default DebugPanel
\ No newline at end of file
diff --git a/components/ui/FilterButton.tsx b/components/ui/FilterButton.tsx
index 2eaabfc2e0c3d25aa51d03e45fe23bf3557e7a91..c8fecf294e00e23669ea4b687fb1990ba35a2cfb 100644
--- a/components/ui/FilterButton.tsx
+++ b/components/ui/FilterButton.tsx
@@ -1,5 +1,5 @@
 import React from "react";
-import { useTheme } from "@/contexts/ThemeContext";
+import { useUI } from "@/store/selectors";
 
 interface FilterButtonProps {
   subjects: string[];
@@ -12,7 +12,7 @@ const FilterButton: React.FC<FilterButtonProps> = ({
   onFilterChange,
   selectedValue,
 }) => {
-  const { theme } = useTheme();
+  const { theme } = useUI();
 
   const handleSubjectChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
     const subject = event.target.value;
diff --git a/contexts/AudioContext.tsx b/contexts/AudioContext.tsx
index 90e346da30ebaef3db828a109311243c41c27e58..382014c1416660eb6132ccb234102ff774080ec6 100644
--- a/contexts/AudioContext.tsx
+++ b/contexts/AudioContext.tsx
@@ -79,7 +79,19 @@ const VOLUME_COEFFICIENTS = {
   [SOUND_CATEGORIES.AMBIENT]: 0.75  // Ambient at half volume
 } as const;
 
+/* --- Constants ----- */
+const DEBUG = process.env.NODE_ENV === 'development';
+
+const logError = (error: Error, context: string) => {
+  if (DEBUG) {
+    console.error(`🎵 [Audio] ${context}:`, error);
+  }
+  // Always show user-facing error
+  toast.error('Audio playback issue. Please refresh if this persists.');
+};
+
 export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
+  console.log('🔍 [DEBUG] AudioProvider rendering');
   const [isPlaying, setIsPlaying] = useState(false);
   const [currentSong, setCurrentSong] = useState<string | null>(null);
   const [volumeState, setVolumeState] = useState(0.5);
@@ -123,7 +135,7 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
 
       return ctx;
     } catch (error) {
-      console.error('Failed to initialize audio context:', error);
+      logError(error as Error, 'Audio context initialization failed');
       throw error;
     }
   }, [volumeState]);
@@ -157,58 +169,35 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
       
       return audioBuffer;
     } catch (error) {
-      handleAudioError(error as Error, 'Error loading audio');
+      logError(error as Error, `Failed to load audio: ${url}`);
       throw error;
     }
   }, [initializeAudioContext, handleAudioError]);
 
   const stopMusic = useCallback(() => {
-    console.log('🎵 [AudioContext] Stop music requested:', {
-      currentSong,
-      isPlaying,
-      musicSource: Array.from(MUSIC_SOURCE.entries()),
-      loopSources: Array.from(LOOP_SOURCES.entries())
-    });
-
-    // Stop all music sources
     MUSIC_SOURCE.forEach((source, url) => {
       try {
-        console.log('🎵 [AudioContext] Stopping music source:', { url });
-        // Remove onended handler before stopping to prevent auto-advance
         source.onended = null;
         source.stop();
         source.disconnect();
         MUSIC_SOURCE.delete(url);
       } catch (error) {
-        console.error('🎵 [AudioContext] Error stopping music source:', { url, error });
+        logError(error as Error, 'Error stopping music');
       }
     });
 
     setIsPlaying(false);
     setCurrentSong(null);
-  }, [currentSong, isPlaying]);
+  }, []);
 
   const playMusic = useCallback(async (url: string, autoplay = true, onEnded?: () => void) => {
-    console.log('🎵 [AudioContext] Play music requested:', {
-      url,
-      autoplay,
-      currentSong,
-      musicSourceCount: MUSIC_SOURCE.size,
-      loopSourcesCount: LOOP_SOURCES.size,
-      currentVolume: volumeState,
-      isPlaying
-    });
-
     if (!autoplay) {
-      console.log('🎵 [AudioContext] Autoplay is false, stopping music');
       stopMusic();
       return null;
     }
 
     try {
-      // Clean up existing music source first (but leave loops running)
       if (MUSIC_SOURCE.size > 0) {
-        console.log('🎵 [AudioContext] Cleaning up existing music source before playing new song');
         stopMusic();
       }
 
@@ -216,8 +205,6 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
       const ctx = await initializeAudioContext();
       if (!ctx) throw new Error('No audio context');
 
-      // Set state before creating new source
-      console.log('🎵 [AudioContext] Setting up new music playback:', { url });
       setIsPlaying(true);
       setCurrentSong(url);
 
@@ -239,23 +226,15 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
       }
 
       source.onended = () => {
-        console.log('🎵 [AudioContext] Music source ended:', { url });
         MUSIC_SOURCE.delete(url);
         setIsPlaying(false);
         setCurrentSong(null);
         onEnded?.();
       };
 
-      console.log('🎵 [AudioContext] Started music playback:', { 
-        url,
-        musicSource: Array.from(MUSIC_SOURCE.keys()),
-        loopSources: Array.from(LOOP_SOURCES.keys())
-      });
-      
       return source;
     } catch (error) {
-      console.error('🎵 [AudioContext] Error playing music:', error);
-      handleAudioError(error as Error, 'Error playing audio');
+      logError(error as Error, 'Error playing music');
       return null;
     }
   }, [loadAudioBuffer, initializeAudioContext, stopMusic, handleAudioError, volumeState]);
@@ -303,18 +282,12 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
 
   // Simplify setVolume to only control master gain
   const setVolume = useCallback((newVolume: number) => {
-    if (!masterGainNode) {
-      console.warn('🔊 [Volume] Master gain node not available');
-      return;
-    }
+    if (!masterGainNode || !audioContextRef.current) return;
 
-    const ctx = audioContextRef.current;
-    if (ctx) {
-      const now = ctx.currentTime;
-      masterGainNode.gain.cancelScheduledValues(now);
-      masterGainNode.gain.linearRampToValueAtTime(newVolume, now + 0.1);
-      setVolumeState(newVolume);
-    }
+    const now = audioContextRef.current.currentTime;
+    masterGainNode.gain.cancelScheduledValues(now);
+    masterGainNode.gain.linearRampToValueAtTime(newVolume, now + 0.1);
+    setVolumeState(newVolume);
   }, []);
 
   const recoverAudioContext = useCallback(async () => {
@@ -332,11 +305,12 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
   }, []);
 
   const monitorPerformance = useCallback((ctx: AudioContext) => {
-    if (ctx.baseLatency > 0.025) { // More than 25ms latency
+    if (!DEBUG) return;
+    
+    if (ctx.baseLatency > 0.025) {
       console.warn('High audio latency detected:', ctx.baseLatency);
     }
     
-    // Monitor for buffer underruns
     if ((ctx as any).getOutputTimestamp) {
       const timestamp = (ctx as any).getOutputTimestamp();
       if (timestamp.contextTime > timestamp.performanceTime) {
@@ -353,36 +327,23 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
         audio.source.disconnect();
         audio.gainNode.disconnect();
         LOOP_SOURCES.delete(soundName);
-        console.log('🔁 [Ambient] Stopped loop:', soundName);
       } catch (error) {
-        console.error('[Ambient] Error stopping loop:', error);
+        console.error('Error stopping ambient sound:', error);
       }
     }
   }, []);
 
   const stopAllLoops = useCallback(() => {
-    console.log('🔁 [Ambient] Attempting to stop all loops:', {
-      activeLoops: Array.from(LOOP_SOURCES.keys()),
-      loopSourcesSize: LOOP_SOURCES.size
-    });
-    
     LOOP_SOURCES.forEach((audio, name) => {
       try {
-        console.log('🔁 [Ambient] Stopping loop:', name);
         audio.source.stop();
         audio.source.disconnect();
         audio.gainNode.disconnect();
         LOOP_SOURCES.delete(name);
       } catch (error) {
-        console.error('🔁 [Ambient] Error stopping loop:', name, error);
+        console.error('Error stopping ambient sound:', error);
       }
     });
-
-    // Verify cleanup
-    console.log('🔁 [Ambient] After cleanup:', {
-      remainingLoops: Array.from(LOOP_SOURCES.keys()),
-      loopSourcesSize: LOOP_SOURCES.size
-    });
   }, []);
 
   // Update loopSound to use coefficient
@@ -429,9 +390,7 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
   }, []);
 
   useEffect(() => {
-    console.log('🔊 AudioProvider mounted');
     return () => {
-      console.log('🔊 AudioProvider unmounted, cleaning up all audio');
       stopAllLoops();
       if (audioContextRef.current) {
         audioContextRef.current.close();
@@ -443,10 +402,11 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
   // Move the existing context check after all hook declarations
   const existingContext = useContext(AudioContext);
   if (existingContext) {
-    console.warn('🔊 Attempted to nest AudioProvider, skipping initialization');
+    console.log('🔍 [DEBUG] AudioProvider - existingContext found, skipping render');
     return <>{children}</>;
   }
 
+  console.log('🔍 [DEBUG] AudioProvider - creating new context');
   return (
     <AudioContext.Provider value={{
       isPlaying,
@@ -467,8 +427,10 @@ export const AudioProvider = ({ children }: { children: React.ReactNode }) => {
 };
 
 export const useAudio = () => {
+  console.log('🔍 [DEBUG] useAudio hook called');
   const context = useContext(AudioContext);
   if (context === null) {
+    console.error('🔍 [DEBUG] useAudio - context is null!');
     throw new Error('useAudio must be used within an AudioProvider');
   }
   return context;
diff --git a/contexts/MusicPlayerContext.tsx b/contexts/MusicPlayerContext.tsx
index eedcf76a7bf81c9f2afe9fa6cc27dce59899b001..31306a175da6f7da89e84b466f0a769797eae246 100644
--- a/contexts/MusicPlayerContext.tsx
+++ b/contexts/MusicPlayerContext.tsx
@@ -8,6 +8,7 @@ interface MusicPlayerContextType {
 const MusicPlayerContext = createContext<MusicPlayerContextType | undefined>(undefined);
 
 export const MusicPlayerProvider = ({ children }: { children: React.ReactNode }) => {
+  console.log('🔍 [DEBUG] MusicPlayerProvider rendering');
   const [isAutoPlay, setIsAutoPlay] = useState(false);
 
   return (
@@ -18,8 +19,10 @@ export const MusicPlayerProvider = ({ children }: { children: React.ReactNode })
 };
 
 export const useMusicPlayer = () => {
+  console.log('🔍 [DEBUG] useMusicPlayer hook called');
   const context = useContext(MusicPlayerContext);
   if (context === undefined) {
+    console.error('🔍 [DEBUG] useMusicPlayer - context is undefined!');
     throw new Error('useMusicPlayer must be used within a MusicPlayerProvider');
   }
   return context;
diff --git a/contexts/ThemeContext.tsx b/contexts/ThemeContext.tsx
deleted file mode 100644
index 2cb3042d1e7e2427dac4bbdb2e493ec31545755a..0000000000000000000000000000000000000000
--- a/contexts/ThemeContext.tsx
+++ /dev/null
@@ -1,41 +0,0 @@
-import React, { createContext, useState, useContext, useEffect } from 'react';
-
-type Theme = 'cyberSpace' | 'sakuraTrees' | 'sunsetCity' | 'mykonosBlue';
-
-interface ThemeContextType {
-  theme: Theme;
-  setTheme: (theme: Theme) => void;
-}
-
-const defaultTheme: ThemeContextType = {
-  theme: 'mykonosBlue',
-  setTheme: () => {},
-};
-
-const ThemeContext = createContext<ThemeContextType>(defaultTheme);
-
-export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
-  const [theme, setTheme] = useState<Theme>('mykonosBlue');
-
-  useEffect(() => {
-    const savedTheme = localStorage.getItem('theme') as Theme | null;
-    if (savedTheme && ['cyberSpace', 'sakuraTrees', 'sunsetCity', 'mykonosBlue'].includes(savedTheme)) {
-      setTheme(savedTheme);
-    }
-  }, []);
-
-  const updateTheme = (newTheme: Theme) => {
-    setTheme(newTheme);
-    localStorage.setItem('theme', newTheme);
-  };
-
-  return (
-    <ThemeContext.Provider value={{ theme, setTheme: updateTheme }}>
-      {children}
-    </ThemeContext.Provider>
-  );
-};
-
-export const useTheme = () => {
-  return useContext(ThemeContext);
-};
diff --git a/contexts/UserInfoContext.tsx b/contexts/UserInfoContext.tsx
deleted file mode 100644
index 79d76a479f478658c8e056752157e5656be5c06b..0000000000000000000000000000000000000000
--- a/contexts/UserInfoContext.tsx
+++ /dev/null
@@ -1,121 +0,0 @@
-'use client';
-
-import React, { createContext, useContext, useState, useCallback } from 'react';
-import { UserInfo } from '@/hooks/useUserInfo';
-import { OnboardingInfo } from '@/types';
-
-interface UserInfoContextType {
-  userInfo: UserInfo | null;
-  refreshUserInfo: () => Promise<void>;
-}
-
-const UserInfoContext = createContext<UserInfoContextType | undefined>(undefined);
-
-export const UserInfoProvider = ({ children }: { children: React.ReactNode }) => {
-  const [userInfo, setUserInfo] = useState<UserInfo | null>(null);
-
-  const refreshUserInfo = useCallback(async () => {
-    try {
-      const response = await fetch('/api/user-info');
-      if (!response.ok) throw new Error();
-      const data = await response.json();
-      await handleRedirect(data);
-      setUserInfo(data);
-    } catch (error) {
-      console.error('Failed to refresh user info:', error);
-    }
-  }, []);
-
-
-// Helper function to check if onboarding is complete
-function isOnboardingComplete(onboardingInfo?: OnboardingInfo): boolean {
-  if (!onboardingInfo) return false;
-
-  // Only check for targetScore
-  const targetScore = onboardingInfo.targetScore;
-  return targetScore !== undefined && targetScore !== null && targetScore > 0;
-}
-
-// Helper function to check if a path is accessible based on subscription
-function canAccessPath(subscriptionType: string | undefined, currentPath: string): boolean {
-  // System paths that are always accessible
-  const systemPaths = ['/api', '/auth'];
-  if (systemPaths.some(path => currentPath.startsWith(path))) {
-    return true;
-  }
-
-  // Paths accessible to all users
-  const unrestrictedPaths = ['/onboarding', '/mobile', '/ankiclinic', '/preferences'];
-  if (unrestrictedPaths.some(path => currentPath.startsWith(path))) {
-    return true;
-  }
-
-  // All other paths require gold or premium subscription
-  return subscriptionType === 'gold' || subscriptionType === 'premium';
-}
-
-// Helper function to determine if and where to redirect
-async function checkRedirectPath(userInfo: UserInfo | null, currentPath: string): Promise<string | null> {
-  // Don't redirect if already on redirect page
-  if (currentPath === '/redirect') return null;
-
-  // Don't redirect to onboarding if we're already there
-  if (currentPath.startsWith('/onboarding') || currentPath.startsWith('/mobile')) return null;
-
-  // No user info -> onboarding
-  if (!userInfo) return '/onboarding';
-
-  // Incomplete onboarding -> onboarding
-  if (!isOnboardingComplete(userInfo.onboardingInfo)) return '/onboarding';
-
-  // Check subscription-based access
-  if (!canAccessPath(userInfo.subscriptionType, currentPath)) {
-    return '/ankiclinic';
-  }
-
-  // Only exempt paths from study plan check
-  const studyPlanExemptPaths = ['/examcalendar', '/api', '/auth', '/onboarding', '/redirect'];
-  const shouldCheckStudyPlan = !studyPlanExemptPaths.some(path => currentPath.startsWith(path));
-
-  // Subscribed users -> check study plan (unless on exempt path)
-  if (shouldCheckStudyPlan && (userInfo.subscriptionType === 'gold' || userInfo.subscriptionType === 'premium')) {
-    try {
-      const studyPlanResponse = await fetch('/api/study-plan');
-      if (!studyPlanResponse.ok) {
-        throw new Error('Failed to fetch study plan');
-      }
-      const studyPlanData = await studyPlanResponse.json();
-
-      if (!studyPlanData.studyPlan) return '/examcalendar';
-    } catch (error) {
-      console.error('Error fetching study plan:', error);
-    }
-  }
-
-  return null;
-}
-
-// Helper function to handle redirect checks and navigation
-async function handleRedirect(userInfo: UserInfo | null): Promise<boolean> {
-  const redirectPath = await checkRedirectPath(userInfo, window.location.pathname);
-  if (redirectPath) {
-    window.location.href = redirectPath;
-    return true;
-  }
-  return false;
-}
-
-  return (
-    <UserInfoContext.Provider value={{ userInfo, refreshUserInfo }}>
-      {children}
-    </UserInfoContext.Provider>
-  );
-};
-
-export const useUserInfoContext = () => {
-  const context = useContext(UserInfoContext);
-  if (!context) {
-    throw new Error('useUserInfoContext must be used within UserInfoProvider');
-  }
-  return context;
-};
\ No newline at end of file
diff --git a/contexts/UserProfileContext.tsx b/contexts/UserProfileContext.tsx
deleted file mode 100644
index 1a1f9054659df08ca8b882401a580661ad985a7b..0000000000000000000000000000000000000000
--- a/contexts/UserProfileContext.tsx
+++ /dev/null
@@ -1,34 +0,0 @@
-"use client";
-
-import React, { createContext, useContext } from 'react';
-import { useUserProfile } from '@/hooks/useUserProfile';
-import { useUser } from '@clerk/nextjs';
-
-interface UserProfileContextType {
-  profile: any;
-  isLoading: boolean;
-  updateProfile: (updates: any) => Promise<void>;
-}
-
-const UserProfileContext = createContext<UserProfileContextType | null>(null);
-
-export const UserProfileProvider = ({ children }: { children: React.ReactNode }) => {
-  const { user } = useUser();
-  const email = user?.primaryEmailAddress?.emailAddress;
-  
-  const { profile, isLoading, updateProfile } = useUserProfile(
-    email ? { email } : null
-  );
-
-  return (
-    <UserProfileContext.Provider value={{ profile, isLoading, updateProfile }}>
-      {children}
-    </UserProfileContext.Provider>
-  );
-};
-
-export const useProfileContext = () => {
-  const context = useContext(UserProfileContext);
-  if (!context) throw new Error('useProfileContext must be used within UserProfileProvider');
-  return context;
-}; 
\ No newline at end of file
diff --git a/contexts/UserStatsContext.tsx b/contexts/UserStatsContext.tsx
deleted file mode 100644
index 13178122d1ded22647cb43fb4f90cada61c54b40..0000000000000000000000000000000000000000
--- a/contexts/UserStatsContext.tsx
+++ /dev/null
@@ -1,45 +0,0 @@
-import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
-import { useUserInfo } from '@/hooks/useUserInfo';
-
-interface UserStatsContextType {
-  coins: number;
-  updateCoins: (amount: number) => Promise<void>;  // DB update
-  updateCoinsDisplay: (newAmount: number) => void;  // UI-only update
-  isLoading: boolean;
-}
-
-const UserStatsContext = createContext<UserStatsContextType | undefined>(undefined);
-
-export const UserStatsProvider = ({ children }: { children: React.ReactNode }) => {
-  const { userInfo, updateScore, isLoading } = useUserInfo();
-  const [displayCoins, setDisplayCoins] = useState<number>(0);
-
-  useEffect(() => {
-    if (userInfo?.score !== undefined) {
-      setDisplayCoins(userInfo.score);
-    }
-  }, [userInfo?.score]);
-
-  const updateCoinsDisplay = useCallback((newAmount: number) => {
-    setDisplayCoins(newAmount);
-  }, []);
-
-  return (
-    <UserStatsContext.Provider value={{ 
-      coins: userInfo?.score ?? displayCoins,
-      updateCoins: updateScore,
-      updateCoinsDisplay,
-      isLoading
-    }}>
-      {children}
-    </UserStatsContext.Provider>
-  );
-};
-
-export const useUserStats = () => {
-  const context = useContext(UserStatsContext);
-  if (context === undefined) {
-    throw new Error('useUserStats must be used within a UserStatsProvider');
-  }
-  return context;
-}; 
\ No newline at end of file
diff --git a/hooks/useAudioTransitions.ts b/hooks/useAudioTransitions.ts
new file mode 100644
index 0000000000000000000000000000000000000000..17121f7830fe9ddb556d89939d3cc326dc9ea8ea
--- /dev/null
+++ b/hooks/useAudioTransitions.ts
@@ -0,0 +1,135 @@
+import { useRef, useEffect, useCallback } from 'react';
+import { useAudio } from "@/contexts/AudioContext";
+
+interface UseAudioTransitionsProps {
+  isFlashcardsOpen: boolean;
+  isLoading: boolean;
+  isMounted?: boolean;
+}
+
+/**
+ * Custom hook to manage audio transitions between different states
+ * Handles playing door sounds and looping ambient sounds
+ */
+export const useAudioTransitions = ({ 
+  isFlashcardsOpen, 
+  isLoading,
+  isMounted = true
+}: UseAudioTransitionsProps) => {
+  const audio = useAudio();
+  
+  // Refs to track state
+  const audioTransitionInProgressRef = useRef<boolean>(false);
+  const prevIsFlashcardsOpenRef = useRef<boolean | null>(null);
+  const prevFlashcardsOpenRef = useRef<boolean>(false);
+  
+  // Effect to handle audio transitions when flashcard dialog opens/closes
+  useEffect(() => {
+    // Skip if the value hasn't actually changed
+    if (prevIsFlashcardsOpenRef.current === isFlashcardsOpen) {
+      return;
+    }
+    
+    // Update the ref
+    prevIsFlashcardsOpenRef.current = isFlashcardsOpen;
+    
+    if (!isMounted) {
+      return;
+    }
+    
+    let isEffectActive = true; // Local flag to track if effect is still active
+    
+    // Add a small delay to allow any loading state changes to settle
+    const timeoutId = setTimeout(() => {
+      // Skip audio transitions during initial load
+      if (isLoading) {
+        return;
+      }
+      
+      // Prevent multiple audio transitions
+      if (audioTransitionInProgressRef.current) {
+        return;
+      }
+      
+      audioTransitionInProgressRef.current = true;
+  
+      const handleAudioTransition = async () => {
+        try {
+          if (!isEffectActive) return;
+
+          if (isFlashcardsOpen) {
+            await audio.stopAllLoops();
+            if (!isEffectActive) return;
+            audio.playSound('flashcard-door-open');
+          } else {
+            if (prevFlashcardsOpenRef.current) {
+              audio.playSound('flashcard-door-closed');
+              await new Promise(resolve => setTimeout(resolve, 500));
+              if (!isEffectActive) return;
+              await audio.loopSound('flashcard-loop-catfootsteps');
+            } else {
+              await audio.loopSound('flashcard-loop-catfootsteps');
+            }
+          }
+          if (!isEffectActive) return;
+          prevFlashcardsOpenRef.current = isFlashcardsOpen;
+        } catch (error) {
+          if (isEffectActive) {
+            console.error('[AudioTransitions] Audio transition error:', error);
+          }
+        } finally {
+          if (isEffectActive) {
+            audioTransitionInProgressRef.current = false;
+          }
+        }
+      };
+
+      handleAudioTransition();
+    }, 50); // Small delay to allow loading state to settle
+
+    return () => {
+      clearTimeout(timeoutId);
+      isEffectActive = false;
+    };
+  }, [isFlashcardsOpen, audio, isLoading, isMounted]);
+
+  // Function to initialize ambient sound on component mount
+  const initializeAmbientSound = useCallback(() => {
+    if (!audio || audioTransitionInProgressRef.current) return;
+    
+    const initAmbientSound = async () => {
+      try {
+        audioTransitionInProgressRef.current = true;
+        await audio.loopSound('flashcard-loop-catfootsteps');
+      } catch (error) {
+        console.error('[AudioTransitions] Error initializing ambient sound:', error);
+      } finally {
+        audioTransitionInProgressRef.current = false;
+      }
+    };
+    
+    // Only start ambient sound if flashcards are not open
+    if (!isFlashcardsOpen) {
+      initAmbientSound();
+    }
+  }, [audio, isFlashcardsOpen]);
+
+  // Function to stop all audio
+  const stopAllAudio = useCallback(async () => {
+    if (!audio) return;
+    
+    try {
+      await audio.stopAllLoops();
+    } catch (error) {
+      console.error('[AudioTransitions] Error stopping audio:', error);
+    }
+  }, [audio]);
+
+  return {
+    initializeAmbientSound,
+    stopAllAudio,
+    isAudioTransitionInProgress: () => audioTransitionInProgressRef.current
+  };
+};
+
+export default useAudioTransitions; 
\ No newline at end of file
diff --git a/hooks/useNotifications.ts b/hooks/useNotifications.ts
index c30d138b98dabdfd675e6e81eae84477054250fa..57a20402f5dff98aa9b9470e9c8eba345a95c314 100644
--- a/hooks/useNotifications.ts
+++ b/hooks/useNotifications.ts
@@ -1,6 +1,6 @@
 import { useState, useEffect, useCallback } from 'react';
 import { toast } from 'react-hot-toast';
-import { useUserInfoContext } from '@/contexts/UserInfoContext';
+import { useUser } from '@/store/selectors';
 
 export type NotificationType = 'coin' | 'reply';
 export type NotificationStatus = 'active' | 'canceled' | 'accepted' | 'rejected';
@@ -25,7 +25,7 @@ export const useNotifications = () => {
     const [notifications, setNotifications] = useState<Notification[]>([]);
     const [isLoading, setIsLoading] = useState(true);
     const [unreadCount, setUnreadCount] = useState(0);
-    const { refreshUserInfo } = useUserInfoContext();
+    const { refreshUserInfo } = useUser();
 
     const fetchNotifications = useCallback(async () => {
         try {
diff --git a/hooks/useUserInfo.ts b/hooks/useUserInfo.ts
index 78e76dacea21b5261139e414e534dc8e0e8e8d23..85c180b30736118d2353664d1a277aa9b6b3abaf 100644
--- a/hooks/useUserInfo.ts
+++ b/hooks/useUserInfo.ts
@@ -1,42 +1,8 @@
-import { OnboardingInfo } from "@/types";
 import { useState, useCallback, useEffect, useRef } from "react";
 import toast from "react-hot-toast";
-import { useUser } from "@clerk/nextjs";
-import { useUserInfoContext } from "@/contexts/UserInfoContext";
-
-export interface UserInfo {
-  unlocks?: string[];
-  userId: string;
-  bio: string;
-  firstName: string;
-  apiCount: number;
-  score: number;
-  streak: number;
-  clinicRooms: string;
-  hasPaid: boolean;
-  subscriptionType: string;
-  diagnosticScores: {
-    total: string;
-    cp: string;
-    cars: string;
-    bb: string;
-    ps: string;
-  };
-  notificationPreference?: string;
-  onboardingInfo?: OnboardingInfo;
-  referrals?: any[];
-}
-
-interface Referral {
-  id: string;
-  userId: string;
-  referrerName: string;
-  referrerEmail: string;
-  friendEmail: string;
-  friendUserId: string;
-  createdAt: Date;
-  joinedAt: Date | null;
-}
+import { useUser as useClerkUser } from "@clerk/nextjs";
+import { useUser } from "@/store/selectors";
+import { UserInfo, Referral } from "@/types/user";
 
 interface UseUserInfoReturn {
   userInfo: UserInfo | null;
@@ -64,14 +30,16 @@ interface UseUserInfoReturn {
 }
 
 export const useUserInfo = (): UseUserInfoReturn => {
-  const { user } = useUser();
-  const { userInfo, refreshUserInfo } = useUserInfoContext();
+  const { user } = useClerkUser();
+  const { userInfo, refreshUserInfo } = useUser();
   const [isLoading, setIsLoading] = useState(true);
   const hasInitialized = useRef(false);
+  
+  const [referrals, setReferrals] = useState<Referral[]>([]);
 
   const fetchUserInfo = useCallback(async () => {
     try {
-      refreshUserInfo();
+      await refreshUserInfo();
     } catch (error) {
       console.error('Failed to fetch user info:', error);
       toast.error('Failed to load user info');
@@ -289,7 +257,7 @@ export const useUserInfo = (): UseUserInfoReturn => {
   }, [refreshUserInfo]);
 
   return {
-    userInfo,
+    userInfo: userInfo as UserInfo | null,
     isLoading,
     isSubscribed: userInfo?.subscriptionType === 'gold' || userInfo?.subscriptionType === 'premium',
     updateScore,
@@ -298,7 +266,7 @@ export const useUserInfo = (): UseUserInfoReturn => {
     incrementScore,
     decrementScore,
     refetch: fetchUserInfo,
-    referrals: userInfo?.referrals || [],
+    referrals,
     isLoadingReferrals: false,
     fetchReferrals,
     createReferral,
diff --git a/store/README-STATE.md b/store/README-STATE.md
new file mode 100644
index 0000000000000000000000000000000000000000..452b8528a2728325fd606719334e7fb5bd9ffe86
--- /dev/null
+++ b/store/README-STATE.md
@@ -0,0 +1,301 @@
+# Global State Management Overview
+
+## Zustand Best Practices
+
+### Using Zustand Stores
+
+```typescript
+// Import selectors from the selectors.ts file
+import { useUI, useUser, useGame } from '@/store/selectors';
+
+// Component example
+const MyComponent = () => {
+  // Use the selector to access only what you need
+  const { theme, setTheme } = useUI();
+  const { userInfo, isSubscribed } = useUser();
+  
+  // Now you can use the state and actions
+  return (
+    <div>
+      <p>Current theme: {theme}</p>
+      <button onClick={() => setTheme('cyberSpace')}>
+        Switch Theme
+      </button>
+    </div>
+  );
+};
+```
+
+### Best Practices
+
+1. **Use Selectors**
+   - Always import from `selectors.ts`, not directly from store files
+   - Use the most specific selector for your needs to minimize re-renders
+   - Example: `useTheme()` instead of `useUI()` if you only need theme data
+
+2. **State Updates**
+   - Use the provided actions to update state
+   - Never modify state directly
+   - Batch related updates when possible
+
+3. **Performance Optimization**
+   - Subscribe only to what you need
+   - Use memoization for expensive computations
+   - Consider using `shallow` equality for complex objects
+
+4. **TypeScript Integration**
+   - Leverage TypeScript for type safety
+   - Use proper type inference with Zustand
+   - Define interfaces for all state slices
+
+5. **Debugging**
+   - Use the debug panel with `?debug=true` URL parameter
+   - Check state updates in React DevTools
+   - Add meaningful action names for easier debugging
+
+## Current Zustand Stores
+
+### UI Store (`store.ts`)
+```typescript
+{
+  // Device & Window Information
+  window: {
+    width: number
+    height: number
+    isDesktop: boolean
+  }
+  
+  // Route Information
+  currentRoute: string
+  
+  // Theme Settings
+  theme: ThemeType // 'cyberSpace' | 'sakuraTrees' | 'sunsetCity' | 'mykonosBlue'
+  
+  // Actions
+  setWindowSize: (size: WindowSize) => void
+  setCurrentRoute: (route: string) => void
+  setTheme: (theme: ThemeType) => void
+}
+```
+
+### User Store (`store.ts`)
+```typescript
+{
+  // UserProfile state
+  profile: UserProfile['profile'];
+  profileLoading: boolean;
+  isProfileComplete: boolean;
+  completedSteps: string[];
+  studyPreferences: {
+    dailyGoal: number;
+    reminderTime: string;
+  };
+  interfaceSettings: {
+    darkMode: boolean;
+    fontSize: string;
+  };
+  tutorialProgress: {
+    currentStep: number;
+    completedRoutes: string[];
+  };
+  hasCompletedOnboarding: boolean;
+  lastVisitedRoute: string;
+  onboardingRoute: string;
+  
+  // UserInfo state
+  userInfo: UserInfoState['userInfo'];
+  isSubscribed: boolean;
+  
+  // UserStats state
+  coins: number;
+  statsLoading: boolean;
+  
+  // Actions
+  updateProfile: (updates: any) => Promise<void>;
+  refreshUserInfo: () => Promise<void>;
+  updateCoins: (amount: number) => Promise<void>;
+  updateCoinsDisplay: (newAmount: number) => void;
+  setIsSubscribed: (status: boolean) => void;
+  setCompletedSteps: (steps: string[]) => void;
+  addCompletedStep: (step: string) => void;
+  updateStudyPreferences: (preferences: Partial<UserSlice['studyPreferences']>) => void;
+  updateInterfaceSettings: (settings: Partial<UserSlice['interfaceSettings']>) => void;
+  updateTutorialProgress: (progress: Partial<UserSlice['tutorialProgress']>) => void;
+  setHasCompletedOnboarding: (completed: boolean) => void;
+  setLastVisitedRoute: (route: string) => void;
+  setOnboardingRoute: (route: string) => void;
+}
+```
+
+### Game Store (`store.ts`)
+```typescript
+{
+  // Game state
+  gameState: {
+    currentRoom: string;
+    visitedRooms: string[];
+    inventory: string[];
+    gameProgress: number;
+  };
+  
+  // Debug state
+  debugMode: boolean;
+  
+  // Actions
+  setCurrentRoom: (room: string) => void;
+  addVisitedRoom: (room: string) => void;
+  addToInventory: (item: string) => void;
+  removeFromInventory: (item: string) => void;
+  setGameProgress: (progress: number) => void;
+  setDebugMode: (enabled: boolean) => void;
+}
+```
+
+### Selectors (`selectors.ts`)
+```typescript
+// UI Selectors
+useUI() => { theme, window, currentRoute, setTheme, setWindowSize, setCurrentRoute }
+useTheme() => theme
+useWindowSize() => window
+useCurrentRoute() => currentRoute
+
+// User Selectors
+useUser() => { 
+  // All user-related state and actions
+  profile, profileLoading, updateProfile, isProfileComplete, completedSteps,
+  studyPreferences, interfaceSettings, tutorialProgress, hasCompletedOnboarding,
+  lastVisitedRoute, onboardingRoute, setCompletedSteps, addCompletedStep,
+  updateStudyPreferences, updateInterfaceSettings, updateTutorialProgress,
+  setHasCompletedOnboarding, setLastVisitedRoute, setOnboardingRoute,
+  userInfo, isSubscribed, coins, statsLoading, updateCoins, updateCoinsDisplay,
+  setIsSubscribed, refreshUserInfo
+}
+
+// Game Selectors
+useGame() => {
+  // All game-related state and actions
+  gameState, debugMode, setCurrentRoom, addVisitedRoom, 
+  addToInventory, removeFromInventory, setGameProgress, setDebugMode
+}
+
+// Individual Profile Selectors
+useProfileComplete() => isProfileComplete
+useCompletedSteps() => completedSteps
+useStudyPreferences() => studyPreferences
+useInterfaceSettings() => interfaceSettings
+useTutorialProgress() => tutorialProgress
+useOnboardingStatus() => { hasCompletedOnboarding, lastVisitedRoute, onboardingRoute }
+```
+
+## Completed Migrations
+- ✅ Theme Management: Migrated from `ThemeContext` to Zustand UI Store
+- ✅ Window Size: Implemented in UI Store with dedicated tracker component
+- ✅ Route Tracking: Added to UI Store with RouteHandler component
+- ✅ UserStats: Migrated from `UserStatsContext` to Zustand User Store
+- ✅ UserInfo: Migrated from `UserInfoContext` to Zustand User Store
+- ✅ UserProfile: Migrated from `UserProfileContext` to Zustand User Store
+- ✅ Consolidated selectors: Combined user-related selectors into a single `useUser` selector
+- ✅ Debug Mode: Implemented in Game Store with URL parameter control
+- ✅ Route Transitions: Enhanced RouteHandler with smooth transitions and debug mode support
+
+## Current Context API State (To Be Migrated)
+
+### [VocabContext](../contexts/VocabContext.tsx)
+- Vocabulary Management:
+  - `vocabList: string[]`
+  - `addVocabWord: (word: string) => void`
+  - `removeVocabWord: (word: string) => void`
+  - `isCmdIEnabled: boolean`
+  - `toggleCmdI: () => void`
+
+### [AudioContext](../contexts/AudioContext.tsx)
+- Sound Control:
+  - `volume: number`
+  - `isMuted: boolean`
+  - `playSound: (soundId: string) => void`
+  - `stopAllLoops: () => Promise<void>`
+  - `loopSound: (soundId: string) => Promise<void>`
+  - `setVolume: (volume: number) => void`
+
+### [MusicPlayerContext](../contexts/MusicPlayerContext.tsx)
+- Music Player:
+  - `isPlaying: boolean`
+  - `currentTrack: string`
+  - `isAutoPlay: boolean`
+  - `setIsAutoPlay: (autoPlay: boolean) => void`
+
+### [AnkiClinicContext](../contexts/AnkiClinicContext.tsx)
+- Game State:
+  - `gameState: GameState`
+  - `dispatch: (action: GameAction) => void`
+  - `resetGame: () => void`
+  - `loadGame: (savedState: GameState) => void`
+
+## Migration Plan
+
+### Priority for Migration to Zustand
+1. Game State (AnkiClinic) - In Progress
+   - Partially migrated to Game Store
+   - Need to complete migration of game logic and state
+   - Will handle game progress, quiz state, and room management
+
+2. Media Management - Low Priority
+   - Combine `AudioContext`, `MusicPlayerContext`
+   - Create `mediaStore`
+   - Will handle sound effects, music, and volume controls
+
+### Keep in Context API
+- VocabContext (real-time features)
+- Form-related contexts
+- DOM-interaction heavy features
+
+## Best Practices for Migration
+1. State Splitting:
+   - Keep related state together
+   - Split by domain/feature
+   - Consider update frequency
+
+2. Performance:
+   - Use selective subscriptions
+   - Implement specialized selectors
+   - Avoid unnecessary rerenders
+
+3. Type Safety:
+   - Maintain strict TypeScript types
+   - Use proper type inference
+   - Document state shape
+
+4. Migration Process:
+   - Migrate one context at a time
+   - Write tests before migration
+   - Update components gradually
+   - Keep backward compatibility 
+
+## Maintenance Guidelines
+1. When adding new state:
+   - Add to appropriate store file
+   - Create selectors in selectors.ts
+   - Update this README
+   - Consider performance implications
+
+2. When creating new selectors:
+   - Add to selectors.ts
+   - Create both combined and individual selectors
+   - Document with JSDoc comments
+
+3. When migrating contexts:
+   - Update the "Completed Migrations" section
+   - Remove from "To Be Migrated" section
+   - Document any breaking changes 
+
+## Migration Progress Notes
+- UserStats and UserInfo contexts have been successfully migrated to Zustand
+- The Zustand store now handles user data fetching and updates
+- A `StoreInitializer` component has been added to initialize the store on app load
+- User selectors have been consolidated into a single `useUser` selector for better organization
+- TypeScript types have been moved to a shared `types/user.ts` file to avoid circular dependencies
+- UserProfileContext has been migrated to Zustand with all profile-related state and actions
+- A compatibility layer has been added to UserProfileContext.tsx to maintain backward compatibility
+- Debug mode has been implemented with URL parameter control
+- RouteHandler has been enhanced with smooth transitions and debug mode support
+- Next steps: Complete Game State (AnkiClinic) migration and implement Media Management store 
\ No newline at end of file
diff --git a/store/gameStoreUtils.ts b/store/gameStoreUtils.ts
new file mode 100644
index 0000000000000000000000000000000000000000..449648e78aeb98d3d3f3c79ca94d8f1b874441ed
--- /dev/null
+++ b/store/gameStoreUtils.ts
@@ -0,0 +1,113 @@
+// Game-specific calculation functions for the Zustand store
+
+export const tierRooms = [
+  "PATIENT LEVEL",
+  "INTERN LEVEL",
+  "RESIDENT LEVEL",
+  "FELLOWSHIP LEVEL",
+  "ATTENDING LEVEL",
+  "PHYSICIAN LEVEL",
+  "MEDICAL DIRECTOR LEVEL"
+];
+
+/**
+ * Calculates the player's level based on their owned rooms
+ * Checks from highest to lowest tier and returns the highest tier found
+ */
+export const calculatePlayerLevel = (userRooms: string[]): string => {
+  for (let i = tierRooms.length - 1; i >= 0; i--) {
+    if (userRooms.includes(tierRooms[i])) {
+      return tierRooms[i];
+    }
+  }
+  
+  return "PATIENT LEVEL";
+};
+
+/**
+ * Gets the numeric level index from a level string
+ */
+export const getLevelNumber = (levelString: string): number => {
+  const index = tierRooms.indexOf(levelString);
+  return index === -1 ? 0 : index;
+};
+
+/**
+ * Returns the number of patients per day based on player level
+ */
+export const getPatientsPerDay = (playerLevel: number): number => {
+  const patientsMap: { [level: number]: number } = {
+    0: 0,   // PATIENT LEVEL
+    1: 4,   // INTERN LEVEL
+    2: 8,   // RESIDENT LEVEL
+    3: 10,  // FELLOWSHIP LEVEL
+    4: 16,  // ATTENDING LEVEL
+    5: 24,  // PHYSICIAN LEVEL
+    6: 30,  // MEDICAL DIRECTOR LEVEL
+  };
+
+  return patientsMap[playerLevel] || 0;
+};
+
+/**
+ * Calculates the total Quality of Care based on player level and streak days
+ */
+export const calculateTotalQC = (playerLevel: number, streakDays: number): number => {
+  const levelQCValues: { [level: number]: number } = {
+    0: 0.5, // PATIENT LEVEL
+    1: 1.0,
+    2: 1.2,
+    3: 1.4,
+    4: 1.6,
+    5: 1.8,
+    6: 2.0,
+  };
+
+  // Streak modifier values based on streak days (max 2.5)
+  const streakModifiers: { [days: number]: number } = {
+    1: 1.0,
+    2: 1.1,
+    3: 1.2,
+    4: 1.3,
+    5: 1.4,
+    6: 1.5,
+    7: 2.0,  // Bigger jump at 7 days
+    8: 2.1,
+    9: 2.2,
+    10: 2.3,
+    11: 2.4,
+    12: 2.5,
+    13: 2.5,
+    14: 2.5,
+  };
+
+  const levelQC = levelQCValues[playerLevel] || 0.5;
+  const streakQC = streakDays >= 14 ? 2.5 : (streakModifiers[streakDays] || 1.0);
+
+  return levelQC + streakQC;
+};
+
+/**
+ * Returns the clinic cost per day based on player level
+ */
+export const getClinicCostPerDay = (playerLevel: number): number => {
+  return 0;  // Remove daily costs while keeping initial unlock costs
+};
+
+/**
+ * Calculates the Quality of Care based on user rooms
+ */
+export const calculateQualityOfCare = (userRooms: string[]): number => {
+  const playerLevel = getLevelNumber(calculatePlayerLevel(userRooms));
+  const levelQCValues: { [level: number]: number } = {
+    0: 0.5, // PATIENT LEVEL
+    1: 1.0,
+    2: 1.25,
+    3: 1.5,
+    4: 1.5,
+    5: 1.75,
+    6: 2.0,
+  };
+
+  return levelQCValues[playerLevel] || 0.5;
+}; 
\ No newline at end of file
diff --git a/store/selectors.ts b/store/selectors.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e4249f6feb9249a7af564adda172a76b8bb04b43
--- /dev/null
+++ b/store/selectors.ts
@@ -0,0 +1,202 @@
+import { useStore } from './store'
+
+/* --- UI Selectors ---- */
+export const useUI = () => {
+  const theme = useStore((state) => state.theme)
+  const window = useStore((state) => state.window)
+  const currentRoute = useStore((state) => state.currentRoute)
+  const setTheme = useStore((state) => state.setTheme)
+  const setWindowSize = useStore((state) => state.setWindowSize)
+  const setCurrentRoute = useStore((state) => state.setCurrentRoute)
+  
+  return {
+    theme,
+    window,
+    currentRoute,
+    setTheme,
+    setWindowSize,
+    setCurrentRoute,
+  }
+}
+
+// Individual property selectors for performance
+export const useTheme = () => useStore(state => state.theme)
+export const useWindowSize = () => useStore(state => state.window)
+export const useCurrentRoute = () => useStore(state => state.currentRoute)
+
+/* --- User Selector ---- */
+// Consolidated user selector that provides all user-related state and actions
+export const useUser = () => {
+  // Profile state and actions
+  const profile = useStore((state) => state.profile)
+  const profileLoading = useStore((state) => state.profileLoading)
+  const updateProfile = useStore((state) => state.updateProfile)
+  const isProfileComplete = useStore((state) => state.isProfileComplete)
+  const completedSteps = useStore((state) => state.completedSteps)
+  const studyPreferences = useStore((state) => state.studyPreferences)
+  const interfaceSettings = useStore((state) => state.interfaceSettings)
+  const tutorialProgress = useStore((state) => state.tutorialProgress)
+  const hasCompletedOnboarding = useStore((state) => state.hasCompletedOnboarding)
+  const lastVisitedRoute = useStore((state) => state.lastVisitedRoute)
+  const onboardingRoute = useStore((state) => state.onboardingRoute)
+  
+  // Profile actions
+  const setCompletedSteps = useStore((state) => state.setCompletedSteps)
+  const addCompletedStep = useStore((state) => state.addCompletedStep)
+  const updateStudyPreferences = useStore((state) => state.updateStudyPreferences)
+  const updateInterfaceSettings = useStore((state) => state.updateInterfaceSettings)
+  const updateTutorialProgress = useStore((state) => state.updateTutorialProgress)
+  const setHasCompletedOnboarding = useStore((state) => state.setHasCompletedOnboarding)
+  const setLastVisitedRoute = useStore((state) => state.setLastVisitedRoute)
+  const setOnboardingRoute = useStore((state) => state.setOnboardingRoute)
+  
+  // User info state and actions
+  const userInfo = useStore((state) => state.userInfo)
+  const isSubscribed = useStore((state) => state.isSubscribed)
+  const setIsSubscribed = useStore((state) => state.setIsSubscribed)
+  
+  // User stats state and actions
+  const coins = useStore((state) => state.coins)
+  const statsLoading = useStore((state) => state.statsLoading)
+  const updateCoins = useStore((state) => state.updateCoins)
+  const updateCoinsDisplay = useStore((state) => state.updateCoinsDisplay)
+  
+  // Shared actions
+  const refreshUserInfo = useStore((state) => state.refreshUserInfo)
+  
+  return {
+    // Profile state and actions
+    profile,
+    profileLoading,
+    updateProfile,
+    isProfileComplete,
+    completedSteps,
+    studyPreferences,
+    interfaceSettings,
+    tutorialProgress,
+    hasCompletedOnboarding,
+    lastVisitedRoute,
+    onboardingRoute,
+    
+    // Profile actions
+    setCompletedSteps,
+    addCompletedStep,
+    updateStudyPreferences,
+    updateInterfaceSettings,
+    updateTutorialProgress,
+    setHasCompletedOnboarding,
+    setLastVisitedRoute,
+    setOnboardingRoute,
+    
+    // User info state and actions
+    userInfo,
+    isSubscribed,
+    setIsSubscribed,
+    
+    // User stats state and actions
+    coins,
+    statsLoading,
+    updateCoins,
+    updateCoinsDisplay,
+    
+    // Shared actions
+    refreshUserInfo,
+  }
+}
+
+/* --- Game Selector ---- */
+// Consolidated game selector that provides all game-related state and actions
+export const useGame = () => {
+  // Game progress
+  const userRooms = useStore((state) => state.userRooms)
+  const userLevel = useStore((state) => state.userLevel)
+  const patientsPerDay = useStore((state) => state.patientsPerDay)
+  const totalPatients = useStore((state) => state.totalPatients)
+  const streakDays = useStore((state) => state.streakDays)
+  
+  // Active game session
+  const isGameInProgress = useStore((state) => state.isGameInProgress)
+  const currentUserTestId = useStore((state) => state.currentUserTestId)
+  const isFlashcardsOpen = useStore((state) => state.isFlashcardsOpen)
+  const flashcardRoomId = useStore((state) => state.flashcardRoomId)
+  const activeRooms = useStore((state) => state.activeRooms)
+  const completeAllRoom = useStore((state) => state.completeAllRoom)
+  
+  // Test results
+  const userResponses = useStore((state) => state.userResponses)
+  const correctCount = useStore((state) => state.correctCount)
+  const wrongCount = useStore((state) => state.wrongCount)
+  const testScore = useStore((state) => state.testScore)
+  
+  // Game actions
+  const startGame = useStore((state) => state.startGame)
+  const endGame = useStore((state) => state.endGame)
+  const unlockRoom = useStore((state) => state.unlockRoom)
+  const setFlashcardRoomId = useStore((state) => state.setFlashcardRoomId)
+  const setIsFlashcardsOpen = useStore((state) => state.setIsFlashcardsOpen)
+  const setActiveRooms = useStore((state) => state.setActiveRooms)
+  const setCompleteAllRoom = useStore((state) => state.setCompleteAllRoom)
+  const setUserResponses = useStore((state) => state.setUserResponses)
+  const setCorrectCount = useStore((state) => state.setCorrectCount)
+  const setWrongCount = useStore((state) => state.setWrongCount)
+  const setTestScore = useStore((state) => state.setTestScore)
+  const resetGameState = useStore((state) => state.resetGameState)
+  const setUserRooms = useStore((state) => state.setUserRooms)
+  const updateUserLevel = useStore((state) => state.updateUserLevel)
+  const setStreakDays = useStore((state) => state.setStreakDays)
+  const setTotalPatients = useStore((state) => state.setTotalPatients)
+  
+  return {
+    // Game progress
+    userRooms,
+    userLevel,
+    patientsPerDay,
+    totalPatients,
+    streakDays,
+    
+    // Active game session
+    isGameInProgress,
+    currentUserTestId,
+    isFlashcardsOpen,
+    flashcardRoomId,
+    activeRooms,
+    completeAllRoom,
+    
+    // Test results
+    userResponses,
+    correctCount,
+    wrongCount,
+    testScore,
+    
+    // Game actions
+    startGame,
+    endGame,
+    unlockRoom,
+    setFlashcardRoomId,
+    setIsFlashcardsOpen,
+    setActiveRooms,
+    setCompleteAllRoom,
+    setUserResponses,
+    setCorrectCount,
+    setWrongCount,
+    setTestScore,
+    resetGameState,
+    setUserRooms,
+    updateUserLevel,
+    setStreakDays,
+    setTotalPatients,
+  }
+}
+
+/* --- Individual Profile Selectors ---- */
+// For components that only need specific profile data
+export const useProfileComplete = () => useStore(state => state.isProfileComplete)
+export const useCompletedSteps = () => useStore(state => state.completedSteps)
+export const useStudyPreferences = () => useStore(state => state.studyPreferences)
+export const useInterfaceSettings = () => useStore(state => state.interfaceSettings)
+export const useTutorialProgress = () => useStore(state => state.tutorialProgress)
+export const useOnboardingStatus = () => ({
+  hasCompletedOnboarding: useStore(state => state.hasCompletedOnboarding),
+  lastVisitedRoute: useStore(state => state.lastVisitedRoute),
+  onboardingRoute: useStore(state => state.onboardingRoute)
+}) 
\ No newline at end of file
diff --git a/store/store.ts b/store/store.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9f4e5e5779dd814d16d25f70cb40a782a37762dd
--- /dev/null
+++ b/store/store.ts
@@ -0,0 +1,667 @@
+import { create } from 'zustand'
+import { devtools } from 'zustand/middleware'
+import { UserInfo } from '@/types/user'
+import { calculatePlayerLevel, getLevelNumber, getPatientsPerDay } from './gameStoreUtils'
+import type { DoctorOfficeStats } from '@/types'
+
+/* --- Constants ----- */
+export const MOBILE_BREAKPOINT = 640  // sm
+export const TABLET_BREAKPOINT = 1024 // lg
+
+/* --- Types ---- */
+interface WindowSize {
+  width: number
+  height: number
+  isDesktop: boolean
+}
+
+export type ThemeType = 'cyberSpace' | 'sakuraTrees' | 'sunsetCity' | 'mykonosBlue'
+
+/* --- User Types ---- */
+interface UserProfile {
+  profile: {
+    userId?: string;
+    firstName?: string;
+    bio?: string;
+    coins?: number;
+    patientsCount?: number;
+    profilePhoto?: string;
+    studyPreferences?: {
+      dailyGoal?: number;
+      reminderTime?: string;
+    };
+    interfaceSettings?: {
+      darkMode?: boolean;
+      fontSize?: string;
+    };
+    tutorialProgress?: {
+      currentStep?: number;
+      completedRoutes?: string[];
+    };
+    completedSteps?: string[];
+    hasCompletedOnboarding?: boolean;
+    lastVisitedRoute?: string;
+    onboardingRoute?: string;
+  } | null;
+  isLoading: boolean;
+}
+
+interface UserInfoState {
+  userInfo: UserInfo | null;
+  isSubscribed: boolean;
+}
+
+interface UserStats {
+  coins: number;
+  isLoading: boolean;
+}
+
+/* --- Store Slices ---- */
+interface UISlice {
+  window: WindowSize
+  currentRoute: string
+  theme: ThemeType
+  setWindowSize: (size: WindowSize) => void
+  setCurrentRoute: (route: string) => void
+  setTheme: (theme: ThemeType) => void
+}
+
+/* --- User Slice ---- */
+interface UserSlice {
+  // UserProfile state
+  profile: UserProfile['profile'];
+  profileLoading: boolean;
+  isProfileComplete: boolean;
+  completedSteps: string[];
+  studyPreferences: {
+    dailyGoal: number;
+    reminderTime: string;
+  };
+  interfaceSettings: {
+    darkMode: boolean;
+    fontSize: string;
+  };
+  tutorialProgress: {
+    currentStep: number;
+    completedRoutes: string[];
+  };
+  hasCompletedOnboarding: boolean;
+  lastVisitedRoute: string;
+  onboardingRoute: string;
+  
+  // UserInfo state
+  userInfo: UserInfoState['userInfo'];
+  isSubscribed: boolean;
+  
+  // UserStats state
+  coins: number;
+  statsLoading: boolean;
+  error: string | null;
+  
+  // Actions
+  updateProfile: (updates: any) => Promise<void>;
+  refreshUserInfo: () => Promise<void>;
+  updateCoins: (amount: number) => Promise<void>;
+  updateCoinsDisplay: (newAmount: number) => void;
+  setIsSubscribed: (status: boolean) => void;
+  setCompletedSteps: (steps: string[]) => void;
+  addCompletedStep: (step: string) => void;
+  updateStudyPreferences: (preferences: Partial<UserSlice['studyPreferences']>) => void;
+  updateInterfaceSettings: (settings: Partial<UserSlice['interfaceSettings']>) => void;
+  updateTutorialProgress: (progress: Partial<UserSlice['tutorialProgress']>) => void;
+  setHasCompletedOnboarding: (completed: boolean) => void;
+  setLastVisitedRoute: (route: string) => void;
+  setOnboardingRoute: (route: string) => void;
+}
+
+/* --- Game Slice ---- */
+interface GameSlice {
+  // Game progress (matching local state names)
+  patientsPerDay: number; // Direct match with page.tsx
+  streakDays: number;     // Direct match with page.tsx
+  totalPatients: number;  // Direct match with page.tsx
+  userLevel: string;    // Changed from currentLevel (number) to string to match page.tsx
+  userRooms: string[];  // Changed from unlockedRooms to match page.tsx
+  
+  // Active game session
+  activeRooms: Set<string>;  // Direct match with page.tsx
+  completeAllRoom: boolean;  // Direct match with page.tsx
+  currentUserTestId: string | null; // Direct match with page.tsx
+  flashcardRoomId: string;   // Direct match with page.tsx
+  isFlashcardsOpen: boolean; // Direct match with page.tsx
+  isGameInProgress: boolean; // Direct match with page.tsx
+  
+  // Test results
+  correctCount: number;      // Direct match with page.tsx
+  testScore: number;         // Direct match with page.tsx
+  userResponses: any[];      // Direct match with page.tsx
+  wrongCount: number;        // Direct match with page.tsx
+  
+  // Actions
+  endGame: () => void;
+  resetGameState: () => void;
+  setActiveRooms: (rooms: Set<string>) => void;
+  setCompleteAllRoom: (complete: boolean) => void;
+  setCorrectCount: (count: number) => void;
+  setFlashcardRoomId: (roomId: string) => void;
+  setIsFlashcardsOpen: (isOpen: boolean) => void;
+  setUserResponses: (responses: any[]) => void;
+  setTestScore: (score: number) => void;
+  setTotalPatients: (count: number) => void;
+  setWrongCount: (count: number) => void;
+  setStreakDays: (days: number) => void;
+  setUserRooms: (rooms: string[]) => void;
+  startGame: (userTestId: string) => void;
+  unlockRoom: (roomId: string) => void;
+  updateUserLevel: () => void;
+}
+
+/* --- Store Type ---- */
+type Store = UISlice & UserSlice & GameSlice;
+
+export const useStore = create<Store>()(
+  devtools(
+    (set, get) => ({
+      //************************************** UI State *********************************************//
+
+      window: {
+        width: typeof window !== 'undefined' ? window.innerWidth : 1920,
+        height: typeof window !== 'undefined' ? window.innerHeight : 1080,
+        isDesktop: true
+      },
+      currentRoute: '/',
+      theme: 'cyberSpace',
+
+      // UI Actions
+      setWindowSize: (size) => set({ window: size }),
+      setCurrentRoute: (route) => set({ currentRoute: route }),
+      setTheme: (theme) => {
+        set({ theme })
+        if (typeof window !== 'undefined') {
+          localStorage.setItem('theme', theme)
+        }
+      },
+
+      //************************************** USER State *********************************************//
+
+
+      // User State
+      profile: null,
+      profileLoading: true,
+      isProfileComplete: false,
+      completedSteps: [],
+      studyPreferences: {
+        dailyGoal: 30, // Default: 30 minutes
+        reminderTime: '09:00', // Default: 9 AM
+      },
+      interfaceSettings: {
+        darkMode: false,
+        fontSize: 'medium',
+      },
+      tutorialProgress: {
+        currentStep: 0,
+        completedRoutes: [],
+      },
+      hasCompletedOnboarding: false,
+      lastVisitedRoute: '/',
+      onboardingRoute: '/onboarding',
+      userInfo: null,
+      isSubscribed: false,
+      coins: 0,
+      statsLoading: true,
+      error: null,
+
+      // User Actions
+      updateProfile: async (updates) => {
+        try {
+          // Get the current profile and email/userId for the API call
+          const currentProfile = get().profile;
+          const userInfo = get().userInfo;
+          
+          if (!userInfo || (!userInfo.email && !userInfo.userId)) {
+            console.error('Cannot update profile: No user email or ID available');
+            return;
+          }
+          
+          // Determine query parameter
+          const queryParam = userInfo.email 
+            ? `email=${encodeURIComponent(userInfo.email)}` 
+            : `userId=${userInfo.userId}`;
+          
+          // Implement your API call here
+          const response = await fetch(`/api/user-info/profile?${queryParam}`, {
+            method: 'PATCH',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify(updates)
+          });
+          
+          if (!response.ok) throw new Error('Failed to update profile');
+          
+          const updatedProfile = await response.json();
+          
+          // Update the profile and related state
+          set({ 
+            profile: updatedProfile,
+            profileLoading: false,
+            // Update other profile-related state if present in the response
+            ...(updatedProfile.completedSteps && { completedSteps: updatedProfile.completedSteps }),
+            ...(updatedProfile.studyPreferences && { studyPreferences: updatedProfile.studyPreferences }),
+            ...(updatedProfile.interfaceSettings && { interfaceSettings: updatedProfile.interfaceSettings }),
+            ...(updatedProfile.tutorialProgress && { tutorialProgress: updatedProfile.tutorialProgress }),
+            ...(updatedProfile.hasCompletedOnboarding !== undefined && { 
+              hasCompletedOnboarding: updatedProfile.hasCompletedOnboarding 
+            }),
+            ...(updatedProfile.lastVisitedRoute && { lastVisitedRoute: updatedProfile.lastVisitedRoute }),
+            ...(updatedProfile.onboardingRoute && { onboardingRoute: updatedProfile.onboardingRoute }),
+          });
+          
+          // Update isProfileComplete based on completedSteps
+          const steps = updatedProfile.completedSteps || get().completedSteps;
+          set({ isProfileComplete: steps.length >= 3 }); // Assuming 3 steps is complete
+        } catch (error) {
+          console.error('Failed to update profile:', error);
+        }
+      },
+      
+      refreshUserInfo: async () => {
+        try {
+          // Only set loading if not already loading
+          const currentState = get();
+          if (!currentState.statsLoading && !currentState.profileLoading) {
+            set({ statsLoading: true, profileLoading: true, error: null });
+          }
+
+          // Add loading timeout
+          const loadingTimeout = setTimeout(() => {
+            const state = get();
+            if (state.statsLoading || state.profileLoading) {
+              set({ 
+                statsLoading: false,
+                profileLoading: false,
+                error: 'Loading timeout - please try again'
+              });
+            }
+          }, 10000);
+
+          // Batch all fetch requests together
+          const [userInfoResponse, profileResponse] = await Promise.all([
+            fetch('/api/user-info'),
+            fetch('/api/user-info/profile')
+          ]);
+
+          clearTimeout(loadingTimeout);
+
+          if (!userInfoResponse.ok) throw new Error('Failed to fetch user info');
+          const userInfo = await userInfoResponse.json();
+
+          // Prepare single state update with only changed values
+          const updates: Partial<Store> = {
+            userInfo,
+            statsLoading: false,
+            profileLoading: false,
+            error: null
+          };
+
+          // Only update coins if changed
+          if (userInfo.score !== get().coins) {
+            updates.coins = userInfo.score || 0;
+          }
+
+          // Only update subscription if changed
+          const newSubStatus = userInfo.subscriptionType === 'gold' || userInfo.subscriptionType === 'premium';
+          if (newSubStatus !== get().isSubscribed) {
+            updates.isSubscribed = newSubStatus;
+          }
+
+          if (profileResponse.ok) {
+            const profileData = await profileResponse.json();
+            const currentProfile = get().profile;
+            
+            // Only update profile fields that have changed
+            if (JSON.stringify(currentProfile) !== JSON.stringify(profileData)) {
+              Object.assign(updates, {
+                profile: profileData,
+                completedSteps: profileData.completedSteps || [],
+                studyPreferences: profileData.studyPreferences || {
+                  dailyGoal: 30,
+                  reminderTime: '09:00'
+                },
+                interfaceSettings: profileData.interfaceSettings || {
+                  darkMode: false,
+                  fontSize: 'medium'
+                },
+                tutorialProgress: profileData.tutorialProgress || {
+                  currentStep: 0,
+                  completedRoutes: []
+                },
+                hasCompletedOnboarding: profileData.hasCompletedOnboarding || false,
+                lastVisitedRoute: profileData.lastVisitedRoute || '/',
+                onboardingRoute: profileData.onboardingRoute || '/onboarding',
+                isProfileComplete: (profileData.completedSteps || []).length >= 3
+              });
+            }
+          }
+
+          // Single state update
+          set(updates);
+
+        } catch (error) {
+          console.error('Error in refreshUserInfo:', error);
+          set({ 
+            error: error instanceof Error ? error.message : 'Failed to refresh user info',
+            statsLoading: false,
+            profileLoading: false
+          });
+        }
+      },
+      
+      updateCoins: async (amount) => {
+        try {
+          // Implement your API call to update coins/score
+          const response = await fetch('/api/user/score', {
+            method: 'POST',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify({ amount })
+          });
+          
+          if (!response.ok) throw new Error('Failed to update coins');
+          
+          // After successful update, refresh user info to get updated data
+          await get().refreshUserInfo();
+        } catch (error) {
+          console.error('Failed to update coins:', error);
+        }
+      },
+      
+      updateCoinsDisplay: (newAmount) => {
+        set({ coins: newAmount });
+      },
+      
+      setIsSubscribed: (status) => {
+        set({ isSubscribed: status });
+      },
+      
+      // New profile-related actions
+      setCompletedSteps: (steps) => {
+        set({ completedSteps: steps });
+        set({ isProfileComplete: steps.length >= 3 }); // Assuming 3 steps is complete
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ profile: { ...profile, completedSteps: steps } });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ completedSteps: steps });
+      },
+      
+      addCompletedStep: (step) => {
+        const currentSteps = get().completedSteps;
+        if (!currentSteps.includes(step)) {
+          const newSteps = [...currentSteps, step];
+          set({ completedSteps: newSteps });
+          set({ isProfileComplete: newSteps.length >= 3 }); // Assuming 3 steps is complete
+          
+          // Also update the profile object for consistency
+          const profile = get().profile;
+          if (profile) {
+            set({ profile: { ...profile, completedSteps: newSteps } });
+          }
+          
+          // Persist to backend if possible
+          get().updateProfile({ completedSteps: newSteps });
+        }
+      },
+      
+      updateStudyPreferences: (preferences) => {
+        const currentPreferences = get().studyPreferences;
+        const updatedPreferences = { ...currentPreferences, ...preferences };
+        set({ studyPreferences: updatedPreferences });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              studyPreferences: updatedPreferences 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ studyPreferences: updatedPreferences });
+      },
+      
+      updateInterfaceSettings: (settings) => {
+        const currentSettings = get().interfaceSettings;
+        const updatedSettings = { ...currentSettings, ...settings };
+        set({ interfaceSettings: updatedSettings });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              interfaceSettings: updatedSettings 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ interfaceSettings: updatedSettings });
+      },
+      
+      updateTutorialProgress: (progress) => {
+        const currentProgress = get().tutorialProgress;
+        const updatedProgress = { ...currentProgress, ...progress };
+        set({ tutorialProgress: updatedProgress });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              tutorialProgress: updatedProgress 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ tutorialProgress: updatedProgress });
+      },
+      
+      setHasCompletedOnboarding: (completed) => {
+        set({ hasCompletedOnboarding: completed });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              hasCompletedOnboarding: completed 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ hasCompletedOnboarding: completed });
+      },
+      
+      setLastVisitedRoute: (route) => {
+        set({ lastVisitedRoute: route });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              lastVisitedRoute: route 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ lastVisitedRoute: route });
+      },
+      
+      setOnboardingRoute: (route) => {
+        set({ onboardingRoute: route });
+        
+        // Also update the profile object for consistency
+        const profile = get().profile;
+        if (profile) {
+          set({ 
+            profile: { 
+              ...profile, 
+              onboardingRoute: route 
+            } 
+          });
+        }
+        
+        // Persist to backend if possible
+        get().updateProfile({ onboardingRoute: route });
+      },
+      
+      //************************************** Game State *********************************************//
+      
+      // Game progress
+      patientsPerDay: 4,
+      streakDays: 0,
+      totalPatients: 0,
+      userLevel: "PATIENT LEVEL",
+      userRooms: [],
+      
+      // Active game session
+      activeRooms: new Set<string>(["WaitingRoom0"]),
+      completeAllRoom: false,
+      currentUserTestId: null,
+      flashcardRoomId: "",
+      isFlashcardsOpen: false,
+      isGameInProgress: false,
+      
+      // Test results
+      correctCount: 0,
+      testScore: 0,
+      userResponses: [],
+      wrongCount: 0,
+      
+      // Game Actions
+      endGame: () => {
+        set({ 
+          isGameInProgress: false,
+          currentUserTestId: null,
+          userResponses: [],
+          correctCount: 0,
+          wrongCount: 0,
+          testScore: 0,
+        });
+      },
+      
+      resetGameState: () => {
+        set({ 
+          isGameInProgress: false,
+          currentUserTestId: null,
+          activeRooms: new Set<string>(["WaitingRoom0"]),
+          completeAllRoom: false,
+          userResponses: [],
+          correctCount: 0,
+          wrongCount: 0,
+          testScore: 0,
+          isFlashcardsOpen: false,
+        });
+      },
+      
+      setActiveRooms: (rooms) => {
+        // Ensure we're always creating a new Set object
+        set({ activeRooms: new Set(rooms) });
+      },
+      
+      setCompleteAllRoom: (complete) => {
+        set({ completeAllRoom: complete });
+      },
+      
+      setCorrectCount: (count) => {
+        set({ correctCount: count });
+      },
+      
+      setFlashcardRoomId: (roomId) => {
+        set({ flashcardRoomId: roomId });
+      },
+      
+      setIsFlashcardsOpen: (isOpen) => {
+        set({ isFlashcardsOpen: isOpen });
+      },
+      
+      setUserResponses: (responses) => {
+        set({ userResponses: responses });
+      },
+      
+      setTestScore: (score) => {
+        set({ testScore: score });
+      },
+      
+      setTotalPatients: (count) => {
+        set({ totalPatients: count });
+      },
+      
+      setWrongCount: (count) => {
+        set({ wrongCount: count });
+      },
+      
+      setStreakDays: (days) => {
+        set({ streakDays: days });
+      },
+      
+      setUserRooms: (rooms) => {
+        set({ userRooms: rooms });
+        get().updateUserLevel();
+      },
+      
+      startGame: (userTestId) => {
+        set({ 
+          isGameInProgress: true,
+          currentUserTestId: userTestId,
+        });
+      },
+      
+      unlockRoom: (roomId) => {
+        const currentRooms = get().userRooms;
+        if (!currentRooms.includes(roomId)) {
+          const updatedRooms = [...currentRooms, roomId];
+          set({ userRooms: updatedRooms });
+          get().updateUserLevel();
+        }
+      },
+      
+      updateUserLevel: () => {
+        const { userRooms } = get();
+        const playerLevel = calculatePlayerLevel(userRooms);
+        const levelNumber = getLevelNumber(playerLevel);
+        const patientsPerDay = getPatientsPerDay(levelNumber);
+        
+        set({
+          userLevel: playerLevel,
+          patientsPerDay
+        });
+      },
+    }),
+    { name: 'MYMCAT Store' }
+  )
+) 
+
+
+export type Card = {
+  id: string;
+  question: string;
+  answer: string;
+  explanation?: string;
+  category?: string;
+  difficulty?: string;
+  otherOptions?: string[];
+}; 
\ No newline at end of file
diff --git a/types/user.ts b/types/user.ts
new file mode 100644
index 0000000000000000000000000000000000000000..351cbd060c6757dec7aedc398aa96966169397f5
--- /dev/null
+++ b/types/user.ts
@@ -0,0 +1,43 @@
+// types/user.ts
+// This file contains shared types for user-related data
+
+export interface OnboardingInfo {
+  targetScore?: number;
+  testDate?: string;
+  // Add other onboarding fields as needed
+}
+
+export interface UserInfo {
+  unlocks?: string[];
+  userId: string;
+  bio: string;
+  firstName: string;
+  apiCount: number;
+  score: number;
+  streak: number;
+  email?: string;
+  clinicRooms: string;
+  hasPaid: boolean;
+  subscriptionType: string;
+  diagnosticScores: {
+    total: string;
+    cp: string;
+    cars: string;
+    bb: string;
+    ps: string;
+  };
+  notificationPreference?: string;
+  onboardingInfo?: OnboardingInfo;
+  referrals?: any[];
+}
+
+export interface Referral {
+  id: string;
+  userId: string;
+  referrerName: string;
+  referrerEmail: string;
+  friendEmail: string;
+  friendUserId: string;
+  createdAt: Date;
+  joinedAt: Date | null;
+} 
\ No newline at end of file
